"""Arcade Starter Tools for Exa_Search

DO NOT EDIT THIS MODULE DIRECTLY.

THIS MODULE WAS AUTO-GENERATED BY TRANSPILING THE API STARTER TOOL JSON DEFINITIONS
IN THE ../wrapper_tools DIRECTORY INTO PYTHON CODE. ANY CHANGES TO THIS MODULE WILL
BE OVERWRITTEN BY THE TRANSPILER.
"""

import asyncio
import json
from enum import Enum
from typing import Annotated, Any

import httpx
import jsonschema
from arcade_tdk import ToolContext, tool
from arcade_tdk.errors import RetryableToolError

from .request_body_schemas import REQUEST_BODY_SCHEMAS

# Retry configuration
INITIAL_RETRY_DELAY = 0.5  # seconds

HTTP_CLIENT = httpx.AsyncClient(
    timeout=httpx.Timeout(60.0, connect=10.0),
    limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
    transport=httpx.AsyncHTTPTransport(retries=3),
    http2=True,
    follow_redirects=True,
)


class ToolMode(str, Enum):
    """Mode for tools with complex request bodies."""

    GET_REQUEST_SCHEMA = "get_request_schema"
    EXECUTE = "execute"


def remove_none_values(data: dict[str, Any]) -> dict[str, Any]:
    return {k: v for k, v in data.items() if v is not None}


async def make_request(
    url: str,
    method: str,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    content: str | None = None,
    data: dict[str, Any] | None = None,
    auth: tuple[str, str] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with retry logic for 5xx server errors."""
    for attempt in range(max_retries):
        try:
            response = await HTTP_CLIENT.request(
                url=url,
                auth=auth,
                method=method,
                params=params,
                headers=headers,
                content=content,
            )
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            # Only retry on 5xx server errors
            if e.response.status_code >= 500 and attempt < max_retries - 1:
                # Exponential backoff: 0.5s, 1s, 2s
                await asyncio.sleep(INITIAL_RETRY_DELAY * (2**attempt))
                continue
            # Re-raise for 4xx errors or if max retries reached
            raise
        except httpx.RequestError:
            # Don't retry request errors (network issues are handled by transport)
            raise
        else:
            return response

    # This should never be reached, but satisfies type checker
    raise httpx.RequestError("Max retries exceeded")  # noqa: TRY003


async def make_request_with_schema_validation(
    url: str,
    method: str,
    request_data: dict[str, Any],
    schema: dict[str, Any] | str,
    auth: tuple[str, str] | None = None,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with schema validation on format errors."""
    # Parse schema if it's a string, skip validation if parsing fails
    parsed_schema = None
    if isinstance(schema, str):
        try:
            parsed_schema = json.loads(schema)
        except Exception:
            # If schema parsing fails, just skip validation
            parsed_schema = None
    else:
        parsed_schema = schema

    try:
        response = await make_request(
            url=url,
            auth=auth,
            method=method,
            params=params,
            headers=headers,
            content=json.dumps(request_data),
            max_retries=max_retries,
        )
    except httpx.HTTPStatusError as e:
        # Only provide schema validation for format-related errors
        if e.response.status_code in (400, 422):
            api_error_details = f"API returned {e.response.status_code}: {e.response.text}"

            # Only run validation if we have a valid parsed schema
            if parsed_schema is not None:
                # Run validation to provide additional context
                is_valid, validation_error = validate_json_against_schema(
                    request_data, parsed_schema
                )

                if not is_valid:
                    # Schema validation found issues - additional context
                    additional_context = (
                        f"{api_error_details}\n\n"
                        f"Schema validation found the following issues:\n"
                        f"{validation_error}"
                    )
                else:
                    # Schema validation passed - just show API error
                    additional_context = api_error_details
            else:
                # No valid schema - just show API error
                additional_context = api_error_details

            raise RetryableToolError(
                message=(f"API request failed with validation error: {e.response.status_code}"),
                developer_message=api_error_details,
                additional_prompt_content=additional_context,
            ) from e
        else:
            # For non-validation errors, re-raise as-is
            raise
    else:
        return response


def validate_json_against_schema(
    json_data: dict[str, Any], schema: dict[str, Any]
) -> tuple[bool, str | None]:
    """Validate JSON data against an OpenAPI/JSON Schema.

    This provides full JSON Schema Draft 7 validation including:
    - Required fields, types, enums
    - Pattern validation (regex)
    - Format validation (email, uuid, date-time, etc.)
    - Min/max length and values
    - oneOf, anyOf, allOf
    - And all other JSON Schema features

    Args:
        json_data: The JSON data to validate
        schema: The JSON Schema to validate against

    Returns:
        Tuple of (is_valid, error_messages). If valid, error_messages is None.
        If invalid, error_messages contains all validation errors.
    """
    try:
        validator = jsonschema.Draft7Validator(
            schema, format_checker=jsonschema.Draft7Validator.FORMAT_CHECKER
        )
        # Collect ALL validation errors
        errors = list(validator.iter_errors(json_data))
        if errors:
            # Format all errors with their paths
            error_messages = []
            for error in errors:
                error_path = ".".join(str(p) for p in error.path) if error.path else "root"
                error_messages.append(f"{error.message} at {error_path}")
            # Join all errors with newlines
            return False, "\n".join(error_messages)
        else:
            return True, None
    except jsonschema.SchemaError as e:
        return False, f"Invalid schema: {e.message}"
    except Exception as e:
        return False, f"Validation error: {e!s}"


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def exa_search_query(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'search'."]:
    """Execute a search query with Exa for relevant results.

    This tool performs a search using an Exa prompt-engineered query to retrieve a list of relevant results. It can optionally include content details. Use this tool to obtain information based on specific search queries.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["EXASEARCHQUERY"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["EXASEARCHQUERY"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["EXASEARCHQUERY"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.exa.ai/search",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["EXASEARCHQUERY"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def find_similar_links(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'findSimilar'."]:
    """Find similar links based on a provided link.

    Use this tool to find and retrieve links that are similar to a given link. Optionally, the contents of these similar links can also be obtained.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["FINDSIMILARLINKS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["FINDSIMILARLINKS"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["FINDSIMILARLINKS"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.exa.ai/findSimilar",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["FINDSIMILARLINKS"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def retrieve_contents(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getContents'."]:
    """Retrieve content data using Exa_Search's API.

    Use this tool to retrieve content data from Exa_Search by calling the getContents API endpoint. Ideal for accessing specific data managed by Exa_Search.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["RETRIEVECONTENTS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["RETRIEVECONTENTS"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["RETRIEVECONTENTS"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.exa.ai/contents",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["RETRIEVECONTENTS"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def perform_search_and_answer(
    context: ToolContext,
    search_query: Annotated[str, "The question or query to be answered by the search tool."],
    enable_streaming_response: Annotated[
        bool | None, "Set to true to receive the response as a server-sent events (SSS) stream."
    ] = False,
    include_full_text_content: Annotated[
        bool | None, "Set to true to include full text content in the search results."
    ] = False,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'answer'."]:
    """Performs search and provides an answer or summary.

    This tool executes a search based on the input query. It returns either a direct answer or a detailed summary with citations, adapting to the type of query provided."""  # noqa: E501
    request_data: Any = {
        "query": search_query,
        "stream": enable_streaming_response,
        "text": include_full_text_content,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/answer",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def get_research_requests(
    context: ToolContext,
    pagination_cursor: Annotated[
        str | None, "The cursor string used to navigate through paginated research results."
    ] = None,
    results_limit: Annotated[
        float | None, "The number of results to return in the paginated response."
    ] = 10,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'ResearchController_listResearch'."]:
    """Retrieve a paginated list of research requests.

    Call this tool to get a list of research requests with pagination support. Useful for accessing multiple research entries from the Exa_Search service."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/research/v1",
        method="GET",
        params=remove_none_values({"cursor": pagination_cursor, "limit": results_limit}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def create_research_request(
    context: ToolContext,
    research_request_body: Annotated[
        dict[str, str],
        "A JSON object containing details about the research request, such as topic, objectives, and any specific requirements.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'ResearchController_createResearch'."
]:
    """Creates a new research request.

    Use this tool to create a new research request when initiating a research study or project."""
    request_data: Any = research_request_body
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/research/v1",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def retrieve_research_by_id(
    context: ToolContext,
    enable_real_time_updates: Annotated[
        str, "Set to 'true' to enable real-time SSE updates for research retrieval."
    ],
    events_to_track: Annotated[
        str,
        "Specify the type of events to track. Typically used for real-time updates or specific event filtering.",  # noqa: E501
    ],
    research_id: Annotated[
        str, "The unique identifier for the research project to retrieve details."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'ResearchController_getResearch'."]:
    """Retrieve research details using a unique ID.

    Call this tool to get detailed information about a specific research project using its unique ID. Ideal for accessing comprehensive research data quickly."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/research/v1/{researchId}".format(researchId=research_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"stream": enable_real_time_updates, "events": events_to_track}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def create_new_webset(
    context: ToolContext,
    webset_configuration: Annotated[
        dict[str, str],
        "JSON containing configurations for search, import, and enrichment. Supports optional custom identifiers.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-create'."]:
    """Create a new Webset with optional configurations.

    This tool creates a new Webset, allowing optional configurations for search, import, and enrichment. It begins processing automatically upon creation. Use it to initiate Websets with custom identifiers for easy integration."""  # noqa: E501
    request_data: Any = webset_configuration
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/websets",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def get_websets_list(
    context: ToolContext,
    number_of_websets_to_return: Annotated[
        float | None, "Specify the number of Websets you want to retrieve in the response."
    ] = 25,
    pagination_cursor: Annotated[
        str | None, "The cursor used for paginating through the websets list."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-list'."]:
    """Retrieve a list of websets with pagination support.

    Use this tool to obtain a list of websets. Results can be paginated using a cursor parameter to navigate through the list."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/websets",
        method="GET",
        params=remove_none_values({
            "cursor": pagination_cursor,
            "limit": number_of_websets_to_return,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def get_webset_info(
    context: ToolContext,
    webset_identifier: Annotated[str, "The ID or external ID of the Webset for retrieval."],
    expand_resources: Annotated[
        list[str] | None,
        "Provide an array of resource names to expand in the response for detailed information.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-get'."]:
    """Retrieve information about a specific Webset using its ID.

    This tool is used to obtain detailed information about a specific Webset by providing its ID. It should be called when you need to access data related to a particular Webset instance."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/websets/{id}".format(id=webset_identifier),  # noqa: UP032
        method="GET",
        params=remove_none_values({"expand": expand_resources}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def update_webset(
    context: ToolContext,
    webset_identifier: Annotated[
        str, "The unique identifier or externalId of the webset to update."
    ],
    webset_update_details: Annotated[
        dict[str, str],
        "JSON object containing the updated details for the webset. Include necessary fields to modify, such as title, description, or content.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-update'."]:
    """Update details of a specified webset.

    Use this tool to update information of an existing webset by specifying the webset ID."""
    request_data: Any = webset_update_details
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/websets/{id}".format(id=webset_identifier),  # noqa: UP032
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def delete_webset(
    context: ToolContext,
    webset_identifier: Annotated[
        str, "The identifier (id or externalId) of the Webset to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-delete'."]:
    """Delete a specified webset and its items.

    Use this tool to permanently remove a webset and all associated items from the system. This action cannot be undone."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/websets/{id}".format(id=webset_identifier),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def cancel_webset_operations(
    context: ToolContext,
    webset_identifier: Annotated[
        str, "The ID or external ID of the Webset to cancel its operations."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-cancel'."]:
    """Cancel all operations on a specified Webset.

    Use this tool to stop any ongoing enrichments or searches in a Webset, changing its status to idle."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/websets/{id}/cancel".format(id=webset_identifier),  # noqa: UP032
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def preview_webset_query(
    context: ToolContext,
    search_query_input: Annotated[
        dict[str, str],
        "JSON object containing the search query and additional parameters for previewing query decomposition.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-preview'."]:
    """Preview search query decomposition for a webset.

    This tool previews how a search query will be decomposed before creating a webset. It shows the detected entity type, generated search criteria, and available enrichment columns. Use this to understand search interpretation before creating a full webset."""  # noqa: E501
    request_data: Any = search_query_input
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/websets/preview",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def get_webset_item(
    context: ToolContext,
    webset_identifier: Annotated[
        str, "The ID or external ID of the Webset to retrieve the item from."
    ],
    webset_item_id: Annotated[str, "The unique identifier for the Webset item to retrieve."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-items-get'."]:
    """Retrieves a specific Webset Item by ID from Exa_Websets.

    Use this tool to get detailed information about a specific Webset Item identified by its ID within a specified webset. Useful for retrieving existing items for review or processing."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/websets/{webset}/items/{id}".format(  # noqa: UP032
            webset=webset_identifier, id=webset_item_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def delete_webset_item(
    context: ToolContext,
    webset_identifier: Annotated[
        str, "The identifier or externalId of the Webset from which the item will be deleted."
    ],
    webset_item_id: Annotated[
        str,
        "The unique identifier for the Webset item to delete. Use this to specify which item should be removed from the webset.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-items-delete'."]:
    """Delete an item from a webset, stopping its enrichment process.

    Use this tool to remove an item from a specified webset, which cancels any ongoing enrichment process for that item."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/websets/{webset}/items/{id}".format(  # noqa: UP032
            webset=webset_identifier, id=webset_item_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def list_webset_items(
    context: ToolContext,
    webset_identifier: Annotated[
        str,
        "The ID or external ID of the Webset to retrieve items from. This identifies which Webset's items are listed.",  # noqa: E501
    ],
    pagination_cursor: Annotated[
        str | None, "A string representing the cursor for paginating through the results."
    ] = None,
    results_limit: Annotated[float | None, "Specify the number of Webset items to return."] = 20,
    source_id: Annotated[
        str | None,
        "The unique identifier for the source. Required to specify which source to retrieve webset items from.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-items-list'."]:
    """Retrieve a list of items from a specified Webset.

    Use this tool to obtain a list of items from a specific Webset. You can paginate through the results using the cursor parameter."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/websets/{webset}/items".format(webset=webset_identifier),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "cursor": pagination_cursor,
            "limit": results_limit,
            "sourceId": source_id,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def create_webset_enrichment(
    context: ToolContext,
    enrichment_details: Annotated[
        dict[str, str],
        "The JSON object containing details and specifications for the enrichment to be created. Include data fields and values needed for the enrichment process.",  # noqa: E501
    ],
    webset_identifier: Annotated[str, "The ID or external ID of the webset to enrich."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-enrichments-create'."]:
    """Create an enrichment for a specified webset.

    This tool is used to create an enrichment for a specific webset. It should be called when you need to add additional data or enhancements to a webset."""  # noqa: E501
    request_data: Any = enrichment_details
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/websets/{webset}/enrichments".format(webset=webset_identifier),  # noqa: UP032
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def update_webset_enrichment(
    context: ToolContext,
    enrichment_configuration_data: Annotated[
        dict[str, str],
        "JSON object containing new enrichment configuration data for the specified webset.",
    ],
    enrichment_id: Annotated[str, "Unique identifier of the enrichment configuration to update."],
    webset_identifier: Annotated[
        str,
        "The unique identifier or name for the webset whose enrichment configuration you want to update.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-enrichments-update'."]:
    """Update enrichment configuration for a specified webset.

    Use this tool to update the enrichment settings of a specific webset. Ideal for modifying configurations of existing webset enrichments."""  # noqa: E501
    request_data: Any = enrichment_configuration_data
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/websets/{webset}/enrichments/{id}".format(  # noqa: UP032
            webset=webset_identifier, id=enrichment_id
        ),
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def get_enrichment_details(
    context: ToolContext,
    enrichment_id: Annotated[str, "The unique identifier for the enrichment to retrieve details."],
    webset_identifier: Annotated[
        str, "The ID or external ID of the Webset to identify it uniquely."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-enrichments-get'."]:
    """Retrieve details of a specific webset enrichment.

    This tool retrieves detailed information about a specific enrichment within a webset by using its unique identifier. It should be called when you need to access the details of an enrichment for analysis or reporting purposes."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/websets/{webset}/enrichments/{id}".format(  # noqa: UP032
            webset=webset_identifier, id=enrichment_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def delete_enrichment(
    context: ToolContext,
    enrichment_id: Annotated[
        str,
        "The unique identifier of the enrichment to delete, used to specify which enrichment to remove.",  # noqa: E501
    ],
    webset_identifier: Annotated[
        str, "The ID or external ID of the Webset to identify which Webset's enrichment to delete."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-enrichments-delete'."]:
    """Delete an enrichment and cancel any running processes.

    Use this tool to delete an enrichment, cancel any running processes associated with it, and remove all existing enrichment results."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/websets/{webset}/enrichments/{id}".format(  # noqa: UP032
            webset=webset_identifier, id=enrichment_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def cancel_running_enrichments(
    context: ToolContext,
    enrichment_id: Annotated[
        str,
        "The ID of the enrichment to be canceled. This should be the unique identifier associated with the enrichment process.",  # noqa: E501
    ],
    webset_identifier: Annotated[str, "The id or externalId of the Webset to be canceled."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-enrichments-cancel'."]:
    """Cancel all running enrichments.

    Use this tool to cancel any running enrichment processes. Once an enrichment is canceled, it cannot be resumed."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/websets/{webset}/enrichments/{id}/cancel".format(  # noqa: UP032
            webset=webset_identifier, id=enrichment_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def create_webhook_notification(
    context: ToolContext,
    webhook_configuration: Annotated[
        dict[str, str],
        "The JSON configuration for the webhook, including events to listen for and the target URL for notifications.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webhooks-create'."]:
    """Create a webhook to receive event notifications.

    This tool creates a webhook for receiving notifications about specific events in Exa Websets. When an event occurs, Exa sends details to the specified URL. Use this tool to set up and start receiving these event notifications immediately."""  # noqa: E501
    request_data: Any = webhook_configuration
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/webhooks",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def get_list_of_webhooks(
    context: ToolContext,
    pagination_cursor: Annotated[
        str | None,
        "A string used to paginate through the webhook results. Use this to fetch the next page of webhooks.",  # noqa: E501
    ] = None,
    results_per_page: Annotated[
        float | None, "Specify the number of webhooks to return per page, up to a maximum of 200."
    ] = 25,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webhooks-list'."]:
    """Retrieve a paginated list of webhooks from your account.

    This tool fetches a list of all webhooks associated with your account. It supports pagination through the use of 'limit' and 'cursor' parameters to navigate through pages."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/webhooks",
        method="GET",
        params=remove_none_values({"cursor": pagination_cursor, "limit": results_per_page}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def get_webhook_info(
    context: ToolContext,
    webhook_id: Annotated[
        str,
        "The unique identifier for the webhook. This ID is necessary to retrieve specific details about the webhook.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webhooks-get'."]:
    """Retrieve information about a specific webhook by ID.

    This tool is used to get details about a webhook using its unique ID. It should be called when users need to know specific attributes of a webhook, excluding its secret."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/webhooks/{id}".format(id=webhook_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def update_webhook_settings(
    context: ToolContext,
    webhook_id: Annotated[str, "The unique identifier of the webhook to be updated."],
    webhook_update_details: Annotated[
        dict[str, str],
        "A JSON object detailing updates for the webhook's events, URL, or metadata.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webhooks-update'."]:
    """Update events, URL, or metadata for a webhook instantly.

    Use this tool to modify a webhook's settings, such as the events it listens to, its notification URL, or its associated metadata. The current status of the webhook, whether active or inactive, is retained after any updates."""  # noqa: E501
    request_data: Any = webhook_update_details
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/webhooks/{id}".format(id=webhook_id),  # noqa: UP032
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def delete_webhook(
    context: ToolContext,
    webhook_id: Annotated[str, "The unique identifier for the webhook to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webhooks-delete'."]:
    """Delete a webhook to stop receiving notifications.

    The tool removes a webhook from your account, immediately stopping all notifications with no option to undo. To restore, a new webhook must be created."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/webhooks/{id}".format(id=webhook_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def list_webhook_attempts(
    context: ToolContext,
    webhook_id: Annotated[
        str, "The unique identifier for the specific webhook whose attempts are being listed."
    ],
    event_type_filter: Annotated[
        str | None,
        "Filter results by specific event type. Options include events like 'webset.created', 'webset.deleted', etc.",  # noqa: E501
    ] = None,
    filter_by_success_status: Annotated[
        bool | None,
        "Filter webhook attempts by their success status: true for successful, false for unsuccessful.",  # noqa: E501
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "A string representing the position in the paginated results to continue retrieving data from.",  # noqa: E501
    ] = None,
    result_limit: Annotated[
        float | None, "Specify the number of webhook attempt results to return."
    ] = 25,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webhooks-attempts-list'."]:
    """Retrieve all attempts made by a specific webhook.

    Use this tool to list all the attempts of a specific webhook, sorted in descending order. This can help in tracking and analyzing webhook activities."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/webhooks/{id}/attempts".format(id=webhook_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "cursor": pagination_cursor,
            "limit": result_limit,
            "eventType": event_type_filter,
            "successful": filter_by_success_status,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def list_system_events(
    context: ToolContext,
    event_types_filter: Annotated[
        list[str] | None,
        "Specify an array of event types to filter the results by. Each type should be a string.",
    ] = None,
    filter_created_before: Annotated[
        str | None,
        "Filter events created before or at this timestamp (inclusive). Must be a valid ISO 8601 datetime string in UTC.",  # noqa: E501
    ] = None,
    filter_events_created_after: Annotated[
        str | None,
        "Filter events created after or at this timestamp. Use a valid ISO 8601 datetime string in UTC.",  # noqa: E501
    ] = None,
    pagination_cursor: Annotated[
        str | None, "String to paginate through the results of the event list."
    ] = None,
    results_limit: Annotated[
        float | None,
        "Specify the maximum number of event results to return. This should be a positive integer.",
    ] = 25,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'events-list'."]:
    """Retrieve a list of all system events.

    Use this tool to list all events that have occurred in the system. It supports pagination through the `cursor` parameter."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/events",
        method="GET",
        params=remove_none_values({
            "cursor": pagination_cursor,
            "limit": results_limit,
            "types": event_types_filter,
            "createdBefore": filter_created_before,
            "createdAfter": filter_events_created_after,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def get_event_by_id(
    context: ToolContext,
    event_id: Annotated[str, "The unique ID of the event to fetch details for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'events-get'."]:
    """Retrieve details of a specific event by its ID.

    This tool fetches details of a single event using its unique ID. It is useful for when you need information about a specific event stored in the Exa_Websets service."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/events/{id}".format(id=event_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def create_webset_search(
    context: ToolContext,
    search_criteria: Annotated[
        dict[str, str],
        "A JSON object specifying the criteria for the new search within the webset. Include relevant attributes and values for filtering.",  # noqa: E501
    ],
    webset_id: Annotated[
        str,
        "The ID of the Webset to create a new search in. This should be a valid string that uniquely identifies the Webset.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-searches-create'."]:
    """Create a new search for a specified webset.

    This tool creates a new search within a webset, reusing previous search results and evaluating them against new criteria. Use it when you need to generate a new search query for a webset."""  # noqa: E501
    request_data: Any = search_criteria
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/websets/{webset}/searches".format(webset=webset_id),  # noqa: UP032
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def get_search_by_id(
    context: ToolContext,
    search_id: Annotated[str, "The unique ID of the search to retrieve details for."],
    webset_id: Annotated[
        str, "The unique identifier for the Webset to specify which Webset's Search to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-searches-get'."]:
    """Retrieve search details by ID from Exa Websets.

    Use this tool to get the details of a specific search using its unique ID within Exa Websets."""
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/websets/{webset}/searches/{id}".format(  # noqa: UP032
            webset=webset_id, id=search_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def cancel_running_search(
    context: ToolContext,
    search_id: Annotated[str, "The unique identifier for the search task you wish to cancel."],
    webset_id: Annotated[str, "The unique identifier of the Webset to be canceled."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'websets-searches-cancel'."]:
    """Cancel a currently running search task.

    Use this tool to cancel an ongoing search process. It's useful when you need to stop a search that is currently running, either individually or by canceling all at once."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/websets/{webset}/searches/{id}/cancel".format(  # noqa: UP032
            webset=webset_id, id=search_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def create_webset_monitor(
    context: ToolContext,
    webset_monitor_configuration: Annotated[
        dict[str, str],
        "A JSON object detailing the configuration for the monitor, including search and refresh operations, cron schedule, and timezone.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'monitors-create'."]:
    """Create a monitor to keep Websets updated with fresh data.

    Use this tool to set up a monitor that automatically updates your Websets by performing search and refresh operations on a defined schedule. Configure using cron expressions and timezones for precise control."""  # noqa: E501
    request_data: Any = webset_monitor_configuration
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/monitors",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def list_webset_monitors(
    context: ToolContext,
    pagination_cursor: Annotated[
        str | None, "A string used to paginate through the results of the Webset monitors list."
    ] = None,
    results_limit: Annotated[
        float | None,
        "Specifies the number of monitor results to return in the list. Use this to control the size of the response.",  # noqa: E501
    ] = 25,
    webset_id: Annotated[
        str | None,
        "The ID of the Webset for which to list all monitors. This is a required string value.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'monitors-list'."]:
    """Retrieve a list of all monitors for the Webset."""
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/monitors",
        method="GET",
        params=remove_none_values({
            "cursor": pagination_cursor,
            "limit": results_limit,
            "websetId": webset_id,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def get_specific_monitor(
    context: ToolContext,
    monitor_id: Annotated[str, "The unique ID of the monitor to retrieve details for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'monitors-get'."]:
    """Retrieve details of a specific monitor by ID.

    Use this tool to get detailed information about a specific monitor using its ID. Ideal for situations where monitor details are needed for analysis or display."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/monitors/{id}".format(id=monitor_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def update_monitor_configuration(
    context: ToolContext,
    monitor_configuration_details: Annotated[
        dict[str, str], "A JSON object containing the new configuration details for the monitor."
    ],
    monitor_id: Annotated[
        str, "The unique identifier for the monitor whose configuration needs to be updated."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'monitors-update'."]:
    """Update monitor configuration details using an ID.

    This tool updates the settings of a specific monitor configuration by using its ID. It should be used when there's a need to modify existing monitor settings."""  # noqa: E501
    request_data: Any = monitor_configuration_details
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/monitors/{id}".format(id=monitor_id),  # noqa: UP032
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def delete_monitor(
    context: ToolContext,
    monitor_id: Annotated[str, "The unique ID of the monitor to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'monitors-delete'."]:
    """Deletes a specified monitor by ID.

    This tool should be used to delete a monitor by its unique ID when its removal is requested."""
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/monitors/{id}".format(id=monitor_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def list_monitor_runs(
    context: ToolContext,
    monitor_id: Annotated[str, "The unique ID of the Monitor to list all associated runs."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'monitors-runs-list'."]:
    """List all runs for a specified monitor.

    This tool retrieves all runs related to a specific monitor. Use it to gather information about monitor activity and history."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/monitors/{monitor}/runs".format(monitor=monitor_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def get_monitor_run_details(
    context: ToolContext,
    monitor_id: Annotated[str, "The ID of the monitor to retrieve the run for."],
    run_id: Annotated[
        str,
        "The unique identifier of the monitor run to be retrieved. Provide this to obtain details about the specific run.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'monitors-runs-get'."]:
    """Retrieve details of a specific monitor run based on its ID.

    Call this tool to obtain complete information about a particular monitor run by providing the monitor and run ID."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/monitors/{monitor}/runs/{id}".format(  # noqa: UP032
            monitor=monitor_id, id=run_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def create_import_for_data_upload(
    context: ToolContext,
    import_data_details: Annotated[
        dict[str, str],
        "JSON structure containing details about the data to upload, including fields for enrichment, search, and exclusion options.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'imports-create'."]:
    """Create a new import to upload and manage your data in Websets.

    This tool creates an import for uploading data to Websets, enabling data enrichment, agentic search, and exclusion of duplicate results. The response includes an upload URL and a validity period for data submission."""  # noqa: E501
    request_data: Any = import_data_details
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/imports",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def list_webset_imports(
    context: ToolContext,
    pagination_cursor: Annotated[
        str | None, "A string used for pagination to get subsequent pages of results."
    ] = None,
    results_limit: Annotated[
        float | None,
        "The number of results to return from the list of imports. Use this to control pagination.",
    ] = 25,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'imports-list'."]:
    """Retrieve a list of all imports for the Webset.

    This tool should be called when you need to obtain a list of all imports for the Webset. It provides a detailed overview of everything imported within the specified Webset."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/imports",
        method="GET",
        params=remove_none_values({"cursor": pagination_cursor, "limit": results_limit}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def get_specific_import(
    context: ToolContext,
    import_id: Annotated[
        str, "The unique identifier for the import you want to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'imports-get'."]:
    """Retrieve details of a specific import by ID.

    Use this tool to get detailed information about a specific import by providing its ID. It calls the Exa_Websets API to fetch the data."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/imports/{id}".format(id=import_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def update_import_config(
    context: ToolContext,
    import_configuration_data: Annotated[
        dict[str, str],
        "JSON object containing the new import settings to update the configuration.",
    ],
    import_id: Annotated[str, "The unique identifier for the import configuration to be updated."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'imports-update'."]:
    """Update an import configuration.

    Use this tool to update an import configuration by specifying the import ID. Ideal for modifying existing import settings when changes are needed."""  # noqa: E501
    request_data: Any = import_configuration_data
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/imports/{id}".format(id=import_id),  # noqa: UP032
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["EXA_SEARCH_API_KEY"])
async def delete_import(
    context: ToolContext,
    import_id: Annotated[
        str, "The identifier of the import to be deleted. Provide the specific import ID."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'imports-delete'."]:
    """Delete an existing import by ID.

    Use this tool to delete a specific import by providing its ID. This is useful for managing and organizing available data imports."""  # noqa: E501
    request_data: Any = {}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.exa.ai/v0/imports/{id}".format(id=import_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(
                authorization=context.get_secret("EXA_SEARCH_API_KEY")
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}
