"""Arcade Starter Tools for ramp

DO NOT EDIT THIS MODULE DIRECTLY.

THIS MODULE WAS AUTO-GENERATED BY TRANSPILING THE API STARTER TOOL JSON DEFINITIONS
IN THE ../wrapper_tools DIRECTORY INTO PYTHON CODE. ANY CHANGES TO THIS MODULE WILL
BE OVERWRITTEN BY THE TRANSPILER.
"""

import asyncio
import json
from enum import Enum
from typing import Annotated, Any

import httpx
import jsonschema
from arcade_tdk import ToolContext, tool
from arcade_tdk.auth import OAuth2
from arcade_tdk.errors import RetryableToolError

from .request_body_schemas import REQUEST_BODY_SCHEMAS

# Retry configuration
INITIAL_RETRY_DELAY = 0.5  # seconds

HTTP_CLIENT = httpx.AsyncClient(
    timeout=httpx.Timeout(60.0, connect=10.0),
    limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
    transport=httpx.AsyncHTTPTransport(retries=3),
    http2=True,
    follow_redirects=True,
)


class ToolMode(str, Enum):
    """Mode for tools with complex request bodies."""

    GET_REQUEST_SCHEMA = "get_request_schema"
    EXECUTE = "execute"


def remove_none_values(data: dict[str, Any]) -> dict[str, Any]:
    return {k: v for k, v in data.items() if v is not None}


async def make_request(
    url: str,
    method: str,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    content: str | None = None,
    data: dict[str, Any] | None = None,
    auth: tuple[str, str] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with retry logic for 5xx server errors."""
    for attempt in range(max_retries):
        try:
            response = await HTTP_CLIENT.request(
                url=url,
                auth=auth,
                method=method,
                params=params,
                headers=headers,
                content=content,
            )
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            # Only retry on 5xx server errors
            if e.response.status_code >= 500 and attempt < max_retries - 1:
                # Exponential backoff: 0.5s, 1s, 2s
                await asyncio.sleep(INITIAL_RETRY_DELAY * (2**attempt))
                continue
            # Re-raise for 4xx errors or if max retries reached
            raise
        except httpx.RequestError as e:
            # Don't retry request errors (network issues are handled by transport)
            raise
        else:
            return response

    # This should never be reached, but satisfies type checker
    raise httpx.RequestError("Max retries exceeded")  # noqa: TRY003


async def make_request_with_schema_validation(
    url: str,
    method: str,
    request_data: dict[str, Any],
    schema: dict[str, Any] | str,
    auth: tuple[str, str] | None = None,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with schema validation on format errors."""
    # Parse schema if it's a string, skip validation if parsing fails
    parsed_schema = None
    if isinstance(schema, str):
        try:
            parsed_schema = json.loads(schema)
        except Exception:
            # If schema parsing fails, just skip validation
            parsed_schema = None
    else:
        parsed_schema = schema

    try:
        response = await make_request(
            url=url,
            auth=auth,
            method=method,
            params=params,
            headers=headers,
            content=json.dumps(request_data),
            max_retries=max_retries,
        )
    except httpx.HTTPStatusError as e:
        # Only provide schema validation for format-related errors
        if e.response.status_code in (400, 422):
            api_error_details = f"API returned {e.response.status_code}: {e.response.text}"

            # Only run validation if we have a valid parsed schema
            if parsed_schema is not None:
                # Run validation to provide additional context
                is_valid, validation_error = validate_json_against_schema(
                    request_data, parsed_schema
                )

                if not is_valid:
                    # Schema validation found issues - additional context
                    additional_context = (
                        f"{api_error_details}\n\n"
                        f"Schema validation found the following issues:\n"
                        f"{validation_error}"
                    )
                else:
                    # Schema validation passed - just show API error
                    additional_context = api_error_details
            else:
                # No valid schema - just show API error
                additional_context = api_error_details

            raise RetryableToolError(
                message=(f"API request failed with validation error: {e.response.status_code}"),
                developer_message=api_error_details,
                additional_prompt_content=additional_context,
            ) from e
        else:
            # For non-validation errors, re-raise as-is
            raise
    else:
        return response


def validate_json_against_schema(
    json_data: dict[str, Any], schema: dict[str, Any]
) -> tuple[bool, str | None]:
    """Validate JSON data against an OpenAPI/JSON Schema.

    This provides full JSON Schema Draft 7 validation including:
    - Required fields, types, enums
    - Pattern validation (regex)
    - Format validation (email, uuid, date-time, etc.)
    - Min/max length and values
    - oneOf, anyOf, allOf
    - And all other JSON Schema features

    Args:
        json_data: The JSON data to validate
        schema: The JSON Schema to validate against

    Returns:
        Tuple of (is_valid, error_messages). If valid, error_messages is None.
        If invalid, error_messages contains all validation errors.
    """
    try:
        validator = jsonschema.Draft7Validator(
            schema, format_checker=jsonschema.Draft7Validator.FORMAT_CHECKER
        )
        # Collect ALL validation errors
        errors = list(validator.iter_errors(json_data))
        if errors:
            # Format all errors with their paths
            error_messages = []
            for error in errors:
                error_path = ".".join(str(p) for p in error.path) if error.path else "root"
                error_messages.append(f"{error.message} at {error_path}")
            # Join all errors with newlines
            return False, "\n".join(error_messages)
        else:
            return True, None
    except jsonschema.SchemaError as e:
        return False, f"Invalid schema: {e.message}"
    except Exception as e:
        return False, f"Validation error: {e!s}"


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:read"]))
async def list_custom_field_options(
    context: ToolContext,
    custom_field_id: Annotated[
        str, "The unique identifier for the custom accounting field to retrieve options for."
    ],
    filter_by_external_id: Annotated[
        str | None,
        "Filter the options by the external/remote ID of custom accounting fields in the ERP system. Useful for narrowing down options to specific fields associated with a given external ID.",  # noqa: E501
    ] = None,
    filter_by_field_option_code: Annotated[
        str | None, "Specify the code to filter custom accounting field options."
    ] = None,
    include_active_options: Annotated[
        bool | None, "Include only active options if true; otherwise, include all."
    ] = None,
    pagination_start_id: Annotated[
        str | None,
        "The ID of the last entity from the previous page to retrieve the next page of results.",
    ] = None,
    results_per_page: Annotated[
        int | None,
        "The number of results to return per page, between 2 and 100. Defaults to 20 if not specified.",  # noqa: E501
    ] = 20,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_custom_field_option_list_resource'."
]:
    """List options for a given custom accounting field.

    This tool retrieves available options for a specified custom accounting field, allowing users to view or select from predefined choices."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/accounting/field-options",
        method="GET",
        params=remove_none_values({
            "remote_id": filter_by_external_id,
            "code": filter_by_field_option_code,
            "start": pagination_start_id,
            "page_size": results_per_page,
            "field_id": custom_field_id,
            "is_active": include_active_options,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:write"]))
async def upload_accounting_field_options(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_custom_field_option_list_resource'."
]:
    """Upload multiple custom accounting field options.

    Use this tool to upload up to 500 new field options for a custom accounting field in a single batch. Ensure the options are sanitized and do not already exist to prevent batch rejection. For updating existing options, use the PATCH method instead.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPLOADACCOUNTINGFIELDOPTIONS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPLOADACCOUNTINGFIELDOPTIONS"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPLOADACCOUNTINGFIELDOPTIONS"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/accounting/field-options",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPLOADACCOUNTINGFIELDOPTIONS"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:read"]))
async def fetch_custom_accounting_field_option(
    context: ToolContext,
    field_option_identifier: Annotated[
        str, "The unique identifier for the custom accounting field option to fetch."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_custom_field_option_resource'."
]:
    """Fetch a custom accounting field option.

    This tool retrieves information about a specific custom accounting field option using its unique identifier. It should be called when detailed data about a custom accounting field option is needed."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/accounting/field-options/{field_option_id}".format(  # noqa: UP032
            field_option_id=field_option_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:write"]))
async def update_accounting_field_option(
    context: ToolContext,
    custom_field_option_id: Annotated[
        str,
        "Unique identifier for the custom accounting field option to be updated. Required for specifying which field option to modify.",  # noqa: E501
    ],
    custom_field_option_code: Annotated[
        str | None,
        "Code of the custom accounting field option. Provide an empty string to reset the code. Only available if not using a direct ERP integration.",  # noqa: E501
    ] = None,
    field_option_name: Annotated[
        str | None,
        "Name of the custom accounting field option. Only available if not using a direct ERP integration.",  # noqa: E501
    ] = None,
    reactivate_custom_field_option: Annotated[
        bool | None,
        "Set to true to reactivate a deleted custom field option if not using direct ERP integration.",  # noqa: E501
    ] = None,
    set_visibility: Annotated[
        str | None, "Set the visibility of the custom field option to 'HIDDEN' or 'VISIBLE'."
    ] = None,
    update_display_name: Annotated[
        str | None, "Update the display name of the custom field option."
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'patch_custom_field_option_resource'."
]:
    """Update a custom accounting field option to reflect changes.

    Use this tool to modify a specific custom accounting field option by providing its ID. It updates the metadata or details associated with the field option."""  # noqa: E501
    request_data: Any = {
        "code": custom_field_option_code,
        "display_name": update_display_name,
        "reactivate": reactivate_custom_field_option,
        "value": field_option_name,
        "visibility": set_visibility,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/accounting/field-options/{field_option_id}".format(  # noqa: UP032
            field_option_id=custom_field_option_id
        ),
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:write"]))
async def delete_custom_accounting_field_option(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    field_option_id: Annotated[
        str | None,
        "The unique identifier for the custom accounting field option to be deleted.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'delete_custom_field_option_resource'."
]:
    """Delete a custom accounting field option by ID.

    Use this tool to delete a specific custom accounting field option by providing its unique ID. It should be called when you need to remove an obsolete or incorrect field option in the accounting system.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["DELETECUSTOMACCOUNTINGFIELDOPTION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not field_option_id:
        missing_params.append(("field_option_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["DELETECUSTOMACCOUNTINGFIELDOPTION"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["DELETECUSTOMACCOUNTINGFIELDOPTION"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/accounting/field-options/{field_option_id}".format(  # noqa: UP032
            field_option_id=field_option_id
        ),
        method="DELETE",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["DELETECUSTOMACCOUNTINGFIELDOPTION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:read"]))
async def list_custom_accounting_fields(
    context: ToolContext,
    filter_by_remote_id: Annotated[
        str | None,
        "Filter results by the Remote/external ID of custom accounting fields within the ERP system.",  # noqa: E501
    ] = None,
    include_only_active: Annotated[
        bool | None,
        "Set to True to include only active fields, False for inactive, or omit for all.",
    ] = None,
    pagination_start_id: Annotated[
        str | None, "ID of the last entity from the previous page for pagination."
    ] = None,
    results_per_page: Annotated[
        int | None,
        "The number of results to return per page, between 2 and 100. Defaults to 20 if not specified.",  # noqa: E501
    ] = 20,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_custom_field_list_resource'."]:
    """Retrieve a list of custom accounting fields.

    Use this tool to get a list of custom fields used in accounting. It should be called when you need to understand the available custom accounting fields in the system."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/accounting/fields",
        method="GET",
        params=remove_none_values({
            "remote_id": filter_by_remote_id,
            "start": pagination_start_id,
            "page_size": results_per_page,
            "is_active": include_only_active,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:write"]))
async def create_or_reactivate_custom_field(
    context: ToolContext,
    custom_accounting_field_name: Annotated[
        str, "Name of the custom accounting field to be created or reactivated on Ramp."
    ],
    custom_field_external_id: Annotated[
        str, "Remote/external ID of the custom accounting field from the ERP system."
    ],
    input_type_option: Annotated[
        str,
        "Specifies if the input type is SINGLE_CHOICE, BOOLEAN, or FREE_FORM_TEXT for the custom field.",  # noqa: E501
    ],
    custom_field_display_name: Annotated[
        str | None,
        "The name of the custom accounting field as displayed on Ramp. This should be a clear and descriptive name.",  # noqa: E501
    ] = None,
    enable_split_line_annotation: Annotated[
        bool | None,
        "Set to true to allow the field to annotate split line items. Defaults to false if unspecified.",  # noqa: E501
    ] = None,
    required_object_types_for_sync: Annotated[
        list[str] | None,
        "List of object types that need this accounting field for coding before syncing.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_custom_field_list_resource'."]:
    """Create or reactivate a custom field on Ramp.

    Use this tool to create a new custom field on Ramp or reactivate an existing inactive custom field. If the field already exists, it will return the existing field without creating a new one. To update an existing field, use the PATCH endpoint instead."""  # noqa: E501
    request_data: Any = {
        "display_name": custom_field_display_name,
        "id": custom_field_external_id,
        "input_type": input_type_option,
        "is_required_for": required_object_types_for_sync,
        "is_splittable": enable_split_line_annotation,
        "name": custom_accounting_field_name,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/accounting/fields",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:read"]))
async def fetch_custom_accounting_field(
    context: ToolContext,
    field_identifier: Annotated[
        str, "The unique identifier for the custom accounting field to be retrieved."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_custom_field_resource'."]:
    """Fetch details of a specific custom accounting field.

    Use this tool to obtain information about a custom accounting field by specifying its field ID."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/accounting/fields/{field_id}".format(  # noqa: UP032
            field_id=field_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:write"]))
async def update_custom_accounting_field(
    context: ToolContext,
    custom_field_id: Annotated[
        str,
        "The unique identifier for the custom accounting field you want to update. This is required to specify which field to modify.",  # noqa: E501
    ],
    custom_accounting_field_name: Annotated[
        str | None, "The name of the custom accounting field to update on Ramp."
    ] = None,
    field_display_name: Annotated[
        str | None, "The new display name for the custom accounting field on Ramp."
    ] = None,
    field_is_splittable: Annotated[
        bool | None, "Boolean to determine if the custom accounting field is splittable on Ramp."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'patch_custom_field_resource'."]:
    """Update a custom accounting field with new information.

    This tool updates a custom accounting field specified by a field ID. Use this when you need to modify the details of a particular accounting field."""  # noqa: E501
    request_data: Any = {
        "display_name": field_display_name,
        "is_splittable": field_is_splittable,
        "name": custom_accounting_field_name,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/accounting/fields/{field_id}".format(  # noqa: UP032
            field_id=custom_field_id
        ),
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:write"]))
async def delete_custom_accounting_field(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    custom_field_id: Annotated[
        str | None,
        "The unique identifier for the custom accounting field to be deleted.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_custom_field_resource'."]:
    """Delete a custom accounting field by its unique ID.

    Use this tool to delete a specified custom accounting field by providing its unique field ID.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["DELETECUSTOMACCOUNTINGFIELD"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not custom_field_id:
        missing_params.append(("custom_field_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["DELETECUSTOMACCOUNTINGFIELD"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["DELETECUSTOMACCOUNTINGFIELD"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/accounting/fields/{field_id}".format(  # noqa: UP032
            field_id=custom_field_id
        ),
        method="DELETE",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["DELETECUSTOMACCOUNTINGFIELD"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:read"]))
async def list_gl_accounts(
    context: ToolContext,
    filter_by_external_id: Annotated[
        str | None, "Filter ledger accounts by their remote/external ID."
    ] = None,
    filter_by_synced_status: Annotated[
        bool | None,
        "Filter accounts by synchronization status. Use true for synced accounts and false for unsynced accounts.",  # noqa: E501
    ] = None,
    include_only_active_accounts: Annotated[
        bool | None, "Set to true to only include active accounts in the results."
    ] = None,
    pagination_start_id: Annotated[
        str | None,
        "The ID of the last entity from the previous page, used to access the next page.",
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Number of results per page. Must be between 2 and 100, defaulting to 20 if unspecified.",
    ] = 20,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_gl_account_list_resource'."]:
    """Retrieve a list of general ledger accounts.

    Call this tool to obtain a list of general ledger accounts, which are essential for accounting and financial tracking."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/accounting/accounts",
        method="GET",
        params=remove_none_values({
            "remote_id": filter_by_external_id,
            "start": pagination_start_id,
            "page_size": results_per_page,
            "is_active": include_only_active_accounts,
            "is_synced": filter_by_synced_status,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:write"]))
async def upload_gl_accounts(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_gl_account_list_resource'."]:
    """Upload a batch of general ledger accounts to Ramp.

    Use this tool to upload up to 500 general ledger accounts in a single batch to Ramp. Ensure data is sanitized and accounts do not already exist on Ramp. If any account is invalid, the entire batch is rejected.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPLOADGLACCOUNTS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPLOADGLACCOUNTS"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPLOADGLACCOUNTS"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/accounting/accounts",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPLOADGLACCOUNTS"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:read"]))
async def fetch_gl_account(
    context: ToolContext,
    general_ledger_account_id: Annotated[
        str, "The unique identifier for the general ledger account to fetch details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_gl_account_resource'."]:
    """Fetch details of a general ledger account.

    Use this tool to retrieve information about a specific general ledger account by its ID."""
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/accounting/accounts/{gl_account_id}".format(  # noqa: UP032
            gl_account_id=general_ledger_account_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:write"]))
async def update_gl_account(
    context: ToolContext,
    gl_account_id: Annotated[
        str, "Unique identifier for the GL account to update. It must be a string."
    ],
    gl_account_code: Annotated[
        str | None, "Code of the general ledger account. Provide an empty string to reset the code."
    ] = None,
    gl_account_name: Annotated[str | None, "The new name for the general ledger account."] = None,
    reactivate_deleted_gl_account: Annotated[
        bool | None,
        "Set to true to reactivate a deleted general ledger account. If false, the account remains inactive.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'patch_gl_account_resource'."]:
    """Update the name or code of a GL account."""
    request_data: Any = {
        "code": gl_account_code,
        "name": gl_account_name,
        "reactivate": reactivate_deleted_gl_account,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/accounting/accounts/{gl_account_id}".format(  # noqa: UP032
            gl_account_id=gl_account_id
        ),
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:write"]))
async def delete_general_ledger_account(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    general_ledger_account_id: Annotated[
        str | None,
        "The ID of the general ledger account to be deleted. It must be a valid string representing the account.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_gl_account_resource'."]:
    """Deletes a specified general ledger account.

    Use this tool to delete a general ledger account by providing the GL account ID. It should be called when you need to permanently remove an account from the records.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["DELETEGENERALLEDGERACCOUNT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not general_ledger_account_id:
        missing_params.append(("general_ledger_account_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["DELETEGENERALLEDGERACCOUNT"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["DELETEGENERALLEDGERACCOUNT"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/accounting/accounts/{gl_account_id}".format(  # noqa: UP032
            gl_account_id=general_ledger_account_id
        ),
        method="DELETE",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["DELETEGENERALLEDGERACCOUNT"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:read"]))
async def fetch_accounting_connections(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_accounting_all_connections_resource'."
]:
    """Fetch all accounting connections for the current business."""
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/accounting/all-connections",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:read"]))
async def get_current_accounting_connection(
    context: ToolContext,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get_accounting_current_connection_resource_deprecated'.",
]:
    """Get deprecated current accounting connection resource.

    Fetches the deprecated current accounting connection resource, usually needed to handle legacy integrations."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/accounting/connection",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:write"]))
async def create_accounting_connection(
    context: ToolContext,
    accounting_connection_name: Annotated[
        str, "The name of the accounting connection to establish or upgrade."
    ],
    reactivate: Annotated[
        bool | None,
        "This argument is deprecated. Use POST accounting/connection/<connection_id>/reactivate instead.",  # noqa: E501
    ] = False,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_accounting_connection_resource'."
]:
    """Establish or upgrade an accounting API connection.

    Use this tool to set up a new accounting API connection or upgrade an existing Universal CSV connection to an API-based connection."""  # noqa: E501
    request_data: Any = {
        "reactivate": reactivate,
        "remote_provider_name": accounting_connection_name,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/accounting/connection",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:write"]))
async def disconnect_accounting_connection(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'delete_accounting_connection_resource'."
]:
    """Disconnect an API-based accounting connection.

    This tool is used to disconnect API-based accounting connections when they are no longer needed. It should be called when a user wants to remove an integration with an accounting service."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/accounting/connection",
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:write"]))
async def reactivate_accounting_connection(
    context: ToolContext,
    accounting_connection_id: Annotated[
        str,
        "A unique identifier for the accounting connection to be reactivated. This ID is required to change the status back to linked.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_reactivate_connection_resource'."
]:
    """Reactivate a previously disconnected accounting connection.

    Utilize this tool to reactivate an accounting connection that was previously disconnected. It restores the connection status to linked, maintaining all previous configurations and settings. Ensure there are no other active accounting connections for the business."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/accounting/connection/{connection_id}/reactivate".format(  # noqa: UP032
            connection_id=accounting_connection_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:write"]))
async def notify_sync_results(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_sync_list_resource'."]:
    """Notify Ramp of a list of sync results.

    Use this tool to inform Ramp about sync results, ensuring proper handling of subsequent requests with an idempotency key.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["NOTIFYSYNCRESULTS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["NOTIFYSYNCRESULTS"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["NOTIFYSYNCRESULTS"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/accounting/syncs",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["NOTIFYSYNCRESULTS"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:read"]))
async def list_vendors(
    context: ToolContext,
    filter_by_remote_id: Annotated[
        str | None,
        "Filter the vendor list by a specific Remote or external ID. This helps refine the results to match a particular identifier.",  # noqa: E501
    ] = None,
    include_synced_vendors: Annotated[
        bool | None,
        "Include vendors based on their sync status with the remote system. Set to true to include only synced vendors, and false to exclude them.",  # noqa: E501
    ] = None,
    pagination_start_id: Annotated[
        str | None, "The ID of the last entity from the previous page for pagination."
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Specify the number of vendor results to return per page. Must be between 2 and 100. Defaults to 20 if not provided.",  # noqa: E501
    ] = 20,
    retrieve_active_vendors: Annotated[
        bool | None, "Set to true to retrieve only active vendors; false to retrieve all vendors."
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_accounting_vendor_list_resource'."
]:
    """Retrieve a list of vendors from the accounting system.

    This tool is used to obtain a comprehensive list of vendors from the accounting system. It should be called when you need to access vendor information for accounting purposes."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/accounting/vendors",
        method="GET",
        params=remove_none_values({
            "remote_id": filter_by_remote_id,
            "start": pagination_start_id,
            "page_size": results_per_page,
            "is_active": retrieve_active_vendors,
            "is_synced": include_synced_vendors,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:write"]))
async def upload_vendor_list(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_accounting_vendor_list_resource'."
]:
    """Upload a batch of up to 500 vendors to Ramp.

    Use this tool to upload a batch of up to 500 vendors to Ramp in an all-or-nothing manner. Ensure that the vendor data is clean and does not contain duplicates already on Ramp to avoid batch rejection. For updating existing vendors, use a different endpoint.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPLOADVENDORLIST"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPLOADVENDORLIST"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPLOADVENDORLIST"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/accounting/vendors",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPLOADVENDORLIST"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:read"]))
async def fetch_vendor_info(
    context: ToolContext,
    vendor_identifier: Annotated[
        str, "A unique identifier for the vendor to fetch its information."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_accounting_vendor_resource'."]:
    """Fetch detailed information about a vendor.

    Use this tool to fetch information about a vendor using their vendor ID. It returns detailed data associated with the specified vendor."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/accounting/vendors/{vendor_id}".format(  # noqa: UP032
            vendor_id=vendor_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:write"]))
async def update_vendor_details(
    context: ToolContext,
    vendor_id: Annotated[
        str,
        "The unique identifier for the vendor to be updated. This is a required string value used to specify which vendor's details are to be modified.",  # noqa: E501
    ],
    reactivate_vendor: Annotated[bool | None, "Set to true to reactivate a deleted vendor."] = None,
    vendor_code: Annotated[
        str | None, "Specify the vendor's code. Use an empty string to reset the code."
    ] = None,
    vendor_name: Annotated[
        str | None, "Specify the name of the vendor to update their details."
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'patch_accounting_vendor_resource'."
]:
    """Update vendor information in the accounting system.

    Use this tool to update the details of an existing vendor in the accounting system. It should be called when vendor information needs to be modified or corrected."""  # noqa: E501
    request_data: Any = {"code": vendor_code, "name": vendor_name, "reactivate": reactivate_vendor}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/accounting/vendors/{vendor_id}".format(  # noqa: UP032
            vendor_id=vendor_id
        ),
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["accounting:write"]))
async def delete_vendor(
    context: ToolContext,
    vendor_id: Annotated[
        str,
        "The unique identifier for the vendor to be deleted. This is required to specify which vendor to remove from the system.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'delete_accounting_vendor_resource'."
]:
    """Deletes a specified vendor from accounting.

    Use this tool to delete a vendor from the accounting system by specifying the vendor ID. It should be called when a vendor needs to be removed from records."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/accounting/vendors/{vendor_id}".format(  # noqa: UP032
            vendor_id=vendor_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["audit_logs:read"]))
async def get_audit_log_events(
    context: ToolContext,
    actor_type_filters: Annotated[
        list[str] | None,
        "Filter audit log events by specifying actor types. Provide an array of strings representing the actor types to include.",  # noqa: E501
    ] = None,
    filter_by_start_date: Annotated[
        str | None,
        "Filter audit log events by those created on or after this date. Format should be YYYY-MM-DD.",  # noqa: E501
    ] = None,
    filter_end_date: Annotated[
        str | None, "Filter audit log events created on or before this date. Use format YYYY-MM-DD."
    ] = None,
    filter_event_types: Annotated[
        list[str] | None,
        "An array of event types to filter audit log events by. Supply event type identifiers as strings to specify the criteria for filtering results.",  # noqa: E501
    ] = None,
    filter_user_ids: Annotated[
        list[str] | None,
        "Filter by audit log events attributed to these specific user IDs, provided as an array of strings.",  # noqa: E501
    ] = None,
    pagination_start_id: Annotated[
        str | None,
        "The ID of the last entity from the previous page to fetch the next page of results.",
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Number of results returned per page. Must be between 2 and 100. Defaults to 20 if not specified.",  # noqa: E501
    ] = 20,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_audit_log_events_list_resource'."
]:
    """Retrieve a list of audit log events for analysis.

    This tool retrieves a list of audit log events from the ramp service. It should be called when there is a need to analyze or review audit logs for security or compliance purposes."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/audit-logs/events",
        method="GET",
        params=remove_none_values({
            "user_ids": filter_user_ids,
            "from_date": filter_by_start_date,
            "to_date": filter_end_date,
            "event_actor_types": actor_type_filters,
            "event_types": filter_event_types,
            "start": pagination_start_id,
            "page_size": results_per_page,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp"))
async def request_access_token(
    context: ToolContext,
    grant_type: Annotated[
        str,
        "Specifies the type of OAuth2 authorization grant to use: 'authorization_code', 'client_credentials', or 'refresh_token'. Ensure that the grant type is permitted for your app.",  # noqa: E501
    ],
    authorization_code: Annotated[
        str | None,
        "Authorization code from https://app.ramp.com/v1/authorize, required if grant_type=authorization_code.",  # noqa: E501
    ] = None,
    authorization_redirect_uri: Annotated[
        str | None,
        "The URI used in the initial authorization request. Required for `grant_type=authorization_code`.",  # noqa: E501
    ] = None,
    authorization_scope: Annotated[
        str | None,
        "Space-separated list of scopes for the returned token. Required if using client_credentials grant type.",  # noqa: E501
    ] = None,
    refresh_token: Annotated[
        str | None,
        "The refresh token used to obtain a new access token. Required for grant_type=refresh_token.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_token'."]:
    """Request an access token using various authorization grants.

    Use this tool to request an access token from the Ramp API using different authorization methods. It supports Authorization Code, Refresh Token, and Client Credentials grants. The tool is useful for integrating with services that require OAuth2 authentication."""  # noqa: E501
    request_data: Any = {
        "code": authorization_code,
        "grant_type": grant_type,
        "redirect_uri": authorization_redirect_uri,
        "refresh_token": refresh_token,
        "scope": authorization_scope,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/token",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp"))
async def revoke_api_token(
    context: ToolContext,
    token_to_revoke: Annotated[str, "The access or refresh token that needs to be revoked."],
    token_type: Annotated[
        str | None,
        "Specify whether the token to be revoked is an 'access_token' or 'refresh_token'.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_revoke_token'."]:
    """Revoke an API token to prevent its use.

    Use this tool to revoke a Ramp API token, ensuring it can no longer be utilized for authentication."""  # noqa: E501
    request_data: Any = {"token": token_to_revoke, "token_type_hint": token_type}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/token/revoke",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["bank_accounts:read"]))
async def get_bank_account_details(
    context: ToolContext,
    bank_account_id: Annotated[
        str,
        "The unique identifier for the bank account to retrieve details for. It must be a string.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_bank_account_resource'."]:
    """Retrieve detailed bank account information by ID.

    Use this tool to get detailed information about a specific bank account by providing the bank account ID."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/bank-accounts/{bank_account_id}".format(  # noqa: UP032
            bank_account_id=bank_account_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["bills:write"]))
async def create_bills_with_pagination(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_bill_list_with_pagination'."]:
    """Creates a paginated list of bills via the API.

    Use this tool to submit a list of bills with pagination capabilities. This tool does not support batch payments. It is useful for creating bills in a structured manner with the ability to paginate through them.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEBILLSWITHPAGINATION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEBILLSWITHPAGINATION"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEBILLSWITHPAGINATION"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/bills",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEBILLSWITHPAGINATION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["bills:read"]))
async def list_draft_bills(
    context: ToolContext,
    before_creation_date: Annotated[
        str | None,
        "Filters draft bills created on or before this date. Provide as an ISO 8601 datetime string.",  # noqa: E501
    ] = None,
    due_date_before: Annotated[
        str | None,
        "Filter draft bills by a due date on or before this date. Must be an ISO 8601 datetime string.",  # noqa: E501
    ] = None,
    due_date_from: Annotated[
        str | None, "Shows draft bills due on or after this date. Use ISO 8601 datetime format."
    ] = None,
    filter_by_entity_id: Annotated[
        str | None, "Filter draft bills by a specific entity ID."
    ] = None,
    filter_by_vendor_id: Annotated[
        str | None, "Filter draft bills by vendor using a vendor ID as a string."
    ] = None,
    filter_from_creation_date: Annotated[
        str | None,
        "Filter draft bills with a creation date on or after this ISO 8601 datetime string.",
    ] = None,
    filter_to_issued_date: Annotated[
        str | None,
        "Filter draft bills to those issued on or before this date. Use ISO 8601 format.",
    ] = None,
    issued_date_start_filter: Annotated[
        str | None, "Filter draft bills issued on or after this date (ISO 8601 format)."
    ] = None,
    pagination_start_id: Annotated[
        str | None, "The ID of the last entity from the previous page for pagination purposes."
    ] = None,
    results_per_page: Annotated[
        int | None, "Number of draft bills to return per page, between 2 and 100. Default is 20."
    ] = 20,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_draft_bill_list_with_pagination'."
]:
    """Retrieve a list of draft bills.

    This tool is used to get a list of draft bills from the Ramp service, including pagination information. Call this when you need to access or manage draft billing entries."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/bills/drafts",
        method="GET",
        params=remove_none_values({
            "entity_id": filter_by_entity_id,
            "vendor_id": filter_by_vendor_id,
            "from_created_at": filter_from_creation_date,
            "to_created_at": before_creation_date,
            "from_due_date": due_date_from,
            "to_due_date": due_date_before,
            "from_issued_date": issued_date_start_filter,
            "to_issued_date": filter_to_issued_date,
            "start": pagination_start_id,
            "page_size": results_per_page,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["bills:read"]))
async def fetch_draft_bill(
    context: ToolContext,
    draft_bill_identifier: Annotated[
        str,
        "A unique identifier for the draft bill to fetch. Provide this to retrieve specific draft bill details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_draft_bill_resource'."]:
    """Fetches details of a draft bill using its ID.

    Call this tool to retrieve detailed information about a draft bill by providing its specific ID. Useful for accessing draft bill data when reviewing or editing bills."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/bills/drafts/{draft_bill_id}".format(  # noqa: UP032
            draft_bill_id=draft_bill_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["bills:read"]))
async def fetch_bill_details(
    context: ToolContext,
    bill_identifier: Annotated[
        str,
        "The unique identifier for the bill you want to fetch details for. Provide this to retrieve specific bill information.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_bill_resource'."]:
    """Fetch details of a specified bill using its ID.

    This tool retrieves detailed information about a specific bill using the bill ID. It should be called when you need to know the specifics of a bill, such as in financial review or customer billing inquiries."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/bills/{bill_id}".format(bill_id=bill_identifier),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["bills:write"]))
async def update_bill(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    bill_identifier: Annotated[
        str | None,
        "The unique identifier of the bill to be updated. This is required to specify which bill to modify.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'patch_bill_resource'."]:
    """Update details of an existing bill.

    Use this tool to make changes to an existing bill's data. It should be called when modifications to bill details are necessary.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATEBILL"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not bill_identifier:
        missing_params.append(("bill_identifier", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEBILL"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEBILL"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/bills/{bill_id}".format(bill_id=bill_identifier),  # noqa: UP032
        method="PATCH",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATEBILL"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["bills:write"]))
async def delete_bill(
    context: ToolContext,
    bill_identifier: Annotated[
        str,
        "The unique identifier of the bill to delete. It must be a string specifying the bill's ID.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_bill_resource'."]:
    """Delete a bill and cancel associated payments if possible.

    Use this tool to delete a specified bill. Note that inflight payments will be canceled if possible, or attached one-time-cards will be terminated. This action cannot be performed on paid bills or those in a batch payment."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/bills/{bill_id}".format(bill_id=bill_identifier),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["bills:write"]))
async def upload_bill_attachment(
    context: ToolContext,
    attachment_type: Annotated[
        str,
        "Specify the type of attachment: 'INVOICE' for the actual invoice, or 'FILE' for other supporting documents.",  # noqa: E501
    ],
    bill_identifier: Annotated[
        str, "A unique string identifier for the bill to which the file will be attached."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_bill_attachment_upload_resource'."
]:
    """Upload an attachment to a bill as INVOICE or FILE.

    Use this tool to upload a file attachment to a bill. The attachment can be of type INVOICE or FILE. The tool should be called when there is a need to associate a document with a specific bill. Note that INVOICE type cannot be uploaded if it already exists."""  # noqa: E501
    request_data: Any = {"attachment_type": attachment_type}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/bills/{bill_id}/attachments".format(  # noqa: UP032
            bill_id=bill_identifier
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["business:read"]))
async def fetch_company_info(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_business_resource'."]:
    """Fetch company information from the business resource endpoint.

    This tool retrieves detailed company information by calling the business resource endpoint. It should be used when you need to access or display company details."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/business",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["business:read"]))
async def get_company_balance_info(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_business_balance_resource'."]:
    """Fetch the company balance information."""
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/business/balance",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["cards:read"]))
async def list_cards(
    context: ToolContext,
    business_entity_filter: Annotated[str | None, "Filter cards by the business entity ID."] = None,
    filter_activated_cards: Annotated[
        bool | None,
        "Set to true to filter only activated cards. Defaults to true if not specified.",
    ] = True,
    filter_by_card_program_id: Annotated[
        str | None, "A string to filter cards by their associated card program."
    ] = None,
    filter_by_display_name: Annotated[
        str | None, "String to filter cards by their display name."
    ] = None,
    filter_by_user_id: Annotated[
        str | None, "String identifier to filter the cards by card owner's user ID."
    ] = None,
    filter_only_terminated_cards: Annotated[
        bool | None,
        "Set to True to filter for only terminated cards. Defaults to False if not specified.",
    ] = False,
    pagination_start_id: Annotated[
        str | None, "The ID of the last entity from the previous page for fetching the next page."
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Specify the number of cards to return per page, between 2 and 100. Defaults to 20 if not specified.",  # noqa: E501
    ] = 20,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_card_list_with_pagination'."]:
    """Retrieve a paginated list of cards from the service.

    Use this tool to fetch a list of cards with pagination support. It provides card details across multiple pages if necessary."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/cards",
        method="GET",
        params=remove_none_values({
            "entity_id": business_entity_filter,
            "user_id": filter_by_user_id,
            "card_program_id": filter_by_card_program_id,
            "display_name": filter_by_display_name,
            "is_activated": filter_activated_cards,
            "is_terminated": filter_only_terminated_cards,
            "start": pagination_start_id,
            "page_size": results_per_page,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["cards:write"]))
async def request_physical_card(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_physical_card'."]:
    """Create a task to request a new physical card.

    Use this tool to initiate an asynchronous task to request a new physical card. Ideal for situations where a new card issuance is needed.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["REQUESTPHYSICALCARD"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["REQUESTPHYSICALCARD"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["REQUESTPHYSICALCARD"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/cards/deferred/physical",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["REQUESTPHYSICALCARD"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["cards:write"]))
async def fetch_deferred_task_status(
    context: ToolContext,
    task_identifier: Annotated[
        str, "The unique identifier for the deferred task whose status you want to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_card_deferred_task_resource'."]:
    """Fetch the status of a deferred task using its ID.

    Use this tool to check the current status of a specific deferred task by providing its task ID. Ideal for monitoring task progress or completion."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/cards/deferred/status/{task_id}".format(  # noqa: UP032
            task_id=task_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["cards:write"]))
async def create_virtual_card_request(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_virtual_card'."]:
    """Initiate a request to create a new virtual card.

    Call this tool to start an asynchronous task for requesting a new virtual card creation.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEVIRTUALCARDREQUEST"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEVIRTUALCARDREQUEST"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEVIRTUALCARDREQUEST"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/cards/deferred/virtual",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEVIRTUALCARDREQUEST"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["cards:read"]))
async def fetch_card_info(
    context: ToolContext,
    card_id: Annotated[
        str,
        "The unique identifier for the card you want to fetch information about. It should be a string.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_card_resource'."]:
    """Retrieves details for a specified card.

    Use this tool to fetch information about a card using its unique ID. It's helpful when specific card details are needed."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/cards/{card_id}".format(card_id=card_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["cards:write"]))
async def update_card_info(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    card_identifier: Annotated[
        str | None,
        "Unique identifier for the card to be updated. Use this to specify which card's details need modification.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'patch_card_resource'."]:
    """Update card owner, display name, and spend restrictions.

    Use this tool to update the owner, display name, or spending restrictions of a specified card. It provides confirmation of the changes made.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATECARDINFO"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not card_identifier:
        missing_params.append(("card_identifier", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATECARDINFO"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATECARDINFO"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/cards/{card_id}".format(card_id=card_identifier),  # noqa: UP032
        method="PATCH",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATECARDINFO"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["cards:write"]))
async def suspend_card_task(
    context: ToolContext,
    card_identifier: Annotated[
        str,
        "A unique identifier for the card that needs to be suspended. This identifies the specific card to lock.",  # noqa: E501
    ],
    idempotency_key: Annotated[
        str, "A unique key to recognize retries of the same request; use a random UUID."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_card_suspension_resource'."]:
    """Creates an asynchronous suspension task for a card.

    Use this tool to initiate an asynchronous task that suspends a card, preventing its use. The suspension can be reversed if needed."""  # noqa: E501
    request_data: Any = {"idempotency_key": idempotency_key}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/cards/{card_id}/deferred/suspension".format(  # noqa: UP032
            card_id=card_identifier
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["cards:write"]))
async def terminate_card_async(
    context: ToolContext,
    card_identifier: Annotated[
        str,
        "A unique identifier for the card to be permanently terminated. This is a required string value.",  # noqa: E501
    ],
    unique_idempotency_key: Annotated[
        str,
        "A unique identifier for recognizing retries of the same request. Use a randomly generated UUID to avoid collisions.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_card_termination_resource'."]:
    """Initiate an irreversible async task to terminate a card permanently.

    This tool should be called when you need to permanently terminate a card and initiate an asynchronous task for this irreversible action."""  # noqa: E501
    request_data: Any = {"idempotency_key": unique_idempotency_key}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/cards/{card_id}/deferred/termination".format(  # noqa: UP032
            card_id=card_identifier
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["cards:write"]))
async def unsuspend_card_task(
    context: ToolContext,
    card_identifier: Annotated[
        str,
        "The unique identifier of the card to unsuspend. Provide the card's ID to reactivate it.",
    ],
    unique_request_id: Annotated[
        str,
        "A unique string used to identify and recognize retries of the same request. It should be a randomly generated UUID to avoid collisions.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_card_unsuspension_resource'."]:
    """Creates an async task to remove a card's suspension.

    Use this tool to initiate an async process to unsuspend a card, enabling it for use again. Call this when you need to reactivate a suspended card."""  # noqa: E501
    request_data: Any = {"idempotency_key": unique_request_id}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/cards/{card_id}/deferred/unsuspension".format(  # noqa: UP032
            card_id=card_identifier
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["cashbacks:read"]))
async def list_cashback_payments(
    context: ToolContext,
    filter_after_date: Annotated[
        str | None, "Filter cashbacks that occurred after this date. Must be in ISO8601 format."
    ] = None,
    filter_before_date: Annotated[
        str | None,
        "Filter cashback payments that occurred before this date. Use ISO8601 format (e.g., 2023-10-01).",  # noqa: E501
    ] = None,
    filter_by_entity_id: Annotated[
        str | None, "Filter cashbacks by the specific business entity ID."
    ] = None,
    filter_by_statement_id: Annotated[
        str | None,
        "Specify the statement ID to filter cashback payments included in that statement.",
    ] = None,
    filter_by_sync_ready: Annotated[
        bool | None,
        "Boolean value to filter cashbacks that are ready to be synced (no pending syncs and completed).",  # noqa: E501
    ] = None,
    filter_by_sync_status: Annotated[
        str | None,
        "Filter cashbacks by sync status: NOT_SYNC_READY, SYNCED, or SYNC_READY. Supersedes sync_ready if provided.",  # noqa: E501
    ] = None,
    last_entity_id_for_pagination: Annotated[
        str | None,
        "The ID of the last entity on the previous page, used to fetch the next page of results.",
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Specify the number of results per page. Must be between 2 and 100. Defaults to 20 if not specified.",  # noqa: E501
    ] = 20,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_cashback_list_with_pagination'."
]:
    """Retrieve a paginated list of cashback payments.

    This tool retrieves a list of cashback payments along with pagination details. It should be called when you need to view or manage cashback transactions."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/cashbacks",
        method="GET",
        params=remove_none_values({
            "sync_status": filter_by_sync_status,
            "entity_id": filter_by_entity_id,
            "statement_id": filter_by_statement_id,
            "sync_ready": filter_by_sync_ready,
            "from_date": filter_after_date,
            "to_date": filter_before_date,
            "start": last_entity_id_for_pagination,
            "page_size": results_per_page,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["cashbacks:read"]))
async def fetch_cashback_payment(
    context: ToolContext,
    cashback_payment_id: Annotated[
        str, "The unique identifier for the cashback payment to be fetched."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_cashback_resource'."]:
    """Fetch details of a specific cashback payment."""
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/cashbacks/{cashback_id}".format(  # noqa: UP032
            cashback_id=cashback_payment_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["custom_records:write"]))
async def create_custom_table(
    context: ToolContext,
    custom_table_api_name: Annotated[
        str, "Specify the API name for the custom table, used to identify it within the system."
    ],
    custom_table_label: Annotated[
        str,
        "The label for the custom table as it will appear in Ramp. This should be a descriptive name for easier identification.",  # noqa: E501
    ],
    table_type: Annotated[
        str | None, "The type of the table to be created. Use 'custom_table' for custom tables."
    ] = "custom_table",
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_dev_api_configure_custom_tables'."
]:
    """Create and configure a custom table via API.

    Use this tool to create and configure custom tables for data management. Call this when you need to set up a new custom table in your system."""  # noqa: E501
    request_data: Any = {
        "table_label": custom_table_label,
        "table_name": custom_table_api_name,
        "type": table_type,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/custom-records/configure/custom-tables",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["custom_records:write"]))
async def create_custom_table_column(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    table_name_for_custom_column: Annotated[
        str | None,
        "The name of the table where the custom column will be created. Must be a valid string identifier.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_dev_api_configure_custom_table_columns'."
]:
    """Create a custom column in a specified table.

    Use this tool to create and configure a custom column in a specific table identified by its name.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATECUSTOMTABLECOLUMN"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not table_name_for_custom_column:
        missing_params.append(("table_name_for_custom_column", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATECUSTOMTABLECOLUMN"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATECUSTOMTABLECOLUMN"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/custom-records/configure/custom-tables/{custom_table_name}/columns".format(  # noqa: UP032
            custom_table_name=table_name_for_custom_column
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATECUSTOMTABLECOLUMN"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["custom_records:write"]))
async def rename_custom_table_column(
    context: ToolContext,
    current_column_name: Annotated[
        str, "The current name of the column that you want to rename in a custom table."
    ],
    custom_table_name: Annotated[
        str,
        "The name of the custom table containing the column to be renamed. This is required to identify the specific table in which the column resides.",  # noqa: E501
    ],
    new_column_name: Annotated[
        str,
        "The new API name for the specified column in the custom table. Must be a non-empty string.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'patch_dev_api_rename_custom_table_column'."
]:
    """Change the API name of a custom table's column.

    Use this tool to update the API name of a specific column in a custom table. It should be called when a column name needs to be renamed for API access."""  # noqa: E501
    request_data: Any = {"new_name": new_column_name}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/custom-records/configure/custom-tables/{custom_table_name}/columns/{column_name}".format(  # noqa: UP032
            column_name=current_column_name, custom_table_name=custom_table_name
        ),
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["custom_records:write"]))
async def extend_native_table(
    context: ToolContext,
    native_table_name: Annotated[
        str,
        "Select the native Ramp table to extend. Options include 'accounting_field_options', 'bills', 'business_entities', etc.",  # noqa: E501
    ],
    table_category: Annotated[
        str | None, "Specifies the category of the table, expected to be 'native_table'."
    ] = "native_table",
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_dev_api_configure_native_tables'."
]:
    """Extend a native Ramp table.

    Use this tool to extend native Ramp tables by configuring additional custom records."""
    request_data: Any = {"table_name": native_table_name, "type": table_category}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/custom-records/configure/native-tables",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["custom_records:write"]))
async def create_native_table_field(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    target_native_table_name: Annotated[
        str | None,
        "The name of the Native Ramp table where a new field will be created.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_dev_api_configure_native_table_columns'."
]:
    """Create a field in a Native Ramp table.

    Use this tool to add a new field (column) to a specified Native Ramp table. Ideal for customizing table structures to suit your data needs.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATENATIVETABLEFIELD"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not target_native_table_name:
        missing_params.append(("target_native_table_name", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATENATIVETABLEFIELD"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATENATIVETABLEFIELD"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/custom-records/configure/native-tables/{native_table_name}/columns".format(  # noqa: UP032
            native_table_name=target_native_table_name
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATENATIVETABLEFIELD"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["custom_records:write"]))
async def change_native_table_column_name(
    context: ToolContext,
    current_column_name: Annotated[
        str, "The current API name of the column to be renamed in the native table."
    ],
    native_table_name: Annotated[
        str, "The name of the native table containing the column to be renamed."
    ],
    new_column_name: Annotated[
        str,
        "The new API name for the specified column in the Native Table. Provide a unique, descriptive name.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'patch_dev_api_rename_native_table_column'."
]:
    """Change the name of a Native Table's Custom Record Column.

    Use this tool to update the API name of a specific column within a Native Table's Custom Records. This is useful for developers managing data structures."""  # noqa: E501
    request_data: Any = {"new_name": new_column_name}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/custom-records/configure/native-tables/{native_table_name}/columns/{column_name}".format(  # noqa: UP032
            column_name=current_column_name, native_table_name=native_table_name
        ),
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["custom_records:read"]))
async def list_custom_tables(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_dev_api_custom_table'."]:
    """Fetch a list of custom tables from the developer API.

    Use this tool to retrieve all the custom tables available in the developer's environment. It should be called when you need to access or display these custom tables."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/custom-records/custom-tables",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["custom_records:read"]))
async def list_custom_table_columns(
    context: ToolContext,
    custom_table_name: Annotated[
        str, "The name of the custom table whose columns you want to list."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_dev_api_custom_table_column'."]:
    """Retrieve columns from a custom table.

    Use this tool to list all the columns of a specified custom table. Call this tool when you need the structure or schema of the table, including column names and other details."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/custom-records/custom-tables/{custom_table_name}/columns".format(  # noqa: UP032
            custom_table_name=custom_table_name
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["custom_records:read"]))
async def list_custom_table_rows(
    context: ToolContext,
    custom_table_name: Annotated[
        str,
        "The name of the custom table from which to retrieve rows. This should be a string representing the exact table name as defined in the Ramp service.",  # noqa: E501
    ],
    external_keys_list: Annotated[
        list[str] | None,
        "A list of external keys to specify which custom table rows to retrieve. Each key should be a string.",  # noqa: E501
    ] = None,
    include_all_referenced_rows: Annotated[
        bool | None,
        "Set to true to include all rows referenced by the main table rows, fetching related data.",
    ] = False,
    rows_per_page: Annotated[
        int | None, "Specifies the number of rows to return per page in the result set."
    ] = 50,
    start_row_index: Annotated[
        str | None,
        "The starting index to begin listing rows from the custom table. This determines where the retrieval starts in the dataset.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_dev_api_custom_row'."]:
    """Retrieve rows from a specified custom table.

    Use this tool to obtain a list of rows from a specific custom table. It's helpful for accessing table data entries stored in the Ramp service."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/custom-records/custom-tables/{custom_table_name}/rows".format(  # noqa: UP032
            custom_table_name=custom_table_name
        ),
        method="GET",
        params=remove_none_values({
            "external_key": external_keys_list,
            "include_all_referenced_rows": include_all_referenced_rows,
            "page_size": rows_per_page,
            "start": start_row_index,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["custom_records:write"]))
async def set_custom_table_rows(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    custom_table_name: Annotated[
        str | None,
        "The name of the custom table where values will be set. Provide the exact table name as a string.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'put_dev_api_custom_row'."]:
    """Set values for rows of a custom table.

    Use this tool to update or set values for the rows in a specified custom table. It is useful when you need to insert or modify data entries within a developer's custom table.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["SETCUSTOMTABLEROWS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not custom_table_name:
        missing_params.append(("custom_table_name", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["SETCUSTOMTABLEROWS"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["SETCUSTOMTABLEROWS"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/custom-records/custom-tables/{custom_table_name}/rows".format(  # noqa: UP032
            custom_table_name=custom_table_name
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["SETCUSTOMTABLEROWS"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["custom_records:write"]))
async def delete_custom_table_row(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    custom_table_name: Annotated[
        str | None,
        "The name of the custom table from which a row will be deleted. Expect a string.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_dev_api_custom_row'."]:
    """Delete a row from a specified custom table.

    This tool deletes a specified row from a custom table. Useful for removing entries that are no longer needed.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["DELETECUSTOMTABLEROW"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not custom_table_name:
        missing_params.append(("custom_table_name", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["DELETECUSTOMTABLEROW"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["DELETECUSTOMTABLEROW"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/custom-records/custom-tables/{custom_table_name}/rows".format(  # noqa: UP032
            custom_table_name=custom_table_name
        ),
        method="DELETE",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["DELETECUSTOMTABLEROW"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["custom_records:write"]))
async def append_cells_to_custom_table(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    custom_table_name: Annotated[
        str | None,
        "The name of the custom table to which cells will be appended. This must match an existing table name in your dataset.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_dev_api_append_custom_row_cells'."
]:
    """Append cells to a Custom Table.

    Use this tool to add new cells to a pre-existing custom table. Ideal for inserting new data entries row-wise to manage dynamic records effectively.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["APPENDCELLSTOCUSTOMTABLE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not custom_table_name:
        missing_params.append(("custom_table_name", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["APPENDCELLSTOCUSTOMTABLE"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["APPENDCELLSTOCUSTOMTABLE"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/custom-records/custom-tables/{table_name}/rows/-/append".format(  # noqa: UP032
            table_name=custom_table_name
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["APPENDCELLSTOCUSTOMTABLE"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["custom_records:write"]))
async def remove_custom_table_cells(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    custom_table_name: Annotated[
        str | None,
        "The name of the custom table from which you want to remove cells.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_dev_api_remove_custom_row_cells'."
]:
    """Removes specified cells from a custom table.

    This tool is used to remove cells from a specified custom table. Call this when you need to delete specific entries from a custom table.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["REMOVECUSTOMTABLECELLS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not custom_table_name:
        missing_params.append(("custom_table_name", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["REMOVECUSTOMTABLECELLS"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["REMOVECUSTOMTABLECELLS"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/custom-records/custom-tables/{table_name}/rows/-/remove".format(  # noqa: UP032
            table_name=custom_table_name
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["REMOVECUSTOMTABLECELLS"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["custom_records:read"]))
async def list_native_tables(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_dev_api_native_table'."]:
    """Retrieve a list of native Ramp tables.

    Use this tool to get a list of available native tables from Ramp's developer API. This can be helpful for developers looking to understand what tables are accessible via Ramp's native features."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/custom-records/native-tables",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["custom_records:read"]))
async def list_custom_columns_for_native_table(
    context: ToolContext,
    native_table_name: Annotated[
        str,
        "The name of the native Ramp table for which to list custom columns. This must be a valid table name used in the Ramp system.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_dev_api_native_table_column'."]:
    """Retrieve custom columns for a specified native table.

    This tool is used to list custom columns for a specified native Ramp table. It should be called when details about the custom columns of a specific native table are required for further processing or analysis."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/custom-records/native-tables/{native_table_name}/columns".format(  # noqa: UP032
            native_table_name=native_table_name
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["custom_records:read"]))
async def list_custom_column_values(
    context: ToolContext,
    native_table_name: Annotated[
        str,
        "The name of the native table to retrieve custom column values from. Specify the exact name as used in the Ramp database.",  # noqa: E501
    ],
    include_all_referenced_rows: Annotated[
        bool | None,
        "Include all referenced rows in the response. Set to true to include, false to exclude.",
    ] = False,
    max_results_per_page: Annotated[
        int | None,
        "Define the maximum number of row results to be returned per page. This helps in paginating the row data efficiently.",  # noqa: E501
    ] = 50,
    ramp_id_list: Annotated[
        list[str] | None,
        "Array of Ramp table identifiers. Provide these to specify which tables to retrieve data from. Each ID should be a string.",  # noqa: E501
    ] = None,
    starting_row_id: Annotated[
        str | None, "Specifies the ID of the first row to retrieve from the Native Ramp table."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_dev_api_native_row'."]:
    """List custom column values for a Native Ramp table's rows.

    Use this tool to retrieve the custom column values for specific rows in a Native Ramp table. Ideal for accessing detailed row data from custom records."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/custom-records/native-tables/{native_table_name}/rows".format(  # noqa: UP032
            native_table_name=native_table_name
        ),
        method="GET",
        params=remove_none_values({
            "include_all_referenced_rows": include_all_referenced_rows,
            "page_size": max_results_per_page,
            "ramp_id": ramp_id_list,
            "start": starting_row_id,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["custom_records:write"]))
async def update_ramp_table_rows(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    table_name: Annotated[
        str | None,
        "The name of the Native Ramp table to be updated. This is a string value representing the table's identifier.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'put_dev_api_native_row'."]:
    """Update or set values in a Native Ramp table row.

    Use this tool to update or set values for specific rows within a Native Ramp table. This is useful for modifying data entries in your custom records.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATERAMPTABLEROWS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not table_name:
        missing_params.append(("table_name", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATERAMPTABLEROWS"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATERAMPTABLEROWS"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/custom-records/native-tables/{native_table_name}/rows".format(  # noqa: UP032
            native_table_name=table_name
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATERAMPTABLEROWS"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["custom_records:write"]))
async def append_cells_to_native_table(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    native_table_name: Annotated[
        str | None,
        "The name of the Native Ramp table where cells will be appended. It must be a string identifying the specific table.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_dev_api_append_native_row_cells'."
]:
    """Append cells to a Native Ramp table.

    Use this tool to add new cells to an existing Native Ramp table. Ideal for expanding data sets or updating tables with additional information.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["APPENDCELLSTONATIVETABLE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not native_table_name:
        missing_params.append(("native_table_name", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["APPENDCELLSTONATIVETABLE"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["APPENDCELLSTONATIVETABLE"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/custom-records/native-tables/{native_table_name}/rows/-/append".format(  # noqa: UP032
            native_table_name=native_table_name
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["APPENDCELLSTONATIVETABLE"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["custom_records:write"]))
async def remove_cells_from_table(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    table_name: Annotated[
        str | None,
        "The name of the Native Ramp table from which cells will be removed. This should be a string matching the table's identifier.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_dev_api_remove_native_row_cells'."
]:
    """Remove cells from a specified Native Ramp table.

    Use this tool to remove specific cells from a Native Ramp table. It should be called when there is a need to delete data within the rows of the specified table.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["REMOVECELLSFROMTABLE"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not table_name:
        missing_params.append(("table_name", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["REMOVECELLSFROMTABLE"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["REMOVECELLSFROMTABLE"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/custom-records/native-tables/{native_table_name}/rows/-/remove".format(  # noqa: UP032
            native_table_name=table_name
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["REMOVECELLSFROMTABLE"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["departments:read"]))
async def list_departments(
    context: ToolContext,
    pagination_start_id: Annotated[
        str | None,
        "The ID of the last entity from the previous page to fetch the next set of departments.",
    ] = None,
    results_per_page: Annotated[
        int | None,
        "The number of departments to retrieve per page. Must be between 2 and 100; default is 20 if not specified.",  # noqa: E501
    ] = 20,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_department_list_with_pagination'."
]:
    """Retrieve a paginated list of departments.

    Use this tool to obtain a list of departments, which is useful for applications needing to browse or manage department data with pagination."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/departments",
        method="GET",
        params=remove_none_values({"start": pagination_start_id, "page_size": results_per_page}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["departments:write"]))
async def create_department(
    context: ToolContext,
    department_name: Annotated[str, "The name of the department to be created. Must be a string."],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_department_list_with_pagination'."
]:
    """Create a new department with pagination support.

    Use this tool to create a new department entry in the system. It supports pagination, allowing management of department listings efficiently."""  # noqa: E501
    request_data: Any = {"name": department_name}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/departments",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["departments:read"]))
async def fetch_department_details(
    context: ToolContext,
    department_identifier: Annotated[
        str, "Unique identifier for the department to fetch details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_department_resource'."]:
    """Fetch details of a specific department by ID.

    Use this tool to get detailed information about a department by providing its ID."""
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/departments/{department_id}".format(  # noqa: UP032
            department_id=department_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["departments:write"]))
async def update_department(
    context: ToolContext,
    department_identifier: Annotated[
        str,
        "The unique identifier for the department to be updated. This is required to specify which department's information will be changed.",  # noqa: E501
    ],
    department_name: Annotated[
        str, "Name of the department to update. Expect a string value that specifies the new name."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'patch_department_resource'."]:
    """Update department information by ID.

    Use this tool to update the details of a specified department identified by its ID. Useful for administrative changes or corrections."""  # noqa: E501
    request_data: Any = {"name": department_name}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/departments/{department_id}".format(  # noqa: UP032
            department_id=department_identifier
        ),
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["entities:read"]))
async def list_business_entities(
    context: ToolContext,
    filter_by_currency: Annotated[
        str | None,
        "Specify the currency to filter entities by. Accepts ISO 4217 currency codes such as 'USD', 'EUR', etc.",  # noqa: E501
    ] = None,
    filter_by_entity_name: Annotated[
        str | None, "Filter the list of business entities by their name."
    ] = None,
    include_deleted_accounts: Annotated[
        bool | None, "Include deleted accounts for entities. Defaults to False."
    ] = False,
    include_primary_entities: Annotated[
        bool | None,
        "Set to true to include only primary entities; false to include non-primary entities.",
    ] = None,
    pagination_start_id: Annotated[
        str | None, "The ID of the last entity on the previous page to fetch the next page."
    ] = None,
    results_per_page: Annotated[
        int | None,
        "The number of results to return per page, ranging from 2 to 100. Defaults to 20 if not specified.",  # noqa: E501
    ] = 20,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_entity_list_with_pagination'."]:
    """Retrieve a list of business entities with pagination.

    Use this tool to get a list of business entities, including pagination details, from the specified service."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/entities",
        method="GET",
        params=remove_none_values({
            "currency": filter_by_currency,
            "entity_name": filter_by_entity_name,
            "is_primary": include_primary_entities,
            "include_deleted_accounts": include_deleted_accounts,
            "start": pagination_start_id,
            "page_size": results_per_page,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["entities:read"]))
async def get_business_entity(
    context: ToolContext,
    entity_id: Annotated[
        str, "The unique identifier for the business entity to retrieve information."
    ],
    include_deleted_accounts: Annotated[
        bool | None,
        "Specify if deleted accounts should be included for entity retrieval. Defaults to False.",
    ] = False,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_entity_resource'."]:
    """Retrieve business entity information using an entity ID.

    Use this tool to get details about a business entity by providing its unique entity ID."""
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/entities/{entity_id}".format(entity_id=entity_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"include_deleted_accounts": include_deleted_accounts}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["item_receipts:read"]))
async def list_item_receipts(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_item_receipts_resource'."]:
    """Retrieve a list of item receipts from the Ramp service.

    This tool is used to fetch and display a list of item receipts from the Ramp platform. It should be called when an overview of item receipts is needed."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/item-receipts",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["item_receipts:write"]))
async def create_item_receipt(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_item_receipts_resource'."]:
    """Create a new item receipt for inventory tracking.

    This tool is used to create a new item receipt, typically for inventory tracking purposes. Call this tool when you need to log a received item in your system.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEITEMRECEIPT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEITEMRECEIPT"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEITEMRECEIPT"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/item-receipts",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEITEMRECEIPT"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["item_receipts:read"]))
async def fetch_item_receipt(
    context: ToolContext,
    item_receipt_identifier: Annotated[
        str,
        "The unique ID of the item receipt to be fetched. Provide this ID to retrieve specific receipt details.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_item_receipt_single_resource'."
]:
    """Fetches the details of a specific item receipt.

    Use this tool to retrieve the details of a specific item receipt by providing its ID."""
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/item-receipts/{item_receipt_id}".format(  # noqa: UP032
            item_receipt_id=item_receipt_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["item_receipts:write"]))
async def delete_item_receipt(
    context: ToolContext,
    item_receipt_identifier: Annotated[
        str, "A unique string identifier for the item receipt to be deleted."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'delete_item_receipt_single_resource'."
]:
    """Delete a specific item receipt by ID.

    Use this tool to delete an item receipt using its unique identifier. It should be called when an item receipt needs to be permanently removed from the system."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/item-receipts/{item_receipt_id}".format(  # noqa: UP032
            item_receipt_id=item_receipt_identifier
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["leads:write"]))
async def create_sales_lead(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_sales_lead_creation'."]:
    """Create a new sales lead.

    This tool creates a new sales lead in the system. It should be called when there's a need to register or track potential customer interest.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATESALESLEAD"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATESALESLEAD"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATESALESLEAD"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/leads",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATESALESLEAD"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["leads:read"]))
async def fetch_sales_lead(
    context: ToolContext,
    sales_lead_id: Annotated[
        str, "The unique identifier for the sales lead to fetch details for. Must be a string."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_sales_lead_resource'."]:
    """Fetch detailed information about a sales lead using its ID."""
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/leads/{sales_lead_id}".format(  # noqa: UP032
            sales_lead_id=sales_lead_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["limits:read"]))
async def list_spend_limits(
    context: ToolContext,
    filter_by_display_name: Annotated[
        str | None,
        "Filter limits by display name. Provide a string to refine the list of spend limits.",
    ] = None,
    filter_by_entity_id: Annotated[
        str | None, "Filter spend limits by the associated business entity ID."
    ] = None,
    filter_by_user_access_roles: Annotated[
        list[str] | None,
        "List of roles to filter on: 'OWNER', 'COOWNER', 'MEMBER'. Accepts repeated parameters or comma-separated values.",  # noqa: E501
    ] = None,
    filter_by_user_id: Annotated[
        str | None, "Filter spend limits that are owned by the specified user ID."
    ] = None,
    filter_created_after_date: Annotated[
        str | None,
        "Filter spend limits created after a certain date. Use ISO8601 format, e.g. 2024-01-15T00:00:00Z.",  # noqa: E501
    ] = None,
    filter_created_before_date: Annotated[
        str | None,
        "Filter for spend limits created before the specified date in ISO8601 format, e.g., 2024-01-15T00:00:00Z.",  # noqa: E501
    ] = None,
    filter_spend_program_id: Annotated[
        str | None,
        "Filter for spend limits related to the specified spend program. Use the program ID to retrieve relevant limits.",  # noqa: E501
    ] = None,
    filter_terminated_spend_limits: Annotated[
        bool | None, "Set to true to filter and show only terminated spend limits."
    ] = None,
    pagination_start_id: Annotated[
        str | None,
        "The ID of the last entity from the previous page to retrieve the next set of results.",
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Specify the number of results per page, between 2 and 100. Defaults to 20 if not set.",
    ] = 20,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_spend_limit_list_with_pagination'."
]:
    """Retrieve a list of spend limits with pagination.

    Use this tool to obtain a paginated list of spend limits, which is useful for managing and reviewing financial limits."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/limits",
        method="GET",
        params=remove_none_values({
            "display_name": filter_by_display_name,
            "entity_id": filter_by_entity_id,
            "spend_program_id": filter_spend_program_id,
            "user_id": filter_by_user_id,
            "created_after": filter_created_after_date,
            "created_before": filter_created_before_date,
            "is_terminated": filter_terminated_spend_limits,
            "user_access_roles": filter_by_user_access_roles,
            "start": pagination_start_id,
            "page_size": results_per_page,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["limits:write"]))
async def create_spend_limit(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_spend_limit_creation'."]:
    """Create a new spend limit with specified parameters.

    This tool creates a spend limit with optional spend program ID, display name, spending restrictions, and permitted spend types. Use this tool when you need to set financial limits for a spending program or without linking to a specific program.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATESPENDLIMIT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATESPENDLIMIT"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATESPENDLIMIT"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/limits/deferred",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATESPENDLIMIT"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["limits:write"]))
async def get_deferred_task_status(
    context: ToolContext,
    task_identifier: Annotated[
        str, "The unique identifier for the deferred task you want to check the status of."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_spend_limit_deferred_task_status'."
]:
    """Retrieve the status of a deferred task by task ID.

    Use this tool to get the current status of a deferred task using the task ID. Useful for monitoring task progress or completion."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/limits/deferred/status/{task_id}".format(  # noqa: UP032
            task_id=task_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["limits:read"]))
async def fetch_spend_limit(
    context: ToolContext,
    spend_limit_identifier: Annotated[
        str, "The unique identifier for the spend limit you want to retrieve details about."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_spend_limit_resource'."]:
    """Fetches details of a specified spend limit.

    This tool retrieves detailed information about a specific spend limit using the spend limit ID. It should be called when you need to know the specifics of a particular spending limit."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/limits/{spend_limit_id}".format(  # noqa: UP032
            spend_limit_id=spend_limit_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["limits:write"]))
async def update_spending_limit(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    spending_limit_id: Annotated[
        str | None,
        "A unique string identifier for the spending limit to be updated.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'put_spend_limit_resource'."]:
    """Update a spending limit for a specified resource.

    Use this tool to modify the spending limit for a given resource identified by its spend limit ID. It updates the limit and provides confirmation of the change.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATESPENDINGLIMIT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not spending_limit_id:
        missing_params.append(("spending_limit_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATESPENDINGLIMIT"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATESPENDINGLIMIT"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/limits/{spend_limit_id}".format(  # noqa: UP032
            spend_limit_id=spending_limit_id
        ),
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATESPENDINGLIMIT"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["limits:write"]))
async def update_spend_limit(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    spend_limit_identifier: Annotated[
        str | None,
        "The ID of the spend limit to be updated. Provide the unique identifier associated with the spend limit you wish to modify.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'patch_spend_limit_resource'."]:
    """Updates the specified spend limit.

    Use this tool to update the spend limit by providing the specific spend limit ID. This is useful for adjusting limits on resources as needed.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATESPENDLIMIT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not spend_limit_identifier:
        missing_params.append(("spend_limit_identifier", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATESPENDLIMIT"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATESPENDLIMIT"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/limits/{spend_limit_id}".format(  # noqa: UP032
            spend_limit_id=spend_limit_identifier
        ),
        method="PATCH",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATESPENDLIMIT"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["limits:write"]))
async def add_users_to_spend_limit(
    context: ToolContext,
    spend_limit_identifier: Annotated[
        str, "The unique identifier for the shared spending limit to which users will be added."
    ],
    user_ids_to_add: Annotated[
        list[str] | None,
        "An array of user IDs to be added to the shared spend limit. Each ID should be a string. Use this to specify which users will be included in the spending allocation.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'put_spend_allocation_add_users'."]:
    """Add new users to a shared spending limit.

    Use this tool to add new users to an existing shared spending limit. Useful for managing group financial allocations."""  # noqa: E501
    request_data: Any = {"user_ids": user_ids_to_add}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/limits/{spend_limit_id}/add-users".format(  # noqa: UP032
            spend_limit_id=spend_limit_identifier
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["limits:write"]))
async def terminate_spend_limit(
    context: ToolContext,
    idempotency_key: Annotated[
        str,
        "A unique string, typically a UUID, to recognize and retry the request without duplication.",  # noqa: E501
    ],
    spend_limit_identifier: Annotated[
        str, "The unique identifier for the spend limit to be terminated permanently."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_spend_limit_termination_resource'."
]:
    """Initiates an async task to permanently terminate a spend limit.

    This tool is used to create an asynchronous task that permanently terminates a specified spend limit. It should be called when there is a need to end a spend limit completely and ensure no further spending can occur under that limit."""  # noqa: E501
    request_data: Any = {"idempotency_key": idempotency_key}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/limits/{spend_limit_id}/deferred/termination".format(  # noqa: UP032
            spend_limit_id=spend_limit_identifier
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["limits:write"]))
async def remove_users_from_shared_limit(
    context: ToolContext,
    spend_limit_identifier: Annotated[
        str,
        "The identifier for the shared spending limit from which users will be removed. This should be a unique string representing the specific spend limit.",  # noqa: E501
    ],
    user_ids_to_remove: Annotated[
        list[str] | None, "An array of user IDs to remove from the shared spending limit."
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'delete_spend_allocation_delete_users'."
]:
    """Remove users from a shared spending limit.

    Use this tool to delete users associated with a specific shared spending limit, identified by the spend limit ID."""  # noqa: E501
    request_data: Any = {"user_ids": user_ids_to_remove}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/limits/{spend_limit_id}/delete-users".format(  # noqa: UP032
            spend_limit_id=spend_limit_identifier
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["limits:write"]))
async def suspend_spend_limit(
    context: ToolContext,
    spend_limit_identifier: Annotated[
        str,
        "The ID of the spend limit to suspend on Ramp. This should be a string representing the unique identifier.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_spend_limit_suspension_resource'."
]:
    """Suspend a spend limit on Ramp.

    Use this tool to suspend a specific spend limit identified by its ID on the Ramp platform."""
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/limits/{spend_limit_id}/suspension".format(  # noqa: UP032
            spend_limit_id=spend_limit_identifier
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["limits:write"]))
async def unsuspend_spend_limit(
    context: ToolContext,
    spend_limit_identifier: Annotated[
        str, "The unique string identifier of the spend limit to be unsuspended."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_spend_limit_unsuspension_resource'."
]:
    """Unsuspend a specified spend limit.

    This tool is used to unsuspend a previously suspended spend limit. Call this tool to restore a spend limit to active status."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/limits/{spend_limit_id}/unsuspension".format(  # noqa: UP032
            spend_limit_id=spend_limit_identifier
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["locations:read"]))
async def list_available_locations(
    context: ToolContext,
    filter_by_business_entity: Annotated[
        str | None,
        "Filter locations by their associated business entity ID. This expects a string representing the entity ID.",  # noqa: E501
    ] = None,
    pagination_start_id: Annotated[
        str | None, "The ID of the last entity from the previous page for pagination."
    ] = None,
    results_per_page: Annotated[
        int | None,
        "The number of locations to be returned per page. Must be between 2 and 100. Defaults to 20 if not specified.",  # noqa: E501
    ] = 20,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_location_list_resource'."]:
    """Retrieve a list of available locations.

    Use this tool to get the current list of locations available through the service."""
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/locations",
        method="GET",
        params=remove_none_values({
            "entity_id": filter_by_business_entity,
            "start": pagination_start_id,
            "page_size": results_per_page,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["locations:write"]))
async def create_location(
    context: ToolContext,
    location_name: Annotated[str, "Name of the location to be created."],
    business_entity_identifier: Annotated[
        str | None, "The identifier of the business entity to which this location belongs."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_location_list_resource'."]:
    """Create a new location entry.

    Use this tool to add a new location to the system. It should be called when you need to create a location resource using the provided data."""  # noqa: E501
    request_data: Any = {"entity_id": business_entity_identifier, "name": location_name}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/locations",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["locations:read"]))
async def fetch_location_details(
    context: ToolContext,
    location_identifier: Annotated[
        str,
        "The unique identifier for the location to fetch details about. It is required to specify which location to retrieve.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_location_single_resource'."]:
    """Retrieve detailed information about a specific location.

    Use this tool to obtain detailed information for a given location using its location ID. Ideal for scenarios where location details are required, such as maps or travel applications."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/locations/{location_id}".format(  # noqa: UP032
            location_id=location_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["locations:write"]))
async def update_location(
    context: ToolContext,
    location_id: Annotated[
        str,
        "The unique identifier of the location to be updated. It is required to specify which location's details are being modified.",  # noqa: E501
    ],
    updated_location_name: Annotated[str, "The new name for the location being updated."],
    updated_business_entity_id: Annotated[
        str | None, "The new identifier for the business entity associated with this location."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'patch_location_single_resource'."]:
    """Update the details of a location.

    This tool updates specific details for a given location using its ID. It should be called to modify location information."""  # noqa: E501
    request_data: Any = {"entity_id": updated_business_entity_id, "name": updated_location_name}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/locations/{location_id}".format(  # noqa: UP032
            location_id=location_id
        ),
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["memos:read"]))
async def list_memos_with_pagination(
    context: ToolContext,
    filter_by_card_id: Annotated[
        str | None, "Filter memos by the specified card ID to retrieve relevant entries."
    ] = None,
    filter_by_department_id: Annotated[
        str | None, "Filter memos by the specified department ID."
    ] = None,
    filter_by_end_date: Annotated[
        str | None, "Filter memos for transactions occurring before this date in ISO 8601 format."
    ] = None,
    filter_by_manager_id: Annotated[
        str | None, "Filter memos by providing the manager's ID."
    ] = None,
    filter_by_merchant_id: Annotated[
        str | None,
        "Filter memos by merchant ID to retrieve only those associated with a specific merchant.",
    ] = None,
    filter_memos_after_date: Annotated[
        str | None,
        "Filter memos for transactions occurring after this date. Use ISO 8601 format (YYYY-MM-DD).",  # noqa: E501
    ] = None,
    filter_memos_by_user_id: Annotated[
        str | None, "Filter memos by specifying the user ID."
    ] = None,
    location_identifier: Annotated[
        str | None, "Filter memos by specifying a location identifier."
    ] = None,
    pagination_last_entity_id: Annotated[
        str | None,
        "The ID of the last entity of the previous page to fetch the next set of results for pagination.",  # noqa: E501
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Specify the number of results to return per page, between 2 and 100. Defaults to 20 if not set.",  # noqa: E501
    ] = 20,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_memo_list_with_pagination'."]:
    """Retrieve a list of memos with pagination support.

    This tool calls the Ramp API to retrieve a list of memos, supporting pagination to handle large sets of data efficiently."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/memos",
        method="GET",
        params=remove_none_values({
            "card_id": filter_by_card_id,
            "department_id": filter_by_department_id,
            "location_id": location_identifier,
            "manager_id": filter_by_manager_id,
            "merchant_id": filter_by_merchant_id,
            "user_id": filter_memos_by_user_id,
            "from_date": filter_memos_after_date,
            "to_date": filter_by_end_date,
            "start": pagination_last_entity_id,
            "page_size": results_per_page,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["memos:read"]))
async def fetch_transaction_memo(
    context: ToolContext,
    transaction_id: Annotated[
        str, "The unique identifier for the transaction to fetch its memo. Expected as a string."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_memo_single_resource'."]:
    """Fetch the memo of a specific transaction using its ID."""
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/memos/{transaction_id}".format(  # noqa: UP032
            transaction_id=transaction_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["memos:write"]))
async def upload_transaction_memo(
    context: ToolContext,
    memo_text: Annotated[str, "Text content of the memo to create for a transaction."],
    transaction_identifier: Annotated[
        str,
        "The unique identifier for the transaction to which the memo will be uploaded. It should be a string representing the transaction's ID.",  # noqa: E501
    ],
    apply_memo_to_future_transactions: Annotated[
        bool | None,
        "Indicate if the memo should automatically apply to similar future transactions. Use true for recurring, false otherwise.",  # noqa: E501
    ] = False,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_memo_create_single_resource'."
]:
    """Upload a new memo for a specific transaction.

    Use this tool to upload a memo to a specified transaction. It is triggered when there is a need to add a note or explanation to a transaction."""  # noqa: E501
    request_data: Any = {"is_memo_recurring": apply_memo_to_future_transactions, "memo": memo_text}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/memos/{transaction_id}".format(  # noqa: UP032
            transaction_id=transaction_identifier
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["merchants:read"]))
async def list_merchants(
    context: ToolContext,
    filter_by_transaction_to_date: Annotated[
        str | None,
        "Filter merchants by transactions occurring on or before this date (format: YYYY-MM-DD).",
    ] = None,
    filter_from_date: Annotated[
        str | None,
        "Filter merchants by transactions on or after this date (`user_transaction_time`). Format: YYYY-MM-DD.",  # noqa: E501
    ] = None,
    pagination_start_id: Annotated[
        str | None, "The ID of the last entity from the previous page for pagination."
    ] = None,
    results_per_page: Annotated[
        int | None,
        "The number of merchants to return per page, between 2 and 100. Default is 20 if unspecified.",  # noqa: E501
    ] = 20,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_merchant_list_with_pagination'."
]:
    """Retrieve a list of merchants with pagination support.

    Use this tool to access a list of merchants, with the ability to paginate through results. Ideal for exploring available merchants or integrating merchant data into applications."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/merchants",
        method="GET",
        params=remove_none_values({
            "transaction_from_date": filter_from_date,
            "transaction_to_date": filter_by_transaction_to_date,
            "start": pagination_start_id,
            "page_size": results_per_page,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["purchase_orders:read"]))
async def list_purchase_orders(
    context: ToolContext,
    business_entity_id: Annotated[
        str | None, "Unique identifier for the associated business entity."
    ] = None,
    filter_before_creation_date: Annotated[
        str | None, "Filter for purchase orders requested before this date. Format: YYYY-MM-DD."
    ] = None,
    filter_from_created_date: Annotated[
        str | None,
        "Filter purchase orders created after a specified date. Expected format is ISO 8601 (YYYY-MM-DD).",  # noqa: E501
    ] = None,
    include_archived_orders: Annotated[
        bool | None, "Set to true to include archived purchase orders. Defaults to false."
    ] = False,
    pagination_start_id: Annotated[
        str | None,
        "The ID of the last entity from the previous page to retrieve the next page of results.",
    ] = None,
    purchase_order_creation_source: Annotated[
        str | None,
        "Specifies the origin of the purchase order. Options include ACCOUNTING_PROVIDER, DEVELOPER_API, or RAMP.",  # noqa: E501
    ] = None,
    receipt_status: Annotated[
        str | None,
        "Specify the receipt status of the purchase order. Options are: FULLY_RECEIVED, NOT_RECEIVED, OVER_RECEIVED, PARTIALLY_RECEIVED.",  # noqa: E501
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Sets the number of purchase orders returned per page. Must be between 2 and 100, default is 20.",  # noqa: E501
    ] = 20,
    spend_request_identifier: Annotated[
        str | None, "Unique identifier for the spend request linked to the purchase order."
    ] = None,
    three_way_match_enabled: Annotated[
        bool | None, "Set to true to enable three-way match for the purchase order."
    ] = False,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_purchase_orders_resource'."]:
    """Retrieve a list of purchase orders.

    Call this tool to obtain a list of current purchase orders. It can be used to view all purchase order details, including their statuses and related information."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/purchase-orders",
        method="GET",
        params=remove_none_values({
            "creation_source": purchase_order_creation_source,
            "from_created_at": filter_from_created_date,
            "to_created_at": filter_before_creation_date,
            "receipt_status": receipt_status,
            "start": pagination_start_id,
            "page_size": results_per_page,
            "entity_id": business_entity_id,
            "spend_request_id": spend_request_identifier,
            "three_way_match_enabled": three_way_match_enabled,
            "include_archived": include_archived_orders,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["purchase_orders:write"]))
async def create_purchase_order(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_purchase_orders_resource'."]:
    """Create a purchase order.

    This tool is used to create a new purchase order by sending the necessary details to the specified endpoint.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEPURCHASEORDER"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEPURCHASEORDER"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEPURCHASEORDER"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/purchase-orders",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEPURCHASEORDER"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["purchase_orders:read"]))
async def fetch_purchase_order(
    context: ToolContext,
    purchase_order_id: Annotated[
        str,
        "The unique identifier for the purchase order to be fetched. It should be a valid string that matches the ID format used in the system.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_purchase_order_single_resource'."
]:
    """Fetches details of a specific purchase order using its ID.

    Use this tool to retrieve detailed information about a specific purchase order by providing its ID. It should be called when you need to access or display purchase order details."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/purchase-orders/{purchase_order_id}".format(  # noqa: UP032
            purchase_order_id=purchase_order_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["purchase_orders:write"]))
async def archive_purchase_order(
    context: ToolContext,
    purchase_order_id: Annotated[
        str, "The unique identifier for the purchase order to be archived."
    ],
    archived_reason: Annotated[
        str | None,
        "Provide the reason for archiving the purchase order. This helps in keeping track of why the order is being archived for future reference and organization.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_purchase_order_archive_resource'."
]:
    """Archive a purchase order to manage records.

    This tool is used to archive a purchase order by specifying its ID. It helps in managing and organizing purchase records efficiently."""  # noqa: E501
    request_data: Any = {"archived_reason": archived_reason}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/purchase-orders/{purchase_order_id}/archive".format(  # noqa: UP032
            purchase_order_id=purchase_order_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["receipt_integrations:read"]))
async def list_opted_out_emails(
    context: ToolContext,
    search_email: Annotated[
        str | None, "Specify an email to filter the opted-out list for a specific address."
    ] = None,
    user_id: Annotated[
        str | None,
        "The identifier for the user whose opt-out status you want to check. This should be a string matching the user's account ID.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get_receipt_integration_opted_out_emails_list_resource'.",
]:
    """List emails opted out of receipt integrations.

    Use this tool to obtain a list of emails that have opted out of receipt integrations. It should be called when it's necessary to identify emails not participating in these integrations."""  # noqa: E501
    request_data: Any = {"email": search_email, "id": user_id}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/receipt-integrations/opt-out",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["receipt_integrations:write"]))
async def add_to_receipt_opt_out_list(
    context: ToolContext,
    business_id: Annotated[
        int,
        "The ID number of the business to associate the opt-out email with. It should be an integer.",  # noqa: E501
    ],
    opt_out_email: Annotated[
        str, "The email address to add to the receipt integrations opt-out list."
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'post_receipt_integration_opted_out_emails_list_resource'.",
]:
    """Add an email to the receipt integrations opt-out list.

    Use this tool to add a new email to the receipt integrations opt-out list, preventing receipt integrations for that email."""  # noqa: E501
    request_data: Any = {"business_id": business_id, "email": opt_out_email}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/receipt-integrations/opt-out",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["receipt_integrations:write"]))
async def opt_in_receipt_integration_email(
    context: ToolContext,
    email_uuid_to_opt_in: Annotated[
        str,
        "The UUID of the email to be opted into receipt integrations. It identifies the specific email previously opted out.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'delete_receipt_integration_opted_out_emails_delete_resource'.",
]:
    """Opt-in an email to receipt integrations.

    This tool is used to opt-in an email that was previously opted out of receipt integrations. It should be called when you need to reverse an email's opt-out status for receipt integrations."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/receipt-integrations/opt-out/{mailbox_opted_out_email_uuid}".format(  # noqa: UP032
            mailbox_opted_out_email_uuid=email_uuid_to_opt_in
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["receipts:read"]))
async def list_receipts(
    context: ToolContext,
    filter_created_after_date: Annotated[
        str | None, "Filter receipts created after this date in ISO8601 format."
    ] = None,
    filter_created_before_date: Annotated[
        str | None, "Filter receipts created before this date in ISO8601 format."
    ] = None,
    filter_from_date: Annotated[
        str | None,
        "Filter receipts; only include transactions with 'user_transaction_time' after this date (ISO8601 format).",  # noqa: E501
    ] = None,
    filter_transactions_before_date: Annotated[
        str | None,
        "Filter receipts for transactions with a `user_transaction_time` before this date (ISO8601 format).",  # noqa: E501
    ] = None,
    pagination_start_id: Annotated[
        str | None, "The ID of the last receipt from the previous page for pagination."
    ] = None,
    results_per_page: Annotated[
        int | None,
        "The number of results per page, between 2 and 100. Defaults to 20 if unspecified.",
    ] = 20,
    specific_transaction_id: Annotated[
        str | None, "Filter receipts for a specific transaction using its ID."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_receipt_list'."]:
    """Retrieve a list of all receipts.

    Call this tool to obtain a list of all receipts. Useful for fetching detailed receipt information."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/receipts",
        method="GET",
        params=remove_none_values({
            "created_after": filter_created_after_date,
            "created_before": filter_created_before_date,
            "transaction_id": specific_transaction_id,
            "from_date": filter_from_date,
            "to_date": filter_transactions_before_date,
            "start": pagination_start_id,
            "page_size": results_per_page,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["receipts:write"]))
async def upload_receipt_image(
    context: ToolContext,
    associated_user_id: Annotated[
        str,
        "ID of the user to be associated with the receipt for matching priority. Provide this to influence which transaction the receipt is matched with.",  # noqa: E501
    ],
    unique_idempotency_key: Annotated[
        str, "Unique string to prevent duplicate uploads. Use a UUID for uniqueness."
    ],
    transaction_id: Annotated[
        str | None,
        "ID of the transaction to link with the uploaded receipt. If not provided, automatic matching will be attempted based on context.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_receipt_upload'."]:
    """Upload a receipt image and optionally link it to a transaction.

    This tool uploads a receipt image to the Ramp service and can optionally associate it with a specific transaction by providing a transaction ID. If no transaction ID is provided, the service will attempt to match the receipt automatically. Use this tool when you need to manage receipts related to financial transactions."""  # noqa: E501
    request_data: Any = {
        "idempotency_key": unique_idempotency_key,
        "transaction_id": transaction_id,
        "user_id": associated_user_id,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/receipts",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["receipts:read"]))
async def fetch_receipt(
    context: ToolContext,
    receipt_identifier: Annotated[
        str,
        "The unique ID of the receipt to fetch. This is required to retrieve the correct receipt details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_receipt_single_resource'."]:
    """Fetches details of a specified receipt.

    Use this tool to retrieve the details of a receipt by providing the receipt ID. Ideal for accessing specific transaction information."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/receipts/{receipt_id}".format(  # noqa: UP032
            receipt_id=receipt_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["reimbursements:read"]))
async def list_reimbursements(
    context: ToolContext,
    filter_awaiting_approval_by_user_id: Annotated[
        str | None, "Filter reimbursements awaiting approval by a specific user's ID."
    ] = None,
    filter_before_creation_date: Annotated[
        str | None,
        "Filter reimbursements created before this date. Use ISO 8601 format (YYYY-MM-DD).",
    ] = None,
    filter_before_transaction_date: Annotated[
        str | None, "Filter reimbursements by transaction date occurring before this date."
    ] = None,
    filter_by_accounting_field_id: Annotated[
        str | None, "Filter reimbursements by the unique accounting field selection ID on Ramp."
    ] = None,
    filter_by_approval_status: Annotated[
        bool | None,
        "Pass true to filter approved reimbursements, false for not approved. If not specified, returns all.",  # noqa: E501
    ] = None,
    filter_by_direction: Annotated[
        str | None,
        "Specify the direction of reimbursements to filter by. Options are BUSINESS_TO_USER (default) or USER_TO_BUSINESS (for repayments).",  # noqa: E501
    ] = "BUSINESS_TO_USER",
    filter_by_entity_id: Annotated[
        str | None, "Filter reimbursements by specifying a business entity ID."
    ] = None,
    filter_by_sync_status: Annotated[
        str | None,
        "Filter reimbursements by sync status. Options are NOT_SYNC_READY, SYNCED, or SYNC_READY.",
    ] = None,
    filter_by_transaction_date_after: Annotated[
        str | None,
        "Specify a date to filter reimbursements by those with transaction dates after this date. Format: YYYY-MM-DD.",  # noqa: E501
    ] = None,
    filter_by_trip_id: Annotated[
        str | None,
        "Filter reimbursements associated with a specific trip by providing the trip's unique identifier.",  # noqa: E501
    ] = None,
    filter_by_user_id: Annotated[
        str | None, "Filter reimbursements by a specific user ID for targeted results."
    ] = None,
    filter_from_creation_date: Annotated[
        str | None, "Filter reimbursements created after this date. Use the format YYYY-MM-DD."
    ] = None,
    filter_reimbursements_submitted_before_date: Annotated[
        str | None, "Filter reimbursements submitted before this specified date."
    ] = None,
    filter_sync_ready: Annotated[
        bool | None, "Set to true to filter reimbursements that are ready to sync to ERP systems."
    ] = None,
    filter_synced_after_date: Annotated[
        str | None,
        "Filter reimbursements synced after the specified date. Provide the date in 'YYYY-MM-DD' format.",  # noqa: E501
    ] = None,
    filter_unsynced_reimbursements: Annotated[
        bool | None, "Set to true to filter reimbursements that haven't been synced to ERP systems."
    ] = None,
    filter_updated_after_date: Annotated[
        str | None, "Specify a date to filter reimbursements updated after this date."
    ] = None,
    pagination_start_id: Annotated[
        str | None,
        "The ID of the last entity from the previous page to fetch the next page of results.",
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Specify the number of reimbursement records per page (2 to 100, default is 20).",
    ] = 20,
    submitted_after_date: Annotated[
        str | None,
        "Filter reimbursements submitted after this date. Expected format is YYYY-MM-DD.",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_reimbursement_list_with_pagination'."
]:
    """Retrieve a paginated list of reimbursements.

    Use this tool to get a list of reimbursements. Supports pagination to navigate through large sets of data. Ideal for tracking expenses or auditing transactions."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/reimbursements",
        method="GET",
        params=remove_none_values({
            "direction": filter_by_direction,
            "sync_status": filter_by_sync_status,
            "from_transaction_date": filter_by_transaction_date_after,
            "to_transaction_date": filter_before_transaction_date,
            "awaiting_approval_by_user_id": filter_awaiting_approval_by_user_id,
            "has_been_approved": filter_by_approval_status,
            "trip_id": filter_by_trip_id,
            "accounting_field_selection_id": filter_by_accounting_field_id,
            "entity_id": filter_by_entity_id,
            "from_date": filter_from_creation_date,
            "to_date": filter_before_creation_date,
            "from_submitted_at": submitted_after_date,
            "to_submitted_at": filter_reimbursements_submitted_before_date,
            "synced_after": filter_synced_after_date,
            "sync_ready": filter_sync_ready,
            "has_no_sync_commits": filter_unsynced_reimbursements,
            "updated_after": filter_updated_after_date,
            "start": pagination_start_id,
            "page_size": results_per_page,
            "user_id": filter_by_user_id,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["reimbursements:write"]))
async def create_mileage_reimbursement(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_mileage_reimbursement_resource'."
]:
    """Create a mileage reimbursement entry.

    Use this tool to create a mileage reimbursement entry when mileage needs to be compensated. This is useful for generating records for reimbursements based on travel mileage.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEMILEAGEREIMBURSEMENT"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATEMILEAGEREIMBURSEMENT"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["CREATEMILEAGEREIMBURSEMENT"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/reimbursements/mileage",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEMILEAGEREIMBURSEMENT"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["reimbursements:write"]))
async def upload_reimbursement_receipt(
    context: ToolContext,
    unique_idempotency_key: Annotated[
        str,
        "Unique value to prevent duplicate uploads. Use a UUID to ensure uniqueness and avoid collisions.",  # noqa: E501
    ],
    user_id_for_reimbursement: Annotated[
        str, "UUID of the user for whom the reimbursement is to be created."
    ],
    existing_reimbursement_id: Annotated[
        str | None,
        "Optional UUID of an existing reimbursement to attach the receipt to. If not provided, a new draft will be created via OCR.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_reimbursement_receipt_upload'."
]:
    """Uploads a receipt for reimbursement processing.

    Use this tool to upload a receipt for a reimbursement. If a `reimbursement_id` is provided, the receipt is linked to that reimbursement. Otherwise, a draft reimbursement is created via OCR."""  # noqa: E501
    request_data: Any = {
        "idempotency_key": unique_idempotency_key,
        "reimbursee_id": user_id_for_reimbursement,
        "reimbursement_id": existing_reimbursement_id,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/reimbursements/submit-receipt",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["reimbursements:read"]))
async def fetch_reimbursement(
    context: ToolContext,
    reimbursement_id: Annotated[
        str,
        "The unique identifier for the reimbursement request you want to fetch. This should be the ID that uniquely represents a particular reimbursement.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_reimbursement_resource'."]:
    """Fetch details of a reimbursement request.

    Use this tool to retrieve detailed information about a specific reimbursement request by providing the reimbursement ID."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/reimbursements/{reimbursement_id}".format(  # noqa: UP032
            reimbursement_id=reimbursement_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["spend_programs:read"]))
async def list_spend_programs(
    context: ToolContext,
    pagination_start_id: Annotated[
        str | None, "The ID for starting pagination from the last entity of the previous page."
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Specify the number of results per page, between 2 and 100. Defaults to 20 if not specified.",  # noqa: E501
    ] = 20,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_spend_program_resource'."]:
    """Retrieve a list of available spend programs.

    This tool fetches and returns a list of all available spend programs. It should be called when there's a need to view or manage current spend programs."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/spend-programs",
        method="GET",
        params=remove_none_values({"start": pagination_start_id, "page_size": results_per_page}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["spend_programs:write"]))
async def create_spend_program(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_spend_program_resource'."]:
    """Create a spend program to manage expenses.

    This tool is used to create a new spend program, helping in organizing and managing expenses. It should be called when there is a need to set up a structured spending plan.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATESPENDPROGRAM"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATESPENDPROGRAM"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATESPENDPROGRAM"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/spend-programs",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATESPENDPROGRAM"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["spend_programs:read"]))
async def fetch_spend_program(
    context: ToolContext,
    spend_program_identifier: Annotated[
        str, "The unique identifier for the spend program to fetch details for."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_spend_program_single_resource'."
]:
    """Fetches details of a specific spend program using its ID.

    This tool retrieves information about a specific spend program by using its unique identifier. It should be called when details about the program are needed, such as in financial reporting or management tasks."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/spend-programs/{spend_program_id}".format(  # noqa: UP032
            spend_program_id=spend_program_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["statements:read"]))
async def list_statements_with_pagination(
    context: ToolContext,
    end_date_before: Annotated[
        str | None,
        "Filter statements with an end_date on or before this date (ISO8601 format). Defaults to the current time if not provided.",  # noqa: E501
    ] = None,
    filter_from_date: Annotated[
        str | None,
        "Filter statements with end_date on or after this date. Use ISO8601 format (e.g., '2023-01-01').",  # noqa: E501
    ] = "1970-01-01T00:00:00+00:00",
    pagination_start_id: Annotated[
        str | None, "ID of the last entity from the previous page to retrieve the next page."
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Specify the number of results per page. Must be between 2 and 100. Defaults to 20 if not specified.",  # noqa: E501
    ] = 20,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_statement_list_with_pagination'."
]:
    """Retrieve and list financial statements with pagination.

    Use this tool to obtain a list of financial statements, supporting pagination for easier data management. It's helpful for users needing detailed or summarized financial records."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/statements",
        method="GET",
        params=remove_none_values({
            "from_date": filter_from_date,
            "to_date": end_date_before,
            "start": pagination_start_id,
            "page_size": results_per_page,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["statements:read"]))
async def fetch_statement(
    context: ToolContext,
    statement_identifier: Annotated[
        str,
        "The unique identifier for the statement to be fetched. It should be a string matching the statement's ID.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_statement_resource'."]:
    """Fetch detailed information about a specific statement.

    Use this tool to retrieve a statement by its ID. Ideal for viewing billing or transaction details."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/statements/{statement_id}".format(  # noqa: UP032
            statement_id=statement_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["transactions:read"]))
async def fetch_transaction_details(
    context: ToolContext,
    transaction_id: Annotated[
        str, "A unique identifier for the transaction to fetch its detailed information."
    ],
    include_merchant_data: Annotated[
        bool | None, "Include all purchase data provided by the merchant when set to true."
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_transaction_canonical_resource'."
]:
    """Fetch detailed information about a transaction.

    This tool retrieves the canonical resource details for a transaction specified by its ID. It should be called when you need comprehensive information about a particular transaction."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/transactions/{transaction_id}".format(  # noqa: UP032
            transaction_id=transaction_id
        ),
        method="GET",
        params=remove_none_values({"include_merchant_data": include_merchant_data}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["transfers:read"]))
async def get_transfer_list(
    context: ToolContext,
    business_entity_id: Annotated[
        str | None, "Filter transfers based on the specified business entity ID."
    ] = None,
    filter_by_statement_id: Annotated[
        str | None, "Include only transfers associated with the specified statement ID."
    ] = None,
    filter_by_sync_status: Annotated[
        str | None,
        "Specify the sync status to filter transfers. Options: NOT_SYNC_READY, SYNCED, SYNC_READY.",
    ] = None,
    filter_from_date: Annotated[
        str | None,
        "Specify the date to filter transfers that occurred after this date, in ISO8601 format.",
    ] = None,
    filter_transfers_before_date: Annotated[
        str | None, "Filter transfers that occurred before this date (in ISO8601 format)."
    ] = None,
    filter_unsynced_transfers: Annotated[
        bool | None, "Filter transfers that have not been synced when set to true."
    ] = None,
    pagination_start_id: Annotated[
        str | None,
        "The ID of the last entity on the previous page to fetch the next set of results in pagination.",  # noqa: E501
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Specify the number of results per page, between 2 and 100. Defaults to 20 if unspecified.",
    ] = 20,
    transfer_status_filter: Annotated[
        str | None,
        "Specify the status to filter transfers by, using predefined status codes. Accepts values such as 'ACH_CONFIRMED', 'CANCELED', 'COMPLETED', etc.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_transfer_list_with_pagination'."
]:
    """Retrieve a paginated list of transfers.

    Use this tool to get a list of financial transfers, including pagination details for navigating large datasets. It helps in checking transaction histories and managing transfer records."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/transfers",
        method="GET",
        params=remove_none_values({
            "sync_status": filter_by_sync_status,
            "status": transfer_status_filter,
            "entity_id": business_entity_id,
            "statement_id": filter_by_statement_id,
            "has_no_sync_commits": filter_unsynced_transfers,
            "from_date": filter_from_date,
            "to_date": filter_transfers_before_date,
            "start": pagination_start_id,
            "page_size": results_per_page,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["transfers:read"]))
async def get_transfer_details(
    context: ToolContext,
    transfer_id: Annotated[
        str,
        "The unique identifier for the transfer. Use this to retrieve specific transfer details.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_transfer_resource'."]:
    """Retrieve transfer details using a specific transfer ID.

    Use this tool to get detailed information about a transfer by providing its unique transfer ID. Ideal for checking the status or details of a particular transfer operation."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/transfers/{transfer_id}".format(  # noqa: UP032
            transfer_id=transfer_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["users:read"]))
async def list_users(
    context: ToolContext,
    business_entity_id: Annotated[
        str | None, "Filter the list of users by specifying a business entity ID."
    ] = None,
    filter_by_department_id: Annotated[
        str | None, "Filter the user list by a specific department ID to narrow down the results."
    ] = None,
    filter_by_email: Annotated[
        str | None, "Filter users by their email address for precise retrieval."
    ] = None,
    filter_by_employee_id: Annotated[
        str | None, "Filter users by their employee ID to narrow down the user list."
    ] = None,
    filter_by_location_id: Annotated[
        str | None, "Specify a location ID to filter users by their location."
    ] = None,
    include_deleted_users: Annotated[
        bool | None, "Set to true to include deleted users in the response. Defaults to false."
    ] = False,
    pagination_start_id: Annotated[
        str | None, "The ID of the last entity from the previous page for pagination."
    ] = None,
    results_per_page: Annotated[
        int | None,
        "The number of results returned per page. Must be between 2 and 100. Defaults to 20 if not specified.",  # noqa: E501
    ] = 20,
    user_role_filter: Annotated[
        str | None,
        "Specify the role to filter users. Valid roles include: AUDITOR, BUSINESS_ADMIN, BUSINESS_BOOKKEEPER, BUSINESS_OWNER, BUSINESS_USER, GUEST_USER, IT_ADMIN.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_user_list_with_pagination'."]:
    """Retrieve a paginated list of users.

    This tool is used to fetch a list of users from the service. It supports pagination to manage large sets of user data efficiently."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/users",
        method="GET",
        params=remove_none_values({
            "employee_id": filter_by_employee_id,
            "role": user_role_filter,
            "include_deleted": include_deleted_users,
            "start": pagination_start_id,
            "page_size": results_per_page,
            "entity_id": business_entity_id,
            "department_id": filter_by_department_id,
            "email": filter_by_email,
            "location_id": filter_by_location_id,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["users:write"]))
async def send_user_invite_async(
    context: ToolContext,
    employee_email_address: Annotated[
        str, "The email address of the employee to whom the invite will be sent."
    ],
    employee_first_name: Annotated[str, "The first name of the employee receiving the invite."],
    employee_last_name: Annotated[str, "Provide the last name of the employee to be invited."],
    employee_role: Annotated[
        str,
        "The employee's role. Options: Admin, Cardholder, Bookkeeper. Note: Owner is not invitable.",  # noqa: E501
    ],
    unique_idempotency_key: Annotated[
        str,
        "A unique identifier for the request, used to recognize and manage retries. Use a randomly generated UUID to avoid collisions.",  # noqa: E501
    ],
    direct_manager_identifier: Annotated[
        str | None, "Unique identifier of the employee's direct manager."
    ] = None,
    employee_department_identifier: Annotated[
        str | None,
        "Unique identifier of the employee's department. Required for assigning the user to the correct department.",  # noqa: E501
    ] = None,
    employee_location_identifier: Annotated[
        str | None, "Unique identifier for the employee's location, mapped to a specific entity."
    ] = None,
    is_manager: Annotated[bool | None, "Indicate whether the employee is a manager."] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_user_creation_deferred_task'."
]:
    """Initiate an async task to send a user invite email.

    Use this tool to start an asynchronous task for sending a user invitation via email. This is part of the onboarding process where users need to accept the invite to continue. Assign the user to a specific entity by providing a location_id."""  # noqa: E501
    request_data: Any = {
        "department_id": employee_department_identifier,
        "direct_manager_id": direct_manager_identifier,
        "email": employee_email_address,
        "first_name": employee_first_name,
        "idempotency_key": unique_idempotency_key,
        "is_manager": is_manager,
        "last_name": employee_last_name,
        "location_id": employee_location_identifier,
        "role": employee_role,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/users/deferred",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["users:write"]))
async def retrieve_task_status(
    context: ToolContext,
    task_id: Annotated[
        str,
        "The unique identifier for the deferred task to retrieve its status. This should be a string.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_user_deferred_task_resource'."]:
    """Fetch the status of a deferred task by task ID.

    Call this tool to check the status and details of a specific deferred task using its task ID."""
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/users/deferred/status/{task_id}".format(  # noqa: UP032
            task_id=task_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["users:read"]))
async def fetch_user_info(
    context: ToolContext,
    user_identifier: Annotated[
        str,
        "The unique identifier of the user to fetch. This should be a string representing the user's ID.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_user_resource'."]:
    """Fetch detailed information about a user by ID.

    This tool retrieves detailed user information, including profile details, by using a user ID. It should be called when there is a need to access specific user data."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/users/{user_id}".format(user_id=user_identifier),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["users:write"]))
async def update_user_details(
    context: ToolContext,
    user_identifier: Annotated[
        str, "A unique string to identify the user whose details are to be updated."
    ],
    auto_promote_manager: Annotated[
        bool | None, "Set to true to automatically promote the user's manager to manager."
    ] = None,
    department_unique_identifier: Annotated[
        str | None, "Unique identifier for the user's department to be updated."
    ] = None,
    employee_direct_manager_id: Annotated[
        str | None,
        "Unique identifier for the employee's direct manager. This ID links the employee to their manager within the system.",  # noqa: E501
    ] = None,
    employee_role: Annotated[
        str | None,
        "The employee's role, restricted to Admin, Cardholder, or Bookkeeper. Note: Owner is not allowed.",  # noqa: E501
    ] = None,
    is_manager: Annotated[
        bool | None,
        "Indicates whether the employee is a manager. Set to true if they are a manager, false otherwise.",  # noqa: E501
    ] = None,
    last_name: Annotated[
        str | None,
        "The last name of the user. This field is required for identifying and updating the user's profile.",  # noqa: E501
    ] = None,
    location_identifier: Annotated[
        str | None, "Unique identifier of the employee's location for updating location details."
    ] = None,
    user_first_name: Annotated[
        str | None, "The first name of the user to be updated. It must be a string."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'patch_user_resource'."]:
    """Update a user's profile information.

    Use this tool to modify the details of a user's profile based on their user ID. It updates user-specific information and returns the updated profile details."""  # noqa: E501
    request_data: Any = {
        "auto_promote": auto_promote_manager,
        "department_id": department_unique_identifier,
        "direct_manager_id": employee_direct_manager_id,
        "first_name": user_first_name,
        "is_manager": is_manager,
        "last_name": last_name,
        "location_id": location_identifier,
        "role": employee_role,
    }
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/users/{user_id}".format(user_id=user_identifier),  # noqa: UP032
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["users:write"]))
async def deactivate_user_account(
    context: ToolContext,
    user_account_id: Annotated[
        str, "The unique identifier for the user whose account is to be deactivated."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'patch_user_deactivation_resource'."
]:
    """Deactivate a user's account to restrict access.

    This tool should be called to deactivate a user's account, preventing them from logging in, using cards, or receiving notifications."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/users/{user_id}/deactivate".format(  # noqa: UP032
            user_id=user_account_id
        ),
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["users:write"]))
async def reactivate_user_account(
    context: ToolContext,
    user_id: Annotated[
        str,
        "The unique identifier for the user account to be reactivated. This is required to execute the reactivation process.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'patch_user_reactivation_resource'."
]:
    """Reactivates a user's account to restore access and notifications.

    Use this tool to reactivate a user's Ramp account, allowing them to log in, use their cards, and receive notifications again."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/users/{user_id}/reactivate".format(user_id=user_id),  # noqa: UP032
        method="PATCH",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["cards:read_vault", "limits:write"]))
async def create_spend_allocation_card(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_card_vault_creation'."]:
    """Create a new spend allocation and retrieve card details.

    This tool creates a new spend allocation and provides sensitive card details. It should be used when there is a need to generate a card vault in the Ramp system.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATESPENDALLOCATIONCARD"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATESPENDALLOCATIONCARD"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATESPENDALLOCATIONCARD"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/vault/cards",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATESPENDALLOCATIONCARD"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["vendors:read"]))
async def get_vendor_list(
    context: ToolContext,
    created_after_date: Annotated[
        str | None, "Filter vendors created after this date. Use ISO 8601 format."
    ] = None,
    filter_by_category_ids: Annotated[
        str | None, "Comma-separated list of integers to filter vendors by Ramp Category Codes."
    ] = None,
    include_only_active_vendors: Annotated[
        bool | None, "Set to true to show only active vendors. False includes all vendors."
    ] = None,
    pagination_start_id: Annotated[
        str | None,
        "ID of the last entity from the previous page to retrieve the next set of results. Used for pagination.",  # noqa: E501
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Specify the number of vendor results to return per page, between 2 and 100. The default is 20 if not provided.",  # noqa: E501
    ] = 20,
    vendor_name_filter: Annotated[
        str | None,
        "Filter vendors by name. Provide a string to match vendor names containing this value.",
    ] = None,
    vendor_owner_identifier: Annotated[
        str | None,
        "Unique identifier of the user who owns the vendor. Provide a valid user ID string.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_vendor_list_resource'."]:
    """Retrieve a list of available vendors.

    This tool retrieves a list of vendors from the Ramp service. It should be called when you need to access or display vendor information."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/vendors",
        method="GET",
        params=remove_none_values({
            "sk_category_ids": filter_by_category_ids,
            "from_created_at": created_after_date,
            "start": pagination_start_id,
            "page_size": results_per_page,
            "vendor_owner_id": vendor_owner_identifier,
            "is_active": include_only_active_vendors,
            "name": vendor_name_filter,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["vendors:write"]))
async def create_vendor(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'post_vendor_list_resource'."]:
    """Create and approve a new vendor automatically.

    This tool is used to create a new vendor via the API. Vendors created are approved by default and bypass existing approval policies. Use this when you need to quickly add a vendor to the system.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATEVENDOR"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEVENDOR"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["CREATEVENDOR"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/vendors",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATEVENDOR"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["vendors:read"]))
async def fetch_vendor_details(
    context: ToolContext,
    vendor_id: Annotated[
        str,
        "The unique ID of the vendor to fetch details for. This is required to identify and retrieve the correct vendor profile.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_vendor_resource'."]:
    """Fetch vendor details using the vendor ID.

    This tool retrieves detailed information about a specific vendor using their unique vendor ID. It should be called when you need to access vendor profiles and relevant details."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/vendors/{vendor_id}".format(vendor_id=vendor_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["vendors:write"]))
async def update_vendor(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    vendor_identifier: Annotated[
        str | None,
        "The unique identifier for the vendor to be updated. This should be a string value representing the vendor's ID.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'patch_vendor_resource'."]:
    """Updates the details of an existing vendor.

    Use this tool to modify and update the details of an existing vendor when changes are required to their information.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATEVENDOR"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not vendor_identifier:
        missing_params.append(("vendor_identifier", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEVENDOR"] + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n" + REQUEST_BODY_SCHEMAS["UPDATEVENDOR"] + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/vendors/{vendor_id}".format(  # noqa: UP032
            vendor_id=vendor_identifier
        ),
        method="PATCH",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATEVENDOR"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["vendors:write"]))
async def remove_vendor(
    context: ToolContext,
    vendor_identifier: Annotated[
        str,
        "The unique identifier of the vendor to be deleted. Ensure the vendor has no associated dependencies.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'delete_vendor_resource'."]:
    """Delete a vendor, if no associated dependencies exist.

    Use this tool to delete a vendor from the system, provided there are no associated transactions, bills, contracts, or spend requests linked to the vendor. The operation will confirm if the vendor is successfully deleted or if deletion was not possible due to existing dependencies."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/vendors/{vendor_id}".format(  # noqa: UP032
            vendor_id=vendor_identifier
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["vendors:read"]))
async def list_vendor_bank_accounts(
    context: ToolContext,
    vendor_id: Annotated[
        str, "The unique identifier for the vendor whose bank accounts are being retrieved."
    ],
    last_entity_id_for_pagination: Annotated[
        str | None, "The ID of the last vendor bank account from the previous page for pagination."
    ] = None,
    results_per_page: Annotated[
        int | None,
        "The number of results returned per page, between 2 and 100. Defaults to 20 if unspecified.",  # noqa: E501
    ] = 20,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_vendor_bank_account_list_resource'."
]:
    """Retrieve a list of vendor bank accounts.

    Use this tool to obtain a list of bank accounts associated with a specific vendor. Useful for managing vendor payments or verifying banking details."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/vendors/{vendor_id}/accounts".format(  # noqa: UP032
            vendor_id=vendor_id
        ),
        method="GET",
        params=remove_none_values({
            "start": last_entity_id_for_pagination,
            "page_size": results_per_page,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["vendors:read"]))
async def fetch_vendor_bank_account(
    context: ToolContext,
    bank_account_identifier: Annotated[
        str, "The unique identifier of the bank account to be fetched."
    ],
    vendor_id: Annotated[
        str, "Unique identifier for the vendor whose bank account details are to be fetched."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_vendor_bank_account_resource'."
]:
    """Fetch the bank account details of a specific vendor.

    Use this tool to retrieve detailed information about a vendor's bank account based on the vendor ID and bank account ID."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/vendors/{vendor_id}/accounts/{bank_account_id}".format(  # noqa: UP032
            bank_account_id=bank_account_identifier, vendor_id=vendor_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["vendors:read"]))
async def get_vendor_contacts(
    context: ToolContext,
    vendor_id: Annotated[
        str,
        "The unique identifier for the vendor whose contacts you want to retrieve. It must be a valid string representing the vendor ID.",  # noqa: E501
    ],
    pagination_start_id: Annotated[
        str | None,
        "The ID of the last entity from the previous page, used to paginate to the next set of results.",  # noqa: E501
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Number of results per page, between 2 and 100. Defaults to 20 if not specified.",
    ] = 20,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_vendor_contact_list_resource'."
]:
    """Retrieve a list of contacts for a given vendor.

    Use this tool to obtain contact information associated with a specific vendor by providing the vendor ID."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/vendors/{vendor_id}/contacts".format(  # noqa: UP032
            vendor_id=vendor_id
        ),
        method="GET",
        params=remove_none_values({"start": pagination_start_id, "page_size": results_per_page}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["vendors:read"]))
async def fetch_vendor_contact(
    context: ToolContext,
    vendor_contact_id: Annotated[
        str,
        "The unique identifier for the vendor contact to be fetched. It is a string value associated with a specific contact.",  # noqa: E501
    ],
    vendor_id: Annotated[
        str,
        "The unique identifier for the vendor whose contact information you want to retrieve. This is a required field.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_vendor_contact_resource'."]:
    """Fetch a specific vendor contact's details.

    Use this tool to retrieve contact information for a specific vendor using their vendor ID and contact ID."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/vendors/{vendor_id}/contacts/{vendor_contact_id}".format(  # noqa: UP032
            vendor_contact_id=vendor_contact_id, vendor_id=vendor_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp", scopes=["vendors:write"]))
async def update_vendor_payment_details(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    vendor_identifier: Annotated[
        str | None,
        "The unique identifier for the vendor whose payment details are to be updated. This should be a string.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_vendor_bank_account_update_resource'."
]:
    """Add or update payment details for a vendor.

    Use this tool to add or update payment details for a vendor through the business's approval workflow. Supports ACH and Wire transfer methods, requiring routing and account numbers. The proposal may require approval based on the business's policies.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATEVENDORPAYMENTDETAILS"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not vendor_identifier:
        missing_params.append(("vendor_identifier", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{p[0]} ({p[1]})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {param_names}",
            developer_message=(f"Required parameters validation failed: {param_details}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{param_details}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATEVENDORPAYMENTDETAILS"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["UPDATEVENDORPAYMENTDETAILS"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/vendors/{vendor_id}/update-bank-accounts".format(  # noqa: UP032
            vendor_id=vendor_identifier
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATEVENDORPAYMENTDETAILS"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp"))
async def get_webhook_subscriptions(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'get_outbound_webhook_subscription_resource'."
]:
    """Retrieve all outbound webhook subscriptions.

    Call this tool to get a list of all currently registered outbound webhook subscriptions from the service."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/webhooks",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp"))
async def register_webhook_subscription(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'post_outbound_webhook_subscription_resource'."
]:
    """Register a new outbound webhook subscription.

    This tool registers a new outbound webhook subscription. The newly registered subscription will be in a pending verification state, requiring verification with the provided challenge.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["REGISTERWEBHOOKSUBSCRIPTION"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["REGISTERWEBHOOKSUBSCRIPTION"]
                + "\n```"
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n```json\n"
                + REQUEST_BODY_SCHEMAS["REGISTERWEBHOOKSUBSCRIPTION"]
                + "\n```"
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://api.ramp.com/developer/v1/webhooks",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["REGISTERWEBHOOKSUBSCRIPTION"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp"))
async def get_webhook_subscription_by_id(
    context: ToolContext,
    webhook_identifier: Annotated[
        str, "The unique identifier for the webhook subscription to retrieve details."
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'get_outbound_webhook_subscription_detail_resource'.",
]:
    """Retrieve details of a webhook subscription by ID.

    Call this tool to get detailed information about a specific webhook subscription using its ID. Useful for managing or verifying webhook configurations."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/webhooks/{webhook_id}".format(  # noqa: UP032
            webhook_id=webhook_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp"))
async def delete_webhook_subscription(
    context: ToolContext,
    webhook_id: Annotated[
        str,
        "The unique ID of the webhook subscription to be deleted. This should be a string that distinctly identifies the webhook subscription.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'delete_outbound_webhook_subscription_detail_resource'.",
]:
    """Deletes a webhook subscription based on its ID.

    Use this tool to delete a webhook subscription by providing its unique ID. This is useful for managing and cleaning up webhook subscription lists by removing unwanted or outdated entries."""  # noqa: E501
    request_data: Any = None
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/webhooks/{webhook_id}".format(webhook_id=webhook_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-ramp"))
async def verify_webhook_subscription(
    context: ToolContext,
    webhook_identifier: Annotated[
        str, "The unique identifier for the webhook subscription to verify."
    ],
    webhook_verification_challenge: Annotated[str, "A string used to verify the webhook endpoint."],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'post_outbound_webhook_subscription_verify_resource'.",
]:
    """Verify a webhook subscription to ensure proper setup.

    Use this tool to verify the setup of a webhook subscription by confirming its configuration is correct."""  # noqa: E501
    request_data: Any = {"challenge": webhook_verification_challenge}
    if isinstance(request_data, dict):
        request_data = remove_none_values(request_data)
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://api.ramp.com/developer/v1/webhooks/{webhook_id}/verify".format(  # noqa: UP032
            webhook_id=webhook_identifier
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}
