"""Arcade Starter Tools for okta

DO NOT EDIT THIS MODULE DIRECTLY.

THIS MODULE WAS AUTO-GENERATED BY TRANSPILING THE API STARTER TOOL JSON DEFINITIONS
IN THE ../wrapper_tools DIRECTORY INTO PYTHON CODE. ANY CHANGES TO THIS MODULE WILL
BE OVERWRITTEN BY THE TRANSPILER.
"""

import asyncio
from typing import Annotated, Any

import httpx
from arcade_tdk import ToolContext, tool
from arcade_tdk.auth import OAuth2

# Retry configuration
INITIAL_RETRY_DELAY = 0.5  # seconds

HTTP_CLIENT = httpx.AsyncClient(
    timeout=httpx.Timeout(60.0, connect=10.0),
    limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
    transport=httpx.AsyncHTTPTransport(retries=3),
    http2=True,
    follow_redirects=True,
)


def remove_none_values(data: dict[str, Any]) -> dict[str, Any]:
    return {k: v for k, v in data.items() if v is not None}


async def make_request(
    url: str,
    method: str,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    data: dict[str, Any] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with retry logic for 5xx server errors."""
    for attempt in range(max_retries):
        try:
            response = await HTTP_CLIENT.request(
                url=url,
                method=method,
                params=params,
                headers=headers,
                data=data,
            )
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            # Only retry on 5xx server errors
            if e.response.status_code >= 500 and attempt < max_retries - 1:
                # Exponential backoff: 0.5s, 1s, 2s
                await asyncio.sleep(INITIAL_RETRY_DELAY * (2**attempt))
                continue
            # Re-raise for 4xx errors or if max retries reached
            raise
        except httpx.RequestError as e:
            # Don't retry request errors (network issues are handled by transport)
            raise
        else:
            return response

    # This should never be reached, but satisfies type checker
    raise httpx.RequestError("Max retries exceeded")  # noqa: TRY003


@tool(requires_auth=OAuth2(id="arcade-okta"))
async def fetch_app_authenticator_config(
    context: ToolContext,
    filter_by_oauth_client_id: Annotated[
        str, "Filter the app authenticator configurations using this OAuth Client ID."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getWellKnownAppAuthenticatorConfiguration'."
]:
    """Retrieves the app authenticator configuration details.

    Use this tool to get information about an app authenticator's settings, supported methods, and other relevant details."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/.well-known/app-authenticator-configuration",
        method="GET",
        params=remove_none_values({"oauthClientId": filter_by_oauth_client_id}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta"))
async def get_apple_app_site_association(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getAppleAppSiteAssociationWellKnownURI'."
]:
    """Retrieve the apple-app-site-association well-known URI.

    This tool retrieves the content of the `apple-app-site-association` well-known URI, including Okta's `authsrv` content for seamless Okta Verify integration."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/.well-known/apple-app-site-association",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta"))
async def retrieve_asset_links(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAssetLinksWellKnownURI'."]:
    """Retrieve the content of the assetlinks.json URI.

    Use this tool to obtain the content of the assetlinks.json well-known URI, often used for app-link verification and asset relationship management."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/.well-known/assetlinks.json",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta"))
async def get_organization_metadata(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getWellknownOrgMetadata'."]:
    """Retrieve organization metadata from Okta.

    Call this tool to get the organization metadata from Okta, including the organization ID, configured custom domains, and authentication pipeline details."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/.well-known/okta-organization",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta"))
async def get_okta_ssf_metadata(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getWellknownSsfMetadata'."]:
    """Retrieve SSF transmitter configuration metadata from Okta.

    Use this tool to get detailed SSF transmitter configuration metadata. It provides all supported endpoints and key information regarding Okta org properties such as delivery methods, issuer, and JWKS URI."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/.well-known/ssf-configuration",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta"))
async def get_webauthn_well_known_uri(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getWebAuthnWellKnownURI'."]:
    """Retrieve the content of the 'webauthn' well-known URI.

    This tool retrieves the content from the '.well-known/webauthn' URI. It is used when needing to access the WebAuthn well-known information for configurations or validations."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/.well-known/webauthn",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.agentPools.read"]))
async def list_agent_pools(
    context: ToolContext,
    maximum_agent_pools: Annotated[
        int | None, "Maximum number of agent pools to be returned per pool type."
    ] = None,
    agent_pool_type: Annotated[
        str | None,
        "Specify the agent type to filter the search. Options are AD, IWA, LDAP, MFA, OPP, RUM, or Radius.",  # noqa: E501
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "An opaque string cursor for pagination, specifying current list position, obtained from the `Link` header.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAgentPools'."]:
    """Lists all agent pools with pagination support.

    Use this tool to retrieve a comprehensive list of agent pools, including support for pagination to manage large datasets."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/agentPools",
        method="GET",
        params=remove_none_values({
            "limitPerPoolType": maximum_agent_pools,
            "poolType": agent_pool_type,
            "after": pagination_cursor,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.agentPools.read"]))
async def list_agent_pool_updates(
    context: ToolContext,
    agent_pool_id: Annotated[str, "ID of the agent pool to retrieve updates for."],
    return_scheduled_or_adhoc: Annotated[
        bool | None,
        "Return only scheduled or ad-hoc updates if true. If false or not provided, returns the full list of updates.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAgentPoolsUpdates'."]:
    """Retrieve all updates for a specific agent pool.

    Use this tool to get a list of all updates related to a specific agent pool in Okta. It provides details on changes or modifications to the agent pool identified by the provided pool ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/agentPools/{poolId}/updates".format(  # noqa: UP032
            poolId=agent_pool_id
        ),
        method="GET",
        params=remove_none_values({"scheduled": return_scheduled_or_adhoc}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.agentPools.read"]))
async def get_agent_pool_update_settings(
    context: ToolContext,
    agent_pool_id: Annotated[
        str, "The unique identifier of the agent pool to retrieve update settings for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAgentPoolsUpdateSettings'."]:
    """Retrieve agent pool update settings information.

    This tool retrieves the current state of the update instance settings for a specific agent pool. It should be called when there's a need to understand or verify the configuration of the update settings for a given pool."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/agentPools/{poolId}/updates/settings".format(  # noqa: UP032
            poolId=agent_pool_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.agentPools.read"]))
async def retrieve_agent_pool_update(
    context: ToolContext,
    agent_pool_id: Annotated[
        str,
        "The ID of the agent pool for which you want to retrieve update details. Provide a valid agent pool ID.",  # noqa: E501
    ],
    update_id: Annotated[
        str, "The identifier for the specific agent pool update to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAgentPoolsUpdateInstance'."]:
    """Retrieve details of a specific agent pool update.

    Use this tool to obtain information about a specific agent pool update using its `updateId`. This is useful for tracking update progress or verifying update configurations."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/agentPools/{poolId}/updates/{updateId}".format(  # noqa: UP032
            poolId=agent_pool_id, updateId=update_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.agentPools.manage"]))
async def delete_agent_pool_update(
    context: ToolContext,
    agent_pool_id: Annotated[str, "ID of the agent pool for which the settings apply."],
    update_id: Annotated[
        str,
        "ID of the update to delete from the agent pool. This must be a valid string identifier.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteAgentPoolsUpdate'."]:
    """Delete a specific update from an agent pool.

    Use this tool to remove a specific update from an agent pool by providing the necessary identifiers. It performs deletion of agent pool updates."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/agentPools/{poolId}/updates/{updateId}".format(  # noqa: UP032
            poolId=agent_pool_id, updateId=update_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.agentPools.manage"]))
async def activate_agent_pool_update(
    context: ToolContext,
    agent_pool_id: Annotated[
        str,
        "ID of the agent pool for which the settings apply to. This is required to specify which pool will have the update activated.",  # noqa: E501
    ],
    update_id: Annotated[
        str,
        "The ID of the update to activate. This is required to initiate the update process for the specified agent pool.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateAgentPoolsUpdate'."]:
    """Activates a scheduled agent pool update.

    Use this tool to activate an update for a specified agent pool that has been scheduled. Call when you need to confirm and commence the update process for agent pools in your system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/agentPools/{poolId}/updates/{updateId}/activate".format(  # noqa: UP032
            poolId=agent_pool_id, updateId=update_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.agentPools.manage"]))
async def deactivate_agent_pool_update(
    context: ToolContext,
    agent_pool_id: Annotated[
        str, "ID of the agent pool for which the deactivation settings apply."
    ],
    update_id: Annotated[str, "The unique ID of the scheduled update to deactivate."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivateAgentPoolsUpdate'."]:
    """Deactivate a scheduled agent pool update.

    Use this tool to deactivate a scheduled update for a specific agent pool in Okta. It should be called when you need to stop an update that is already scheduled but not yet executed."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/agentPools/{poolId}/updates/{updateId}/deactivate".format(  # noqa: UP032
            poolId=agent_pool_id, updateId=update_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.agentPools.manage"]))
async def pause_agent_pools_update(
    context: ToolContext,
    agent_pool_id: Annotated[
        str,
        "ID of the agent pool for which the update settings apply. Required to specify which pool's update is being paused.",  # noqa: E501
    ],
    update_id: Annotated[
        str,
        "ID of the update to be paused. This is required to identify which specific update to stop within the agent pool.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'pauseAgentPoolsUpdate'."]:
    """Pause a running or queued agent pool update.

    This tool pauses an ongoing or scheduled update for an agent pool, identified by poolId and updateId. Use it to temporarily halt updates you don't want to proceed immediately."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/agentPools/{poolId}/updates/{updateId}/pause".format(  # noqa: UP032
            poolId=agent_pool_id, updateId=update_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.agentPools.manage"]))
async def resume_agent_pool_update(
    context: ToolContext,
    agent_pool_id: Annotated[
        str,
        "The ID of the agent pool to resume update for. Required to specify which pool's update is being resumed.",  # noqa: E501
    ],
    update_id: Annotated[
        str, "The unique ID of the update to be resumed for the specified agent pool."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'resumeAgentPoolsUpdate'."]:
    """Resume a running or queued agent pool update.

    Use this tool to resume an update for a specific agent pool that is either running or queued. This is useful when updates need to be restarted or continued after a pause."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/agentPools/{poolId}/updates/{updateId}/resume".format(  # noqa: UP032
            poolId=agent_pool_id, updateId=update_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.agentPools.manage"]))
async def retry_agent_pool_update(
    context: ToolContext,
    agent_pool_id: Annotated[str, "The ID of the agent pool to retry the update for."],
    update_id: Annotated[str, "The unique ID of the agent pool update to retry."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'retryAgentPoolsUpdate'."]:
    """Retry an agent pool update after failure or interruption.

    Use this tool to retry an agent pool update in Okta if the initial update fails or communication is interrupted during an auto-update process."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/agentPools/{poolId}/updates/{updateId}/retry".format(  # noqa: UP032
            poolId=agent_pool_id, updateId=update_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.agentPools.manage"]))
async def stop_agent_pool_update(
    context: ToolContext,
    agent_pool_id: Annotated[str, "ID of the agent pool to stop the update for."],
    update_id: Annotated[str, "ID of the specific update to be stopped in the agent pool."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'stopAgentPoolsUpdate'."]:
    """Stops an agent pool update process.

    Use this tool to stop an ongoing update for a specific agent pool in Okta. Ideal for halting updates when unexpected issues arise."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/agentPools/{poolId}/updates/{updateId}/stop".format(  # noqa: UP032
            poolId=agent_pool_id, updateId=update_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apiTokens.read"]))
async def list_active_api_tokens(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listApiTokens'."]:
    """Lists metadata of all active API tokens.

    Use this tool to retrieve metadata of all active API tokens in the system."""
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/api-tokens",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apiTokens.read"]))
async def retrieve_api_token_metadata(
    context: ToolContext,
    api_token_id: Annotated[
        str, "The unique identifier for the API token to retrieve its metadata."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getApiToken'."]:
    """Retrieve metadata for a specific API token.

    This tool retrieves metadata for an active API token using the `apiTokenId`. It should be called when there's a need to understand the details or status of a specific API token."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/api-tokens/{apiTokenId}".format(  # noqa: UP032
            apiTokenId=api_token_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apiTokens.manage"]))
async def revoke_api_token(
    context: ToolContext,
    api_token_id: Annotated[str, "The unique ID of the API token to revoke."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'revokeApiToken'."]:
    """Revoke an API token using its ID.

    Use this tool to revoke an API token by providing its unique ID. It will disable the specified token, preventing any further access or operations using that token."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/api-tokens/{apiTokenId}".format(  # noqa: UP032
            apiTokenId=api_token_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def list_organization_applications(
    context: ToolContext,
    search_query: Annotated[
        str | None,
        "Search for applications with names or labels starting with this value using the `startsWith` operation.",  # noqa: E501
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "Opaque string to fetch the next page of results. Obtained from the 'next' link.",
    ] = None,
    results_per_page: Annotated[
        int | None, "Specifies the number of results per page for pagination."
    ] = None,
    filter_expression_for_applications: Annotated[
        str | None,
        "Filters applications using `status`, `user.id`, `group.id`, `credentials.signing.kid`, or `name` with `eq` operator.",  # noqa: E501
    ] = None,
    expand_user_resources: Annotated[
        str | None,
        'Embeds more resources in the response, supports `expand=user/{userId}`. Requires the `user.id eq "{userId}"` filter.',  # noqa: E501
    ] = None,
    use_query_optimization: Annotated[
        bool | None,
        "Set to true to use query optimization, returning a subset of app instance properties.",
    ] = None,
    include_non_deleted_apps: Annotated[
        bool | None, "Include non-active but not deleted apps in the results."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listApplications'."]:
    """Lists all applications in the organization with filters.

    Use this tool to retrieve a list of all applications within the organization. Supports filtering and pagination to manage large sets of applications efficiently."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps",
        method="GET",
        params=remove_none_values({
            "q": search_query,
            "after": pagination_cursor,
            "useOptimization": use_query_optimization,
            "limit": results_per_page,
            "filter": filter_expression_for_applications,
            "expand": expand_user_resources,
            "includeNonDeleted": include_non_deleted_apps,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def retrieve_okta_application(
    context: ToolContext,
    application_id: Annotated[str, "The unique identifier of the application in Okta."],
    expand_user_info: Annotated[
        str | None,
        "Specifies if the details of a particular Application User should be returned in the response. Use the format `user/{userId}` to expand.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getApplication'."]:
    """Retrieves application details from Okta by ID.

    Use this tool to get detailed information about a specific application in your Okta organization by providing the application's ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}".format(appId=application_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"expand": expand_user_info}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def delete_inactive_application(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The unique identifier for the application to be deleted. This ID is required to specify which inactive application should be removed from Okta.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteApplication'."]:
    """Delete an inactive application from the system.

    This tool deletes an inactive application by providing its application ID. Call this tool when you need to permanently remove an inactive application from the Okta system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}".format(appId=application_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def get_default_provisioning_connection(
    context: ToolContext,
    application_id: Annotated[
        str,
        "Provide the unique Application ID to retrieve its default provisioning connection details.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'getDefaultProvisioningConnectionForApplication'.",
]:
    """Retrieve the default provisioning connection for an app.

    Call this tool to get details about the default provisioning connection associated with a specific application using its app ID. This is useful for understanding how an application is configured to provision resources or users."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/connections/default".format(  # noqa: UP032
            appId=application_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def update_default_provisioning_connection(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The unique identifier for the specific application whose provisioning connection is to be updated.",  # noqa: E501
    ],
    request_body_data: Annotated[
        dict[str, str],
        "JSON object with data needed to update the provisioning connection. Ensure it includes necessary fields for the app.",  # noqa: E501
    ],
    activate_provisioning_connection: Annotated[
        bool | None,
        "Set to true to activate the provisioning connection; false to keep it inactive.",
    ] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'updateDefaultProvisioningConnectionForApplication'.",
]:
    """Updates the default provisioning connection for an app.

    Use this tool to update the default provisioning connection for a specific application in Okta. This is typically called when changes to app provisioning configurations are needed."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/connections/default".format(  # noqa: UP032
            appId=application_id
        ),
        method="POST",
        params=remove_none_values({"activate": activate_provisioning_connection}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({"requestBody": request_body_data}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def get_provisioning_connection_jwks(
    context: ToolContext,
    application_id: Annotated[
        str, "The unique identifier of the application to retrieve its JWKS."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getUserProvisioningConnectionJWKS'."
]:
    """Retrieve JWKS for an app's default provisioning connection.

    Fetches the JSON Web Key Set (JWKS) for the default provisioning connection of a specified app. This is useful for OAuth 2.0 applications needing the `jwk_uri` property for integration in the target organization."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/connections/default/jwks".format(  # noqa: UP032
            appId=application_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def activate_default_provisioning_connection(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The unique identifier for the application to activate its default provisioning connection.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'activateDefaultProvisioningConnectionForApplication'.",
]:
    """Activate the default provisioning connection for an app.

    This tool activates the default provisioning connection for a specified application. It should be called when you need to enable the provisioning connection of an app managed in Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/connections/default/lifecycle/activate".format(  # noqa: UP032
            appId=application_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def deactivate_app_provisioning_connection(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The unique identifier for the application whose provisioning connection you want to deactivate.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'deactivateDefaultProvisioningConnectionForApplication'.",
]:
    """Deactivate an application's default provisioning connection.

    Use this tool to deactivate the default provisioning connection for a specific application. It is useful when you need to disable automatic provisioning for app management."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/connections/default/lifecycle/deactivate".format(  # noqa: UP032
            appId=application_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def list_application_csrs(
    context: ToolContext,
    application_id: Annotated[str, "The unique identifier for the application to retrieve CSRs."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listCsrsForApplication'."]:
    """Retrieve all Certificate Signing Requests for a specific application.

    Use this tool to obtain a list of all Certificate Signing Requests (CSRs) associated with a specific application. This is helpful for managing or auditing CSRs within the Okta platform."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/credentials/csrs".format(  # noqa: UP032
            appId=application_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def retrieve_csr_for_app(
    context: ToolContext,
    application_id: Annotated[
        str, "The unique identifier of the application for which to retrieve the CSR."
    ],
    certificate_signing_request_id: Annotated[
        str, "The unique identifier of the Certificate Signing Request (CSR) to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCsrForApplication'."]:
    """Retrieve a CSR for a specific application.

    Use this tool to obtain a Certificate Signing Request (CSR) for a given application, identified by the CSR ID. The CSR can be returned as a Base64-encoded string or a JSON object, depending on the requested media type."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/credentials/csrs/{csrId}".format(  # noqa: UP032
            appId=application_id, csrId=certificate_signing_request_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def revoke_csr_from_application(
    context: ToolContext,
    application_id: Annotated[
        str, "The ID of the application from which to revoke the CSR and delete the key pair."
    ],
    csr_id: Annotated[str, "The unique ID of the Certificate Signing Request to revoke."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'revokeCsrFromApplication'."]:
    """Revoke a CSR and delete its key pair from an app.

    Use this tool to revoke a Certificate Signing Request and delete the associated key pair from a specified application. This is useful for managing certificate credentials within applications."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/credentials/csrs/{csrId}".format(  # noqa: UP032
            appId=application_id, csrId=csr_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def publish_certificate(
    context: ToolContext,
    application_id: Annotated[
        str, "Unique identifier for the application to which the CSR belongs."
    ],
    csr_id: Annotated[
        str, "The ID of the Certificate Signing Request (CSR) to publish for the application."
    ],
    certificate_content: Annotated[
        str, "The signed X.509 certificate content to be published for the CSR."
    ],
    certificate_data: Annotated[
        str, "The signed X.509 certificate content in PEM format to be published with the CSR."
    ],
    signed_certificate: Annotated[
        str, "The signed X.509 certificate content to be published for the application CSR."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'publishCsrFromApplication'."]:
    """Publish a signed certificate for an application's CSR.

    Use this tool to publish a Certificate Signing Request (CSR) for an application by attaching a signed X.509 certificate. This completes the CSR's lifecycle, making it inaccessible afterwards."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/credentials/csrs/{csrId}/lifecycle/publish".format(  # noqa: UP032
            appId=application_id, csrId=csr_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({"requestBody": signed_certificate}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def list_oauth_jwks(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The ID of the OAuth 2.0 client application for which to list JSON Web Keys. This is required to identify the specific application's keys.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listJwk'."]:
    """Retrieve JSON Web Keys for an OAuth 2.0 client app.

    Use this tool to fetch all JSON Web Keys associated with a specific OAuth 2.0 client application. This is essential for managing or inspecting the keys used in the app's OAuth security setup."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/credentials/jwks".format(  # noqa: UP032
            appId=application_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def retrieve_oauth_client_jwk(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The unique ID of the application. Used to identify which application's OAuth 2.0 Client JSON Web Key to retrieve.",  # noqa: E501
    ],
    key_id: Annotated[
        str, "Unique ID of the Custom Authorization Server JSON Web Key for OAuth 2.0 clients."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getJwk'."]:
    """Retrieve an OAuth 2.0 Client JSON Web Key by keyId.

    Use this tool to obtain the JSON Web Key associated with a specific OAuth 2.0 client using the provided keyId. Useful for verifying signatures and encrypting/un-decrypting data."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/credentials/jwks/{keyId}".format(  # noqa: UP032
            appId=application_id, keyId=key_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def delete_inactive_oauth2_client_jwk(
    context: ToolContext,
    application_id: Annotated[
        str, "The ID of the application for which the OAuth 2.0 client JWK should be deleted."
    ],
    oauth2_client_jwk_id: Annotated[
        str, "Unique `id` of the Custom Authorization Server JSON Web Key to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deletejwk'."]:
    """Delete an inactive OAuth 2.0 Client JSON Web Key.

    Use this tool to delete an inactive JSON Web Key (JWK) for an OAuth 2.0 client by specifying the key ID. It ensures that only inactive keys can be removed."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/credentials/jwks/{keyId}".format(  # noqa: UP032
            appId=application_id, keyId=oauth2_client_jwk_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def activate_oauth_client_key(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The unique identifier for the application. It specifies which application's JSON Web Key to activate.",  # noqa: E501
    ],
    key_id: Annotated[
        str, "Unique ID of the Custom Authorization Server JSON Web Key to activate."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateOAuth2ClientJsonWebKey'."]:
    """Activate an OAuth 2.0 Client JSON Web Key using its key ID.

    Use this tool to activate an OAuth 2.0 Client JSON Web Key for a specific application. Note: Only one encryption key can be active at a time. Activating a new key will deactivate the current active key."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/credentials/jwks/{keyId}/lifecycle/activate".format(  # noqa: UP032
            appId=application_id, keyId=key_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def deactivate_oauth2_client_key(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The ID of the application for which the OAuth 2.0 Client JSON Web Key should be deactivated.",  # noqa: E501
    ],
    key_id: Annotated[
        str, "Unique ID of the Custom Authorization Server JSON Web Key for deactivation."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deactivateOAuth2ClientJsonWebKey'."
]:
    """Deactivate an OAuth 2.0 Client JSON Web Key by key ID.

    Use this tool to deactivate a specific OAuth 2.0 Client JSON Web Key using its key ID. Note: Only signing keys can be deactivated, and active encryption keys cannot be deactivated if ID token encryption is enabled."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/credentials/jwks/{keyId}/lifecycle/deactivate".format(  # noqa: UP032
            appId=application_id, keyId=key_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def list_app_keys(
    context: ToolContext,
    application_id: Annotated[
        str, "The unique identifier for the application. Required to retrieve key credentials."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listApplicationKeys'."]:
    """Retrieve all key credentials for a specific app.

    Call this tool to obtain all key credentials associated with a specific application in Okta. Useful for managing or auditing application key data."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/credentials/keys".format(  # noqa: UP032
            appId=application_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def generate_app_key_certificate(
    context: ToolContext,
    certificate_validity_years: Annotated[
        int, "The number of years until the X.509 certificate for the application key expires."
    ],
    application_id: Annotated[
        str,
        "The unique identifier of the application for which the certificate is being generated.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'generateApplicationKey'."]:
    """Generate a new X.509 certificate for an app key.

    This tool generates a new X.509 certificate for an application's key credential. Use it to update an application's signing credentials with the newly generated key."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/credentials/keys/generate".format(  # noqa: UP032
            appId=application_id
        ),
        method="POST",
        params=remove_none_values({"validityYears": certificate_validity_years}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def retrieve_application_key(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The unique identifier for the application in Okta. Required to retrieve a key credential.",
    ],
    key_credential_id: Annotated[
        str,
        "The unique identifier of the Key Credential for the application. Used to specify which key to retrieve.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getApplicationKey'."]:
    """Retrieve a specific application key credential.

    Use this tool to retrieve a specific application key credential by its key ID ('kid') for a particular application in Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/credentials/keys/{keyId}".format(  # noqa: UP032
            appId=application_id, keyId=key_credential_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def clone_okta_application_key(
    context: ToolContext,
    target_application_key: Annotated[
        str, "Unique key of the target application for cloning the X.509 certificate."
    ],
    source_application_id: Annotated[
        str, "The ID of the source application from which the X.509 certificate will be cloned."
    ],
    key_credential_id: Annotated[str, "ID of the Key Credential for the application to clone."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'cloneApplicationKey'."]:
    """Clone X.509 certificate between Okta applications.

    This tool clones an X.509 certificate from a source application to a target application within Okta. It should be called when you need to share application key credentials across different applications. Note that sharing certificates is not a recommended security practice."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/credentials/keys/{keyId}/clone".format(  # noqa: UP032
            appId=source_application_id, keyId=key_credential_id
        ),
        method="POST",
        params=remove_none_values({"targetAid": target_application_key}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def list_oauth2_client_secrets(
    context: ToolContext,
    application_id: Annotated[
        str, "The ID of the OAuth 2.0 client application for which to list client secrets."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listOAuth2ClientSecrets'."]:
    """List all client secrets for an OAuth 2.0 client app.

    Use this tool to retrieve all client secrets associated with a specific OAuth 2.0 client application. It should be called when you need to access or manage the secrets for an app."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/credentials/secrets".format(  # noqa: UP032
            appId=application_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def retrieve_oauth2_client_secret(
    context: ToolContext,
    application_id: Annotated[
        str, "The unique identifier for the application to retrieve the client secret for."
    ],
    oauth_client_secret_id: Annotated[
        str, "The unique identifier for the OAuth 2.0 client secret you want to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOAuth2ClientSecret'."]:
    """Retrieve an OAuth 2.0 client secret by secret ID.

    This tool is used to retrieve the details of an OAuth 2.0 client secret using its secret ID and app ID. It should be called when you need information about a specific OAuth client secret for an application."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/credentials/secrets/{secretId}".format(  # noqa: UP032
            appId=application_id, secretId=oauth_client_secret_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def delete_oauth_client_secret(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The ID of the application for which the OAuth 2.0 client secret will be deleted. Must be a valid string.",  # noqa: E501
    ],
    oauth_client_secret_id: Annotated[
        str,
        "The unique ID of the OAuth 2.0 client secret to be deleted. Ensure the secret is inactive before deletion.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteOAuth2ClientSecret'."]:
    """Delete an inactive OAuth 2.0 client secret.

    Use this tool to delete an inactive OAuth 2.0 client secret by specifying the secret ID. Call this when you need to remove credentials that are no longer in use."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/credentials/secrets/{secretId}".format(  # noqa: UP032
            appId=application_id, secretId=oauth_client_secret_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def activate_oauth2_client_secret(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The unique identifier for the application whose OAuth 2.0 Client Secret you want to activate.",  # noqa: E501
    ],
    oauth2_client_secret_id: Annotated[
        str, "The unique identifier for the OAuth 2.0 Client Secret to be activated."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateOAuth2ClientSecret'."]:
    """Activates an OAuth 2.0 Client Secret for an app.

    Use this tool to activate a specific OAuth 2.0 Client Secret using the `secretId` for a designated application."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/credentials/secrets/{secretId}/lifecycle/activate".format(  # noqa: UP032
            appId=application_id, secretId=oauth2_client_secret_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def deactivate_oauth2_client_secret(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The ID of the application for which the OAuth 2.0 client secret should be deactivated.",
    ],
    oauth2_client_secret_id: Annotated[
        str, "Unique identifier for the OAuth 2.0 client secret to deactivate."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivateOAuth2ClientSecret'."]:
    """Deactivate an OAuth 2.0 client secret for a specific app.

    This tool deactivates an OAuth 2.0 client secret specified by `secretId` for a given app (`appId`). It cannot deactivate a secret if it is the only secret of the client."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/credentials/secrets/{secretId}/lifecycle/deactivate".format(  # noqa: UP032
            appId=application_id, secretId=oauth2_client_secret_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def get_cross_app_access_connections(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The unique identifier of the application for which Cross App Access connections are retrieved.",  # noqa: E501
    ],
    pagination_cursor: Annotated[
        str | None,
        "Specifies the pagination cursor for retrieving the next page of connection results.",
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Number of results per page: -1 for all results, 0 for empty, or a positive integer for specific count.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAllCrossAppAccessConnections'."]:
    """Retrieve Cross App Access connections for a specified app.

    Use this tool to obtain information about inbound and outbound Cross App Access connections linked to a specific application. It provides the necessary details about the connections associated with the app."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/cwo/connections".format(  # noqa: UP032
            appId=application_id
        ),
        method="GET",
        params=remove_none_values({"after": pagination_cursor, "limit": results_per_page}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def retrieve_cross_app_access_connection(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The unique ID of the application for which to retrieve the cross app access connection.",
    ],
    connection_id: Annotated[
        str, "The unique identifier for the Cross App Access connection you want to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCrossAppAccessConnection'."]:
    """Retrieve details of a Cross App Access connection by ID.

    Use this tool to fetch information about a specific Cross App Access connection using the app and connection IDs."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/cwo/connections/{connectionId}".format(  # noqa: UP032
            appId=application_id, connectionId=connection_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def delete_cross_app_access_connection(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The ID of the application for which the Cross App Access connection needs to be deleted.",
    ],
    connection_id: Annotated[
        str,
        "The ID of the Cross App Access connection to delete. This ID is required for identifying which connection to remove.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteCrossAppAccessConnection'."]:
    """Deletes a specified Cross App Access connection.

    Use this tool to delete a Cross App Access connection for a specified app and connection ID within Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/cwo/connections/{connectionId}".format(  # noqa: UP032
            appId=application_id, connectionId=connection_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def list_application_features(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The unique identifier for the application whose features are to be listed. Required for retrieving feature details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listFeaturesForApplication'."]:
    """Retrieve all features for a specific app.

    Use this tool to list all features associated with a specific application. Note that it will return an error if provisioning isn't enabled for the app."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/features".format(appId=application_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def retrieve_app_feature(
    context: ToolContext,
    application_id: Annotated[
        str, "The unique ID of the application for which the feature should be retrieved."
    ],
    feature_name: Annotated[
        str,
        "Specify the feature name to retrieve. Options are 'USER_PROVISIONING' or 'INBOUND_PROVISIONING'.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getFeatureForApplication'."]:
    """Retrieve a feature for a specific application.

    Use this tool to get detailed information about a specific feature in an application by providing the app ID and feature name. It helps in understanding the feature's status and properties for a given app."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/features/{featureName}".format(  # noqa: UP032
            appId=application_id, featureName=feature_name
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def list_federated_claims(
    context: ToolContext,
    application_id: Annotated[str, "The ID of the application for which to list federated claims."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listFederatedClaims'."]:
    """Retrieve all federated claims for a specified app.

    This tool retrieves all federated claims associated with a specific app. It should be called when you need to list or review federated claims for application management or auditing purposes."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/federated-claims".format(  # noqa: UP032
            appId=application_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def retrieve_federated_claim(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The ID of the application for which the federated claim is retrieved. Required to specify which application the claim is associated with.",  # noqa: E501
    ],
    federated_claim_id: Annotated[
        str, "The unique ID of the federated claim to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getFederatedClaim'."]:
    """Retrieve a federated claim by its ID.

    Use this tool to retrieve details of a federated claim by providing the specific claim ID and application ID. This is useful for obtaining information about a particular federated identity claim in an Okta application."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/federated-claims/{claimId}".format(  # noqa: UP032
            appId=application_id, claimId=federated_claim_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def delete_federated_claim(
    context: ToolContext,
    application_id: Annotated[
        str, "The ID of the application associated with the federated claim to be deleted."
    ],
    federated_claim_id: Annotated[str, "The unique ID of the federated claim to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteFederatedClaim'."]:
    """Deletes a specific federated claim by its ID.

    This tool removes a federated claim given the specific claim ID. It should be used when there's a need to delete a federated claim associated with an application in Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/federated-claims/{claimId}".format(  # noqa: UP032
            appId=application_id, claimId=federated_claim_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.appGrants.read"]))
async def list_app_scope_consent_grants(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The unique identifier of the application for which you want to list scope consent grants.",
    ],
    include_scope_details: Annotated[
        str | None,
        "Set to `scope` to include scope details in the `_embedded` property. This is optional.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listScopeConsentGrants'."]:
    """Lists all scope consent grants for a specific app.

    Use this tool to retrieve all scope consent grants associated with a specific application in Okta. It should be called when you need to understand which grants have been issued for an app."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/grants".format(appId=application_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"expand": include_scope_details}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.appGrants.read"]))
async def retrieve_scope_consent_grant(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The unique identifier for the application. Used to specify which application's scope consent grant to retrieve.",  # noqa: E501
    ],
    grant_id: Annotated[
        str,
        "The unique identifier for the grant to retrieve details for the specific scope consent grant.",  # noqa: E501
    ],
    include_scope_details: Annotated[
        str | None, "Set to 'scope' to include scope details in the `_embedded` property."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getScopeConsentGrant'."]:
    """Retrieve a single scope consent grant for an app.

    Use this tool to get details of a specific scope consent grant object for a given application, using app and grant identifiers."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/grants/{grantId}".format(  # noqa: UP032
            appId=application_id, grantId=grant_id
        ),
        method="GET",
        params=remove_none_values({"expand": include_scope_details}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.appGrants.manage"]))
async def revoke_app_scope_consent(
    context: ToolContext,
    application_id: Annotated[
        str, "The unique identifier for the application whose scope consent is being revoked."
    ],
    grant_id: Annotated[
        str,
        "The ID of the grant to be revoked. This identifies the specific permission grant associated with the app.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'revokeScopeConsentGrant'."]:
    """Revoke an app's permission for a specific scope grant.

    Use this tool to revoke the permission of an application to use a specific scope. This is useful for managing app permissions and ensuring security by withdrawing unnecessary or outdated consents."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/grants/{grantId}".format(  # noqa: UP032
            appId=application_id, grantId=grant_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.groups.read", "okta.apps.read"]))
async def list_group_push_mappings(
    context: ToolContext,
    application_id: Annotated[str, "The ID of the application to filter group push mappings for."],
    pagination_cursor: Annotated[
        str | None,
        "Specifies the pagination cursor for retrieving the next page of group push mappings.",
    ] = None,
    results_limit: Annotated[
        int | None,
        "Specifies the number of group push mappings to return in the response. Useful for pagination to limit the number of items retrieved per request.",  # noqa: E501
    ] = None,
    filter_by_last_updated_date: Annotated[
        str | None,
        "Filters mappings updated on or after the specified date and time in UTC. Use `YYYY-MM-DDTHH:mm:ssZ` format.",  # noqa: E501
    ] = None,
    source_group_id: Annotated[
        str | None,
        "Filters group push mappings by source group ID. When omitted, returns all mappings.",
    ] = None,
    filter_by_status: Annotated[
        str | None,
        "Filters group push mappings by status. Valid options include 'ACTIVE', 'ERROR', 'INACTIVE'. If omitted, all statuses are included.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listGroupPushMappings'."]:
    """Retrieve a list of group push mappings for a specific app.

    This tool is used to list all group push mappings for a specific app, identified by the app ID, with support for pagination if there are many mappings."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/group-push/mappings".format(  # noqa: UP032
            appId=application_id
        ),
        method="GET",
        params=remove_none_values({
            "after": pagination_cursor,
            "limit": results_limit,
            "lastUpdated": filter_by_last_updated_date,
            "sourceGroupId": source_group_id,
            "status": filter_by_status,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.groups.read", "okta.apps.read"]))
async def retrieve_group_push_mapping(
    context: ToolContext,
    application_id: Annotated[
        str, "The ID of the application. This is required to retrieve the group push mapping."
    ],
    group_push_mapping_id: Annotated[str, "The ID of the group push mapping to retrieve."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getGroupPushMapping'."]:
    """Retrieve a group push mapping by ID.

    Use this tool to get details of a specific group push mapping by providing the application and mapping IDs."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/group-push/mappings/{mappingId}".format(  # noqa: UP032
            appId=application_id, mappingId=group_push_mapping_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.groups.manage", "okta.apps.manage"]))
async def delete_inactive_group_push_mapping(
    context: ToolContext,
    application_id: Annotated[
        str, "The unique identifier for the application associated with the group push mapping."
    ],
    group_push_mapping_id: Annotated[
        str, "ID of the group push mapping to be deleted. Must be in an 'INACTIVE' state."
    ],
    delete_target_group: Annotated[
        bool,
        "Set to `true` to delete the target group; `false` to retain it. Controls whether the target group is also deleted.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteGroupPushMapping'."]:
    """Delete an inactive group push mapping.

    Use this tool to delete a specific group push mapping that is in an 'INACTIVE' state. This is useful for managing and maintaining group configurations within an application."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/group-push/mappings/{mappingId}".format(  # noqa: UP032
            appId=application_id, mappingId=group_push_mapping_id
        ),
        method="DELETE",
        params=remove_none_values({"deleteTargetGroup": delete_target_group}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def list_app_group_assignments(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The unique identifier for the application. Use this to specify which application's group assignments to list.",  # noqa: E501
    ],
    group_name_starts_with_filter: Annotated[
        str | None,
        "A filter to match group names that start with the specified string for assigned groups.",
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "Specifies the pagination cursor for the next page of results. Use the value from the 'next' link in the Link header.",  # noqa: E501
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Specifies the number of objects to return per page. Supports pagination by using the `next` link for additional pages.",  # noqa: E501
    ] = None,
    return_assigned_group_or_metadata: Annotated[
        str | None,
        "Optional query to return the assigned group or assignment metadata in the `_embedded` property.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listApplicationGroupAssignments'."]:
    """List all group assignments for a specific application.

    Use this tool to retrieve a list of app group assignments for a given application by specifying the app ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/groups".format(appId=application_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "q": group_name_starts_with_filter,
            "after": pagination_cursor,
            "limit": results_per_page,
            "expand": return_assigned_group_or_metadata,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def retrieve_app_group_assignment(
    context: ToolContext,
    application_id: Annotated[
        str, "The unique identifier of the application to retrieve group assignment details."
    ],
    group_id: Annotated[str, "The unique identifier for the group to retrieve assignment details."],
    include_assigned_group_details: Annotated[
        str | None,
        "Specifies whether to include assigned group or assignment metadata details in the `_embedded` property.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getApplicationGroupAssignment'."]:
    """Retrieve details of an app group assignment from Okta.

    Use this tool to get information about a specific application group assignment within Okta. It requires the application ID and group ID to retrieve the relevant details."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/groups/{groupId}".format(  # noqa: UP032
            appId=application_id, groupId=group_id
        ),
        method="GET",
        params=remove_none_values({"expand": include_assigned_group_details}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def unassign_group_from_app(
    context: ToolContext,
    application_id: Annotated[
        str, "The unique identifier of the application to unassign the group from."
    ],
    group_id: Annotated[
        str, "The unique identifier for the group to be unassigned from the application."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'unassignApplicationFromGroup'."]:
    """Unassign a group from a specific application.

    Use this tool to remove the association between a group and an application in Okta. It should be called when you need to revoke a group's access to a specific app."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/groups/{groupId}".format(  # noqa: UP032
            appId=application_id, groupId=group_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def activate_inactive_application(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The unique identifier of the application to be activated. This ID is required to specify which inactive application should be activated in the Okta system.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateApplication'."]:
    """Activate an inactive application in Okta.

    This tool activates an inactive application in the Okta system. It should be used when you need to enable an application that was previously inactive, using the application's ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/lifecycle/activate".format(  # noqa: UP032
            appId=application_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def deactivate_application(
    context: ToolContext,
    application_id: Annotated[str, "The unique identifier for the application to be deactivated."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivateApplication'."]:
    """Deactivate an active application in Okta.

    This tool deactivates an active application in Okta, triggering a reconciliation process that removes all user assignments to the app. Useful for managing application lifecycle and user access control."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/lifecycle/deactivate".format(  # noqa: UP032
            appId=application_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def assign_app_to_policy(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The unique identifier for the application to be assigned to the authentication policy.",
    ],
    policy_id: Annotated[
        str,
        "The ID of the authentication policy to assign the application to. This replaces any previous policy assignments.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'assignApplicationPolicy'."]:
    """Assign an app to a specified authentication policy.

    Use this tool to assign an application to a specific authentication policy in Okta, replacing any previous assignments. Note that if authentication policies are being merged, this operation may be temporarily unavailable."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/policies/{policyId}".format(  # noqa: UP032
            appId=application_id, policyId=policy_id
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def preview_saml_metadata(
    context: ToolContext,
    key_identifier: Annotated[str, "The Key Identifier (kid) used in the SAML metadata request."],
    application_id: Annotated[
        str,
        "The ID of the application for which to preview the SSO SAML metadata. This is required to specify which application's metadata to retrieve.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'previewSAMLmetadataForApplication'."
]:
    """Preview SSO SAML metadata for a specific application.

    This tool retrieves the SSO SAML metadata for a given application using its appId. It should be called when you need to preview or validate the SAML settings for an application."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/sso/saml/metadata".format(  # noqa: UP032
            appId=application_id
        ),
        method="GET",
        params=remove_none_values({"kid": key_identifier}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def list_refresh_tokens_for_app(
    context: ToolContext,
    application_id: Annotated[
        str, "The unique identifier for the application to retrieve refresh tokens."
    ],
    include_scope_details: Annotated[
        str | None, "Set to 'scope' to include scope details in the response (_embedded property)."
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "Pagination cursor for retrieving the next page of results. Use the opaque value from the next link.",  # noqa: E501
    ] = None,
    max_tokens_to_return: Annotated[
        int | None, "Sets the maximum number of refresh tokens to retrieve for the application."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listOAuth2TokensForApplication'."]:
    """Retrieve all refresh tokens for a specific app in Okta.

    Use this tool to get a list of all OAuth2 refresh tokens associated with a specified application in Okta. Useful for managing and auditing app tokens."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/tokens".format(appId=application_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "expand": include_scope_details,
            "after": pagination_cursor,
            "limit": max_tokens_to_return,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def revoke_oauth2_tokens_app(
    context: ToolContext,
    application_id: Annotated[
        str, "The unique identifier for the application whose OAuth 2.0 tokens are to be revoked."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'revokeOAuth2TokensForApplication'."
]:
    """Revoke all OAuth 2.0 tokens for a specific app.

    Use this tool to revoke all OAuth 2.0 refresh tokens and associated access tokens for a given application. It does not affect access tokens issued without a refresh token."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/tokens".format(appId=application_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def retrieve_oauth2_token(
    context: ToolContext,
    application_id: Annotated[
        str, "The ID of the application for which you wish to retrieve the refresh token."
    ],
    token_id: Annotated[str, "The `id` of the token for which a refresh token is to be retrieved."],
    include_scope_details: Annotated[
        str | None, "Set to 'scope' to return scope details in the `_embedded` property."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOAuth2TokenForApplication'."]:
    """Retrieve a refresh token for a specified application.

    This tool retrieves a refresh token for a specified application using its app ID and token ID. It should be called when there's a need to obtain a new refresh token for app authentication."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/tokens/{tokenId}".format(  # noqa: UP032
            appId=application_id, tokenId=token_id
        ),
        method="GET",
        params=remove_none_values({"expand": include_scope_details}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def revoke_app_oauth2_token(
    context: ToolContext,
    application_id: Annotated[
        str, "The unique identifier for the application whose token is to be revoked."
    ],
    token_id: Annotated[
        str, "The ID of the OAuth2 token to be revoked for the specified application."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'revokeOAuth2TokenForApplication'."]:
    """Revoke a specific OAuth2 token for an application.

    Use this tool to revoke a specific OAuth2 token associated with a particular application. Ideal for cases where you want to invalidate a token, ensuring it can no longer be used for authorization."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/tokens/{tokenId}".format(  # noqa: UP032
            appId=application_id, tokenId=token_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def list_app_users(
    context: ToolContext,
    application_id: Annotated[
        str, "The unique identifier for the application whose assigned users you want to list."
    ],
    pagination_cursor: Annotated[
        str | None,
        "Specifies the pagination cursor for the next page of results. Use this as an opaque value from the next link.",  # noqa: E501
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Specifies the number of user records to return per page. Use this to control pagination effectively. Refer to the pagination guidelines for handling multiple pages.",  # noqa: E501
    ] = None,
    filter_user_profile: Annotated[
        str | None,
        "Filter users based on profile attributes like `userName`, `firstName`, `lastName`, or `email`. Supports `startsWith` filtering.",  # noqa: E501
    ] = None,
    include_user_object: Annotated[
        str | None,
        "Include this parameter to return the corresponding User object in the embedded property. Use 'user' as the value.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listApplicationUsers'."]:
    """Retrieve all users assigned to a specific app.

    Use this tool to list all users who have been assigned to a particular application in Okta. Useful for managing app users and access control."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/users".format(appId=application_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "after": pagination_cursor,
            "limit": results_per_page,
            "q": filter_user_profile,
            "expand": include_user_object,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def retrieve_app_user_assignment(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The unique identifier for the application. Used to specify which application's user assignment to retrieve.",  # noqa: E501
    ],
    okta_user_id: Annotated[
        str,
        "Specify the ID of an existing Okta user to retrieve their assignment information for a specific app.",  # noqa: E501
    ],
    include_user_in_response: Annotated[
        str | None,
        "Optionally include the corresponding user object in the response. Valid value: 'user'.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getApplicationUser'."]:
    """Retrieve a specific user's assignment for an app.

    Use this tool to get information about a user's assignment for a particular application in Okta. It should be called when you need to verify or inspect user access and assignments related to specific applications."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/users/{userId}".format(  # noqa: UP032
            appId=application_id, userId=okta_user_id
        ),
        method="GET",
        params=remove_none_values({"expand": include_user_in_response}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def unassign_user_from_app(
    context: ToolContext,
    application_id: Annotated[
        str,
        "The unique identifier for the application from which the user will be unassigned. This ID is necessary to specify the target application.",  # noqa: E501
    ],
    user_id: Annotated[
        str,
        "The unique identifier for an existing Okta user to be unassigned from the application.",
    ],
    send_deactivation_email: Annotated[
        bool | None,
        "Set to true to send a deactivation email to the administrator upon unassignment.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'unassignUserFromApplication'."]:
    """Unassign a user from a specified application.

    Use this tool to unassign a user from an application when managing directory services like Active Directory or LDAP. Note that this operation is irreversible and may deactivate the user in the target application if provisioning is enabled."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appId}/users/{userId}".format(  # noqa: UP032
            appId=application_id, userId=user_id
        ),
        method="DELETE",
        params=remove_none_values({"sendEmail": send_deactivation_email}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.manage"]))
async def verify_oauth2_connection(
    context: ToolContext,
    application_name: Annotated[
        str,
        "Specifies the application for OAuth 2.0 provisioning. Must be one of: google, office365, slack, zoomus.",  # noqa: E501
    ],
    application_id: Annotated[
        str,
        "The unique identifier for the application. Use this to specify which application's OAuth 2.0 connection is being verified.",  # noqa: E501
    ],
    authorization_code: Annotated[
        str | None,
        "The authorization code received after the OAuth 2.0 consent flow. This code is used to verify the provisioning connection for the application.",  # noqa: E501
    ] = None,
    oauth2_state_parameter: Annotated[
        str | None,
        "A unique string to maintain state between the request and callback in the OAuth consent process.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'verifyProvisioningConnectionForApplication'."
]:
    """Verify OAuth 2.0 provisioning for specific applications.

    This tool verifies the OAuth 2.0-based connection as part of the consent flow for provisioning setup. It is specifically used with Office 365, Google, Zoom, and Slack applications. Use this tool to confirm that the last step of the OAuth provisioning process is complete."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/apps/{appName}/{appId}/oauth2/callback".format(  # noqa: UP032
            appName=application_name, appId=application_id
        ),
        method="POST",
        params=remove_none_values({"code": authorization_code, "state": oauth2_state_parameter}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authenticators.read"]))
async def list_all_authenticators(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAuthenticators'."]:
    """Fetches a list of all authenticators."""
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authenticators",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authenticators.manage"]))
async def create_authenticator(
    context: ToolContext,
    activate_authenticator_on_creation: Annotated[
        bool | None,
        "Set to true to execute the activation lifecycle operation when creating the authenticator.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createAuthenticator'."]:
    """Creates a new authenticator in Okta.

    Call this tool to add a new authenticator to your Okta account. It is useful for setting up new authentication methods or devices."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authenticators",
        method="POST",
        params=remove_none_values({"activate": activate_authenticator_on_creation}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authenticators.read"]))
async def retrieve_okta_authenticator(
    context: ToolContext,
    authenticator_id: Annotated[str, "The unique `id` of the authenticator to retrieve from Okta."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAuthenticator'."]:
    """Fetches an authenticator from Okta using its ID.

    Use this tool to retrieve detailed information about a specific authenticator in your Okta organization by providing its ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authenticators/{authenticatorId}".format(  # noqa: UP032
            authenticatorId=authenticator_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authenticators.manage"]))
async def replace_authenticator_properties(
    context: ToolContext,
    authenticator_id: Annotated[
        str, "The unique identifier of the authenticator whose properties need to be replaced."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'replaceAuthenticator'."]:
    """Replace properties of a specified authenticator.

    Invoke this tool to update the properties of an authenticator using its `authenticatorId`. Use when you need to modify authenticator settings in the Okta system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authenticators/{authenticatorId}".format(  # noqa: UP032
            authenticatorId=authenticator_id
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authenticators.read"]))
async def list_custom_aaguids(
    context: ToolContext,
    authenticator_id: Annotated[
        str, "The unique identifier for the authenticator to list custom AAGUIDs for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAllCustomAAGUIDs'."]:
    """Retrieve all custom AAGUIDs from the organization.

    This tool retrieves all custom Authenticator Attestation Global Unique Identifiers (AAGUIDs) created by an admin in the organization. Use this tool to get a list of custom AAGUIDs associated with a specific authenticator ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authenticators/{authenticatorId}/aaguids".format(  # noqa: UP032
            authenticatorId=authenticator_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authenticators.read"]))
async def retrieve_custom_aaguid(
    context: ToolContext,
    authenticator_id: Annotated[
        str, "The ID of the authenticator for which to retrieve the custom AAGUID."
    ],
    custom_aaguid: Annotated[
        str,
        "The unique identifier for a custom AAGUID. This is used to specify which AAGUID to retrieve.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCustomAAGUID'."]:
    """Retrieve a custom AAGUID for a specific authenticator.

    Call this tool to obtain the custom AAGUID for a given authenticator using its ID. This is useful for authentication processes requiring specific AAGUID details."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authenticators/{authenticatorId}/aaguids/{aaguid}".format(  # noqa: UP032
            authenticatorId=authenticator_id, aaguid=custom_aaguid
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authenticators.manage"]))
async def delete_custom_aaguid(
    context: ToolContext,
    authenticator_id: Annotated[
        str,
        "The unique identifier of the authenticator from which the custom AAGUID will be deleted.",
    ],
    custom_aaguid_id: Annotated[
        str, "The unique ID of the custom AAGUID to be deleted, created by an admin."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteCustomAAGUID'."]:
    """Deletes a custom AAGUID created by an admin.

    This tool deletes a custom AAGUID created by an admin. It should be used when there's a need to remove specific custom AAGUIDs from the Okta system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authenticators/{authenticatorId}/aaguids/{aaguid}".format(  # noqa: UP032
            authenticatorId=authenticator_id, aaguid=custom_aaguid_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authenticators.manage"]))
async def activate_authenticator(
    context: ToolContext,
    authenticator_id: Annotated[
        str,
        "The unique identifier for the authenticator to be activated. It must be a valid string matching the authenticator's ID.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateAuthenticator'."]:
    """Activates an authenticator using its ID.

    Use this tool to activate a specific authenticator by providing its ID. It is useful when an authenticator needs to be enabled for user verification processes."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authenticators/{authenticatorId}/lifecycle/activate".format(  # noqa: UP032
            authenticatorId=authenticator_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authenticators.manage"]))
async def deactivate_authenticator(
    context: ToolContext,
    authenticator_id: Annotated[
        str,
        "The ID of the authenticator to deactivate. Provide the specific `id` to disable the authenticator in Okta.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivateAuthenticator'."]:
    """Deactivate an authenticator by its ID.

    Use this tool to deactivate an authenticator in Okta using the specific authenticator ID. This is useful when an authenticator needs to be temporarily or permanently disabled."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authenticators/{authenticatorId}/lifecycle/deactivate".format(  # noqa: UP032
            authenticatorId=authenticator_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authenticators.read"]))
async def list_authenticator_methods(
    context: ToolContext,
    authenticator_id: Annotated[
        str, "The unique identifier of the authenticator to list its methods."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAuthenticatorMethods'."]:
    """Retrieve all methods of a specified authenticator.

    Call this tool to get a list of all available methods for a specific authenticator using its authenticatorId."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authenticators/{authenticatorId}/methods".format(  # noqa: UP032
            authenticatorId=authenticator_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authenticators.read"]))
async def retrieve_authenticator_method(
    context: ToolContext,
    authenticator_id: Annotated[
        str, "The unique identifier for the authenticator to retrieve the method from."
    ],
    authenticator_method_type: Annotated[
        str,
        "The type of authenticator method. Possible values include: 'cert', 'duo', 'email', 'idp', 'otp', 'password', 'push', 'security_question', 'signed_nonce', 'sms', 'totp', 'voice', 'webauthn', 'tac'.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAuthenticatorMethod'."]:
    """Retrieve a specific authenticator method by ID and type.

    This tool is used to get details of a specific authentication method identified by method type and authenticator ID. It is useful for retrieving information about how users authenticate using specific methods."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authenticators/{authenticatorId}/methods/{methodType}".format(  # noqa: UP032
            authenticatorId=authenticator_id, methodType=authenticator_method_type
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authenticators.manage"]))
async def activate_authenticator_method(
    context: ToolContext,
    authenticator_id: Annotated[
        str, "The unique identifier of the authenticator to activate a method for."
    ],
    authenticator_method_type: Annotated[
        str,
        "Specifies the type of authenticator method to activate. Must be one of: 'cert', 'duo', 'email', 'idp', 'otp', 'password', 'push', 'security_question', 'signed_nonce', 'sms', 'totp', 'voice', 'webauthn', or 'tac'.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateAuthenticatorMethod'."]:
    """Activate a specific method for an authenticator.

    This tool activates a specified method for an authenticator based on the provided `authenticatorId` and `methodType`. Call this tool when you need to enable a particular authentication method in the Okta system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authenticators/{authenticatorId}/methods/{methodType}/lifecycle/activate".format(  # noqa: UP032
            authenticatorId=authenticator_id, methodType=authenticator_method_type
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authenticators.manage"]))
async def deactivate_authenticator_method(
    context: ToolContext,
    authenticator_id: Annotated[str, "The unique ID of the authenticator to be deactivated."],
    authenticator_method_type: Annotated[
        str, "Type of authenticator method to deactivate, such as 'cert', 'duo', 'email', etc."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivateAuthenticatorMethod'."]:
    """Deactivate a specific authenticator method.

    Use this tool to deactivate a particular method for an authenticator by providing the `authenticatorId` and `methodType`."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authenticators/{authenticatorId}/methods/{methodType}/lifecycle/deactivate".format(  # noqa: UP032
            authenticatorId=authenticator_id, methodType=authenticator_method_type
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.read"]))
async def list_custom_authorization_servers(
    context: ToolContext,
    search_query: Annotated[
        str | None,
        "Search for matching values in the `name` and `audiences` of authorization servers.",
    ] = None,
    results_per_page: Annotated[
        int | None,
        "The number of authorization server results to return per page. Maximum value is 200.",
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "Specifies the pagination cursor for the next page of authorization servers. Use the value obtained from the next link of the previous response.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAuthorizationServers'."]:
    """Retrieve all custom authorization servers for the organization.

    Use this tool to get a list of all custom authorization servers configured in the Okta organization. Useful for managing and reviewing authorization server configurations."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers",
        method="GET",
        params=remove_none_values({
            "q": search_query,
            "limit": results_per_page,
            "after": pagination_cursor,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.read"]))
async def retrieve_authorization_server(
    context: ToolContext,
    authorization_server_id: Annotated[
        str,
        "ID of the authorization server to retrieve. This is required to identify which server's details to fetch.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAuthorizationServer'."]:
    """Retrieve details of a specific authorization server.

    Call this tool to get information about a specific authorization server using its ID. Useful for managing or reviewing authorization server configurations."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}".format(  # noqa: UP032
            authServerId=authorization_server_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.manage"]))
async def delete_authorization_server(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "The unique ID of the authorization server to be deleted. This action is irreversible."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteAuthorizationServer'."]:
    """Deletes an authorization server by ID.

    Use this tool to delete a specific authorization server by providing its unique ID. This action is irreversible and should be used when an authorization server is no longer needed."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}".format(  # noqa: UP032
            authServerId=authorization_server_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.read"]))
async def list_authorization_servers_by_trusted_type(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "The unique ID of the Authorization Server to retrieve associated servers for."
    ],
    search_name_or_audience: Annotated[
        str | None,
        "A string to search for the name or audience of associated authorization servers.",
    ] = None,
    page_size: Annotated[int | None, "Specifies the number of results to return per page."] = None,
    pagination_cursor: Annotated[
        str | None, "Specifies the cursor for fetching the next page of authorization servers."
    ] = None,
    search_trusted_authorization_servers: Annotated[
        bool | None,
        "Set to `true` to search for trusted authorization servers, or `false` for untrusted ones.",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'listAssociatedServersByTrustedType'."
]:
    """List associated authorization servers by trusted type.

    Use this tool to retrieve all authorization servers associated with a specific trusted type for a given `authServerId`."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/associatedServers".format(  # noqa: UP032
            authServerId=authorization_server_id
        ),
        method="GET",
        params=remove_none_values({
            "trusted": search_trusted_authorization_servers,
            "q": search_name_or_audience,
            "limit": page_size,
            "after": pagination_cursor,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.manage"]))
async def delete_authorization_server_association(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "The ID of the primary Authorization Server to remove the association from."
    ],
    associated_server_id: Annotated[
        str, "The `id` of the associated Authorization Server to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteAssociatedServer'."]:
    """Deletes an associated Authorization Server for an ID pair.

    This tool deletes an association between a specified Authorization Server and an associated server, using their IDs. Call this tool when you need to remove such an association."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/associatedServers/{associatedServerId}".format(  # noqa: UP032
            authServerId=authorization_server_id, associatedServerId=associated_server_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.read"]))
async def list_oauth2_claims(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "`id` of the Authorization Server to list custom token claims for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listOAuth2Claims'."]:
    """Retrieve all custom token claims for a specified authorization server.

    This tool should be called to list all custom token claims defined for a specified custom authorization server in Okta. It's useful for managing token customization and understanding what claims are currently configured."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/claims".format(  # noqa: UP032
            authServerId=authorization_server_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.read"]))
async def retrieve_oauth2_claim(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "The ID of the Authorization Server whose claim is being retrieved."
    ],
    claim_id: Annotated[str, "The unique identifier of the custom token claim to retrieve."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOAuth2Claim'."]:
    """Retrieve a custom OAuth2 token claim by ID.

    This tool retrieves a specific custom token claim from an authorization server using the provided claim ID. It is used when you need to access detailed information about a particular OAuth2 custom token claim."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/claims/{claimId}".format(  # noqa: UP032
            authServerId=authorization_server_id, claimId=claim_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.manage"]))
async def delete_oauth2_claim(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "The ID of the Authorization Server from which the OAuth2 claim will be deleted."
    ],
    claim_id: Annotated[
        str,
        "The ID of the OAuth2 token claim to delete. This ID specifies which claim to remove from the authorization server.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteOAuth2Claim'."]:
    """Delete a custom OAuth2 token claim by ID.

    Use this tool to delete a specific custom OAuth2 token claim by providing the claim ID. Ideal for managing and removing unnecessary or outdated claims in Okta authorization servers."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/claims/{claimId}".format(  # noqa: UP032
            authServerId=authorization_server_id, claimId=claim_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.read"]))
async def list_auth_server_oauth2_clients(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "The ID of the Authorization Server to list OAuth2 clients for."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'listOAuth2ClientsForAuthorizationServer'."
]:
    """List OAuth2 clients for a specific authorization server.

    Retrieve all client resources associated with a specified authorization server that have tokens. Useful for managing client applications and understanding access scopes within an authorization environment."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/clients".format(  # noqa: UP032
            authServerId=authorization_server_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.read"]))
async def list_refresh_tokens(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "The unique identifier of the Authorization Server. Required to list tokens."
    ],
    client_application_id: Annotated[
        str, "The ID of the client application to fetch refresh tokens for."
    ],
    include_scope_details: Annotated[
        str | None, "Specify 'scope' to include scope details in the embedded attribute."
    ] = None,
    next_page_cursor: Annotated[
        str | None,
        "Specifies the pagination cursor for retrieving the next page of tokens. Use this for navigating through pages of results.",  # noqa: E501
    ] = None,
    maximum_tokens_to_return: Annotated[
        int | None, "Specify the maximum number of tokens to return. It must not exceed 200."
    ] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'listRefreshTokensForAuthorizationServerAndClient'.",
]:
    """List refresh tokens for a specific client and authorization server.

    Use this tool to retrieve all refresh tokens issued by an authorization server for a particular client. Ideal for managing client access and monitoring tokens."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/clients/{clientId}/tokens".format(  # noqa: UP032
            authServerId=authorization_server_id, clientId=client_application_id
        ),
        method="GET",
        params=remove_none_values({
            "expand": include_scope_details,
            "after": next_page_cursor,
            "limit": maximum_tokens_to_return,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.manage"]))
async def revoke_refresh_tokens_for_client(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "The ID of the Authorization Server to revoke tokens from."
    ],
    client_app_id: Annotated[
        str, "The unique ID of the client application whose refresh tokens need to be revoked."
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'revokeRefreshTokensForAuthorizationServerAndClient'.",
]:
    """Revokes all refresh tokens for a specific client.

    Use this tool to revoke all refresh tokens associated with a particular client within a specific authorization server. This is useful for managing client access and ensuring security by invalidating existing tokens."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/clients/{clientId}/tokens".format(  # noqa: UP032
            authServerId=authorization_server_id, clientId=client_app_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.read"]))
async def retrieve_refresh_token(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "The ID of the Authorization Server for which the refresh token is retrieved."
    ],
    client_app_id: Annotated[
        str, "The ID of the client application for which the refresh token is being retrieved."
    ],
    token_id: Annotated[
        str,
        "The ID of the token to retrieve a refresh token for a specific client within an authorization server.",  # noqa: E501
    ],
    include_scope_details: Annotated[
        str | None, "Specify 'scope' to include scope details in the `_embedded` attribute."
    ] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'getRefreshTokenForAuthorizationServerAndClient'.",
]:
    """Retrieve a refresh token for a client.

    Use this tool to get a refresh token for a specified client within an authorization server."""
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/clients/{clientId}/tokens/{tokenId}".format(  # noqa: UP032
            authServerId=authorization_server_id, clientId=client_app_id, tokenId=token_id
        ),
        method="GET",
        params=remove_none_values({"expand": include_scope_details}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.manage"]))
async def revoke_refresh_token(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "The ID of the Authorization Server to revoke the refresh token from."
    ],
    client_app_id: Annotated[
        str, "The ID of the client application for which the refresh token is being revoked."
    ],
    token_id: Annotated[
        str,
        "The ID of the refresh token to be revoked. It is a string that uniquely identifies the token.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'revokeRefreshTokenForAuthorizationServerAndClient'.",
]:
    """Revoke a refresh token for a specific client.

    Use this tool to revoke a refresh token for a specific client within an authorization server. It is useful for managing and invalidating existing refresh tokens when they are no longer needed or should be explicitly invalidated."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/clients/{clientId}/tokens/{tokenId}".format(  # noqa: UP032
            authServerId=authorization_server_id, clientId=client_app_id, tokenId=token_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.read"]))
async def list_authorization_server_keys(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "ID of the Authorization Server whose keys are to be listed."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAuthorizationServerKeys'."]:
    """Lists keys for a custom authorization server.

    Retrieves all current, future, and expired keys for a specified custom authorization server. Use this tool to manage and review authorization keys."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/credentials/keys".format(  # noqa: UP032
            authServerId=authorization_server_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.read"]))
async def retrieve_auth_server_key(
    context: ToolContext,
    authorization_server_id: Annotated[
        str,
        "The unique identifier of the Authorization Server whose key details are to be retrieved.",
    ],
    certificate_key_id: Annotated[
        str, "The unique identifier (`id`) of the certificate key to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAuthorizationServerKey'."]:
    """Retrieve specific Authorization Server Key details.

    Used to fetch details of a specified Authorization Server Key using the `keyId`. This is helpful when verifying or utilizing specific keys in the Okta system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/credentials/keys/{keyId}".format(  # noqa: UP032
            authServerId=authorization_server_id, keyId=certificate_key_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.manage"]))
async def activate_auth_server(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "The unique identifier (`id`) of the authorization server to activate."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateAuthorizationServer'."]:
    """Activates an authorization server.

    Use this tool to activate an authorization server in Okta. Call this when you need to enable an authorization server that is currently inactive."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/lifecycle/activate".format(  # noqa: UP032
            authServerId=authorization_server_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.manage"]))
async def deactivate_auth_server(
    context: ToolContext,
    authorization_server_id: Annotated[str, "The ID of the authorization server to deactivate."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivateAuthorizationServer'."]:
    """Deactivates an authorization server.

    Use this tool to deactivate an authorization server by providing its ID. This is useful for temporarily disabling access control without deleting configuration."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/lifecycle/deactivate".format(  # noqa: UP032
            authServerId=authorization_server_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.read"]))
async def list_auth_server_policies(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "The ID of the specific Authorization Server to retrieve policies for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAuthorizationServerPolicies'."]:
    """Retrieve all policies for a specific authorization server.

    This tool retrieves a list of all policies associated with a specific authorization server using its ID. It should be used to obtain policy details for management or review purposes."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/policies".format(  # noqa: UP032
            authServerId=authorization_server_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.read"]))
async def retrieve_auth_policy(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "The ID of the Authorization Server to retrieve the policy from."
    ],
    policy_id: Annotated[str, "The unique `id` of the Policy to retrieve its details."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAuthorizationServerPolicy'."]:
    """Retrieve details of an authorization server policy.

    This tool retrieves the details of a specific policy from an authorization server using the provided authorization server ID and policy ID. It should be called when detailed information about an authorization server policy is needed."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/policies/{policyId}".format(  # noqa: UP032
            authServerId=authorization_server_id, policyId=policy_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.manage"]))
async def delete_auth_server_policy(
    context: ToolContext,
    authorization_server_id: Annotated[
        str,
        "The unique `id` of the Authorization Server from which the policy needs to be deleted.",
    ],
    policy_id: Annotated[str, "The unique identifier for the policy to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteAuthorizationServerPolicy'."]:
    """Delete a policy from the authorization server.

    Use this tool to delete a specific policy from an authorization server by providing the authorization server ID and policy ID. It should be called when a policy is no longer needed or requires removal."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/policies/{policyId}".format(  # noqa: UP032
            authServerId=authorization_server_id, policyId=policy_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.manage"]))
async def activate_auth_server_policy(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "The unique identifier of the Authorization Server to activate a policy for."
    ],
    policy_id: Annotated[
        str,
        "The `id` of the Policy to activate. This should be a string representing the unique identifier of the policy.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'activateAuthorizationServerPolicy'."
]:
    """Activates an authorization server policy in Okta.

    This tool is used to activate a specific authorization server policy on Okta. It should be called when there is a need to enable a policy that is currently inactive. The tool confirms the successful activation of the policy."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/policies/{policyId}/lifecycle/activate".format(  # noqa: UP032
            authServerId=authorization_server_id, policyId=policy_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.manage"]))
async def deactivate_auth_server_policy(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "Identifier for the Authorization Server to be deactivated."
    ],
    policy_id: Annotated[str, "The ID of the policy to deactivate in the authorization server."],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deactivateAuthorizationServerPolicy'."
]:
    """Deactivates a specific authorization server policy.

    Use this tool to deactivate an authorization server policy by specifying the server and policy IDs. Ideal for managing access control settings."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/policies/{policyId}/lifecycle/deactivate".format(  # noqa: UP032
            authServerId=authorization_server_id, policyId=policy_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.read"]))
async def list_auth_server_policy_rules(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "The ID of the specified Custom Authorization Server to retrieve policy rules from."
    ],
    policy_id: Annotated[str, "The unique identifier of the Policy for which to list rules."],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'listAuthorizationServerPolicyRules'."
]:
    """Retrieve policy rules for a Custom Authorization Server.

    Fetches a list of all policy rules for a specified Custom Authorization Server and Policy, useful for managing access policies."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/policies/{policyId}/rules".format(  # noqa: UP032
            authServerId=authorization_server_id, policyId=policy_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.read"]))
async def get_policy_rule(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "The ID of the Authorization Server needed to retrieve the specified policy rule."
    ],
    policy_id: Annotated[str, "The unique identifier of the policy associated with the rule."],
    policy_rule_id: Annotated[str, "The unique identifier of the policy rule to retrieve."],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getAuthorizationServerPolicyRule'."
]:
    """Retrieve details of a specific policy rule using its rule ID.

    Use this tool to fetch the details of a policy rule from an authorization server by providing the rule ID. Its useful for accessing specific configurations or settings of a particular rule within a policy."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/policies/{policyId}/rules/{ruleId}".format(  # noqa: UP032
            authServerId=authorization_server_id, policyId=policy_id, ruleId=policy_rule_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.manage"]))
async def delete_auth_server_policy_rule(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "ID of the Authorization Server to target for policy rule deletion."
    ],
    policy_id: Annotated[
        str,
        "The ID of the policy to be deleted from the authorization server. This is required to specify which policy rule is being targeted.",  # noqa: E501
    ],
    policy_rule_id: Annotated[str, "The unique identifier for the policy rule to be deleted."],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deleteAuthorizationServerPolicyRule'."
]:
    """Delete a policy rule in an authorization server.

    Use this tool to delete a specific policy rule from a custom authorization server in Okta. This is useful when you need to manage or clean up authorization rules."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/policies/{policyId}/rules/{ruleId}".format(  # noqa: UP032
            authServerId=authorization_server_id, policyId=policy_id, ruleId=policy_rule_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.manage"]))
async def activate_auth_server_policy_rule(
    context: ToolContext,
    authorization_server_id: Annotated[str, "The ID of the Authorization Server to be activated."],
    policy_id: Annotated[
        str, "The `id` of the Policy to be activated within the authorization server."
    ],
    policy_rule_id: Annotated[
        str, "The unique identifier for the policy rule to be activated in Okta."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'activateAuthorizationServerPolicyRule'."
]:
    """Activates an authorization server policy rule in Okta.

    This tool is used to activate a specific policy rule within an authorization server on the Okta platform. Call this tool when you need to enable a specific policy rule that is currently inactive."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/policies/{policyId}/rules/{ruleId}/lifecycle/activate".format(  # noqa: UP032
            authServerId=authorization_server_id, policyId=policy_id, ruleId=policy_rule_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.manage"]))
async def deactivate_policy_rule(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "ID of the Authorization Server to target for deactivation."
    ],
    policy_id: Annotated[str, "The unique `id` of the policy to be deactivated."],
    policy_rule_id: Annotated[str, "The unique identifier of the policy rule to deactivate."],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deactivateAuthorizationServerPolicyRule'."
]:
    """Deactivates an authorization server policy rule.

    Use this tool to deactivate a specific policy rule in an Okta authorization server. This is useful when managing access control policies and you need to disable a particular rule."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/policies/{policyId}/rules/{ruleId}/lifecycle/deactivate".format(  # noqa: UP032
            authServerId=authorization_server_id, policyId=policy_id, ruleId=policy_rule_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.read"]))
async def list_public_keys(
    context: ToolContext,
    authorization_server_id: Annotated[
        str,
        "The unique identifier of the authorization server for which public keys are requested.",
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'listOAuth2ResourceServerJsonWebKeys'."
]:
    """Retrieve public keys for the custom authorization server.

    This tool retrieves all public keys used by a specified custom authorization server for OAuth2. Use it when you need to verify JWTs or manage security keys for your authorization server."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/resourceservercredentials/keys".format(  # noqa: UP032
            authServerId=authorization_server_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.read"]))
async def retrieve_oauth2_server_key(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "The unique `id` of the Authorization Server to retrieve the JSON web key from."
    ],
    custom_auth_server_jwk_id: Annotated[
        str, "Unique identifier of the custom authorization server JSON web key."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getOAuth2ResourceServerJsonWebKey'."
]:
    """Retrieve a custom authorization server's public JSON web key.

    Use this tool to obtain a public JSON web key for a specified custom authorization server by providing the server and key identifiers."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/resourceservercredentials/keys/{keyId}".format(  # noqa: UP032
            authServerId=authorization_server_id, keyId=custom_auth_server_jwk_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.manage"]))
async def delete_inactive_oauth2_jwk(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "`ID` of the Authorization Server required for deleting an inactive JSON web key."
    ],
    json_web_key_id: Annotated[
        str,
        "The unique identifier for the custom authorization server JSON web key to delete. Must be inactive before deletion.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deleteOAuth2ResourceServerJsonWebKey'."
]:
    """Deletes an inactive public JSON web key from an auth server.

    Use this tool to delete a custom authorization server's public JSON web key by providing the key's ID. Ensure the key is inactive before deletion."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/resourceservercredentials/keys/{keyId}".format(  # noqa: UP032
            authServerId=authorization_server_id, keyId=json_web_key_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.manage"]))
async def activate_oauth2_server_key(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "Unique `id` of the Authorization Server whose key is being activated."
    ],
    json_web_key_id: Annotated[
        str, "Unique identifier for the Custom Authorization Server JSON Web Key to activate."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'activateOAuth2ResourceServerJsonWebKey'."
]:
    """Activate an OAuth2 resource server JSON web key.

    This tool activates a custom authorization server's public JSON web key by its `id`. Note that only one key can be active at a time, so activating a new key will deactivate the current one."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/resourceservercredentials/keys/{keyId}/lifecycle/activate".format(  # noqa: UP032
            authServerId=authorization_server_id, keyId=json_web_key_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.manage"]))
async def deactivate_custom_authorization_server_key(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "The ID of the Authorization Server whose JSON web key you want to deactivate."
    ],
    json_web_key_id: Annotated[
        str, "Unique `id` of the Custom Authorization Server JSON Web Key to deactivate."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deactivateOAuth2ResourceServerJsonWebKey'."
]:
    """Deactivate a custom authorization server JSON web key.

    Use this tool to deactivate a public JSON web key for a custom authorization server by its `id`. Note that you cannot deactivate an active key if access token encryption is enabled."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/resourceservercredentials/keys/{keyId}/lifecycle/deactivate".format(  # noqa: UP032
            authServerId=authorization_server_id, keyId=json_web_key_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.read"]))
async def list_custom_oauth2_scopes(
    context: ToolContext,
    authorization_server_id: Annotated[
        str, "The ID of the Authorization Server to retrieve custom token scopes."
    ],
    query_custom_scope_name: Annotated[
        str | None, "Search for custom token scopes by matching values in their names."
    ] = None,
    custom_token_scopes_filter: Annotated[
        str | None, "Filter the list of custom token scopes using a specific expression."
    ] = None,
    pagination_cursor_next_page: Annotated[
        str | None,
        "Specify the pagination cursor for fetching the next page of scopes. Use the cursor from the next link as an opaque value.",  # noqa: E501
    ] = None,
    results_per_page: Annotated[
        int | None,
        "Specifies the number of OAuth2 scopes to return per page. Handles pagination automatically.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listOAuth2Scopes'."]:
    """Retrieve all custom OAuth2 token scopes.

    This tool is used to list all custom OAuth2 token scopes for a specific authorization server identified by its ID. Call this tool when you need to access or display the custom scopes defined in an OAuth2 authorization server."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/scopes".format(  # noqa: UP032
            authServerId=authorization_server_id
        ),
        method="GET",
        params=remove_none_values({
            "q": query_custom_scope_name,
            "filter": custom_token_scopes_filter,
            "after": pagination_cursor_next_page,
            "limit": results_per_page,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.read"]))
async def retrieve_custom_token_scope(
    context: ToolContext,
    authorization_server_id: Annotated[
        str,
        "`id` of the Authorization Server. Required to specify which authorization server to use.",
    ],
    scope_id: Annotated[str, "The `id` of the OAuth2 custom token scope to be retrieved."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOAuth2Scope'."]:
    """Retrieve details of a specific OAuth2 custom token scope.

    This tool is used to obtain details of a particular OAuth2 custom token scope from a specified authorization server using the Auth Server ID and Scope ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/scopes/{scopeId}".format(  # noqa: UP032
            authServerId=authorization_server_id, scopeId=scope_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.authorizationServers.manage"]))
async def delete_oauth2_scope(
    context: ToolContext,
    authorization_server_id: Annotated[
        str,
        "The unique ID of the authorization server from which the custom token scope is to be deleted.",  # noqa: E501
    ],
    scope_id: Annotated[str, "The ID of the custom token scope to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteOAuth2Scope'."]:
    """Deletes a custom OAuth2 token scope by its ID.

    Call this tool to remove a specific custom token scope from an authorization server using its ID. Useful for managing and updating authentication configurations."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/authorizationServers/{authServerId}/scopes/{scopeId}".format(  # noqa: UP032
            authServerId=authorization_server_id, scopeId=scope_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.behaviors.read"]))
async def list_behavior_detection_rules(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listBehaviorDetectionRules'."]:
    """Retrieve all behavior detection rules with pagination.

    Use this tool to obtain a complete list of behavior detection rules from the Okta API. It supports pagination for handling large datasets."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/behaviors",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.behaviors.read"]))
async def retrieve_behavior_detection_rule(
    context: ToolContext,
    behavior_detection_rule_id: Annotated[
        str, "The unique ID of the Behavior Detection Rule to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getBehaviorDetectionRule'."]:
    """Retrieve details of a Behavior Detection Rule by ID.

    This tool retrieves information about a specific Behavior Detection Rule using its unique behaviorId. It's useful for obtaining rule configurations and settings."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/behaviors/{behaviorId}".format(  # noqa: UP032
            behaviorId=behavior_detection_rule_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.behaviors.manage"]))
async def delete_behavior_detection_rule(
    context: ToolContext,
    behavior_detection_rule_id: Annotated[
        str, "ID of the Behavior Detection Rule to delete in Okta."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteBehaviorDetectionRule'."]:
    """Delete a Behavior Detection Rule by behaviorId.

    Use this tool to delete a specific Behavior Detection Rule in Okta by providing the behaviorId. This can be useful for managing and updating security rules in an Okta environment."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/behaviors/{behaviorId}".format(  # noqa: UP032
            behaviorId=behavior_detection_rule_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.behaviors.manage"]))
async def activate_behavior_detection_rule(
    context: ToolContext,
    behavior_detection_rule_id: Annotated[
        str, "The ID of the Behavior Detection Rule to activate in Okta."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateBehaviorDetectionRule'."]:
    """Activates a behavior detection rule.

    Use this tool to activate a behavior detection rule in Okta by providing the behavior ID."""
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/behaviors/{behaviorId}/lifecycle/activate".format(  # noqa: UP032
            behaviorId=behavior_detection_rule_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.behaviors.manage"]))
async def deactivate_behavior_detection_rule(
    context: ToolContext,
    behavior_id: Annotated[
        str, "The unique identifier for the Behavior Detection Rule to deactivate in Okta."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivateBehaviorDetectionRule'."]:
    """Deactivates a specified behavior detection rule in Okta.

    Use this tool to deactivate a behavior detection rule in Okta by providing the behavior ID. This is useful for managing security settings and updating detection configurations."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/behaviors/{behaviorId}/lifecycle/deactivate".format(  # noqa: UP032
            behaviorId=behavior_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.read"]))
async def list_all_brands(
    context: ToolContext,
    include_additional_metadata: Annotated[
        list[str] | None,
        "Specifies additional metadata to be included in the response. Provide a list of metadata fields to expand.",  # noqa: E501
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "The cursor for pagination. It is an opaque string obtained from the `Link` response header to specify your current location in the brand list.",  # noqa: E501
    ] = None,
    object_limit: Annotated[
        int | None,
        "Sets an upper limit on the number of brand objects to return in the response. Accepts an integer value.",  # noqa: E501
    ] = None,
    search_query: Annotated[
        str | None, "Search string to filter the brand records for matching values."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listBrands'."]:
    """Retrieve all brands within your organization.

    Use this tool to get a comprehensive list of all the brands associated with your organization using Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands",
        method="GET",
        params=remove_none_values({
            "expand": include_additional_metadata,
            "after": pagination_cursor,
            "limit": object_limit,
            "q": search_query,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.read"]))
async def retrieve_brand_details(
    context: ToolContext,
    brand_id: Annotated[str, "The unique identifier for the brand to retrieve details for."],
    include_additional_metadata: Annotated[
        list[str] | None,
        "An array of strings specifying additional metadata to be included in the response.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getBrand'."]:
    """Fetches brand details using the brand ID.

    Use this tool to retrieve detailed information about a specific brand by providing the brand ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}".format(brandId=brand_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"expand": include_additional_metadata}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.manage"]))
async def delete_brand(
    context: ToolContext,
    brand_id: Annotated[str, "The unique ID of the brand to be deleted. Required for deletion."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteBrand'."]:
    """Delete a specific brand by its ID.

    Use this tool to delete a brand by providing its unique identifier. This is useful for removing brands that are no longer needed."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}".format(brandId=brand_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.read"]))
async def list_brand_domains(
    context: ToolContext,
    brand_id: Annotated[
        str, "The unique ID used to identify the brand whose domains are to be listed."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listBrandDomains'."]:
    """Retrieve all domains linked to a specific brand.

    Use this tool to get a list of all domains associated with a particular brand identified by `brandId`."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/domains".format(brandId=brand_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.read"]))
async def retrieve_error_page_details(
    context: ToolContext,
    brand_id: Annotated[
        str, "The unique identifier for the brand whose error page details you want to retrieve."
    ],
    include_sub_resources: Annotated[
        list[str] | None,
        "A list of sub-resource names to include additional metadata in the response.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getErrorPage'."]:
    """Retrieve error page sub-resource details.

    This tool retrieves the error page sub-resources for a specified brand using the Okta service. Use this tool to obtain detailed information about error pages, tailored by the `expand` parameter to specify included sub-resources."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/pages/error".format(brandId=brand_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"expand": include_sub_resources}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.read"]))
async def get_customized_error_page(
    context: ToolContext,
    brand_id: Annotated[
        str, "The unique identifier for the brand whose error page is being retrieved."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCustomizedErrorPage'."]:
    """Retrieves the live customized error page for a brand.

    Use this tool to get the customized error page that appears in the live environment for a specified brand."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/pages/error/customized".format(  # noqa: UP032
            brandId=brand_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.manage"]))
async def delete_custom_error_page(
    context: ToolContext,
    brand_id: Annotated[
        str, "The unique ID of the brand from which to delete the customized error page."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteCustomizedErrorPage'."]:
    """Delete a customized error page to revert to the default.

    Use this tool to delete a customized error page, reverting the display to the default error page in your live environment. Useful when restoration to default settings is needed."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/pages/error/customized".format(  # noqa: UP032
            brandId=brand_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.read"]))
async def retrieve_default_error_page(
    context: ToolContext,
    brand_id: Annotated[
        str, "The unique identifier for the brand to retrieve its default error page."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getDefaultErrorPage'."]:
    """Retrieve the default error page for a brand.

    This tool retrieves the default error page for a specified brand when no customized error page is present."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/pages/error/default".format(  # noqa: UP032
            brandId=brand_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.read"]))
async def get_preview_error_page(
    context: ToolContext,
    brand_id: Annotated[
        str, "The unique ID of the brand to retrieve its unpublished error page preview."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPreviewErrorPage'."]:
    """Retrieve the unpublished error page preview for a specific brand.

    Use this tool to access the preview error page associated with a brand, which includes changes that have not been published yet. This preview is not visible in the live environment."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/pages/error/preview".format(  # noqa: UP032
            brandId=brand_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.manage"]))
async def delete_preview_error_page(
    context: ToolContext,
    brand_id: Annotated[
        str, "The ID of the brand for which the preview error page is to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deletePreviewErrorPage'."]:
    """Delete the preview error page with unpublished changes.

    Use this tool to delete the preview error page that contains unpublished changes. It affects only the preview version and not the live environment."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/pages/error/preview".format(  # noqa: UP032
            brandId=brand_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.read"]))
async def retrieve_sign_in_page(
    context: ToolContext,
    brand_id: Annotated[
        str,
        "The unique identifier for the brand. Required to retrieve specific sign-in page resources.",  # noqa: E501
    ],
    include_additional_metadata: Annotated[
        list[str] | None,
        "List specific sub-resources to include in the sign-in page response as metadata.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getSignInPage'."]:
    """Retrieve sign-in page sub-resources for a brand.

    This tool retrieves the sub-resources of a sign-in page for a specified brand on Okta. You can specify which sub-resources to include using the `expand` query parameter. Call this tool to access detailed elements of the sign-in page configuration."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/pages/sign-in".format(  # noqa: UP032
            brandId=brand_id
        ),
        method="GET",
        params=remove_none_values({"expand": include_additional_metadata}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.read"]))
async def get_customized_sign_in_page(
    context: ToolContext,
    brand_id: Annotated[
        str,
        "The unique ID of the brand for which you want to retrieve the customized sign-in page.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCustomizedSignInPage'."]:
    """Retrieve the customized sign-in page for a brand.

    Call this tool to get details of the customized sign-in page for a specific brand in your live environment."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/pages/sign-in/customized".format(  # noqa: UP032
            brandId=brand_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.manage"]))
async def delete_custom_signin_page(
    context: ToolContext,
    brand_id: Annotated[
        str, "The ID of the brand whose customized sign-in page you want to delete."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteCustomizedSignInPage'."]:
    """Delete the customized sign-in page to revert to default.

    Use this tool to delete a customized sign-in page, which will revert to the default sign-in page in the live environment."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/pages/sign-in/customized".format(  # noqa: UP032
            brandId=brand_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.read"]))
async def get_default_sign_in_page(
    context: ToolContext,
    brand_id: Annotated[
        str, "The unique ID of the brand to specify which default sign-in page to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getDefaultSignInPage'."]:
    """Retrieve the default sign-in page when no custom page exists.

    This tool retrieves the default sign-in page for a specified brand when no customized sign-in page is set. It should be called to access the standard Okta sign-in page template."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/pages/sign-in/default".format(  # noqa: UP032
            brandId=brand_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.read"]))
async def retrieve_preview_sign_in_page(
    context: ToolContext,
    brand_identifier: Annotated[
        str, "The unique identifier for the brand whose preview sign-in page you want to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPreviewSignInPage'."]:
    """Retrieve the preview sign-in page for unpublished changes.

    This tool retrieves the preview version of the sign-in page, which includes any unpublished changes. Use this to view the page at `${yourOktaDomain}/login/preview` before it goes live."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/pages/sign-in/preview".format(  # noqa: UP032
            brandId=brand_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.manage"]))
async def delete_preview_sign_in_page(
    context: ToolContext,
    brand_id: Annotated[
        str, "The unique identifier for the brand whose preview sign-in page you wish to delete."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deletePreviewSignInPage'."]:
    """Delete the preview sign-in page with unpublished changes.

    Use this tool to delete the preview version of a sign-in page, which includes changes not yet published to the live environment. Call this when you want to discard these changes."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/pages/sign-in/preview".format(  # noqa: UP032
            brandId=brand_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.read"]))
async def list_sign_in_widget_versions(
    context: ToolContext,
    brand_id: Annotated[
        str,
        "The unique identifier of the brand for which you want to list all supported sign-in widget versions. This is required to specify the brand associated with your organization.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAllSignInWidgetVersions'."]:
    """Retrieve all sign-in widget versions for your organization.

    Call this tool to obtain a list of all sign-in widget versions supported by your organization. This is useful for overseeing compatibility and versioning of authentication interfaces within your system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/pages/sign-in/widget-versions".format(  # noqa: UP032
            brandId=brand_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.read"]))
async def get_sign_out_page_settings(
    context: ToolContext,
    brand_id: Annotated[
        str, "The unique ID of the brand whose sign-out page settings are to be retrieved."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getSignOutPageSettings'."]:
    """Retrieves the sign-out page settings for a given brand.

    Use this tool to get the customized sign-out page settings for a specified brand. Ideal for applications needing to display or manage sign-out page configurations."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/pages/sign-out/customized".format(  # noqa: UP032
            brandId=brand_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.templates.read"]))
async def list_email_templates(
    context: ToolContext,
    brand_id: Annotated[
        str, "The unique identifier of the brand for which to list email templates."
    ],
    pagination_cursor: Annotated[
        str | None,
        "The cursor used for pagination, obtained from the response header, to continue from the current position in the list.",  # noqa: E501
    ] = None,
    result_limit: Annotated[int | None, "The maximum number of email templates to return."] = None,
    include_additional_metadata: Annotated[
        list[str] | None,
        "Array of strings specifying additional metadata to include in the response.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listEmailTemplates'."]:
    """Lists all supported email templates for a brand.

    Use this tool to retrieve all supported email templates for a specified brand in Okta. It is helpful when you need to review or manage the email templates available for customization."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/templates/email".format(  # noqa: UP032
            brandId=brand_id
        ),
        method="GET",
        params=remove_none_values({
            "after": pagination_cursor,
            "limit": result_limit,
            "expand": include_additional_metadata,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.templates.read"]))
async def retrieve_email_template_details(
    context: ToolContext,
    brand_id: Annotated[
        str,
        "The unique identifier for the brand. It's required to specify which brand's email template details to retrieve.",  # noqa: E501
    ],
    email_template_name: Annotated[
        str, "The name of the email template you want to retrieve details for."
    ],
    include_additional_metadata: Annotated[
        list[str] | None,
        "A list of strings specifying additional metadata to include in the response.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getEmailTemplate'."]:
    """Retrieve details of an email template by its name.

    This tool retrieves detailed information about a specific email template by its name, for a given brand ID. It should be called when you need to access or display the details of an email template managed by Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/templates/email/{templateName}".format(  # noqa: UP032
            brandId=brand_id, templateName=email_template_name
        ),
        method="GET",
        params=remove_none_values({"expand": include_additional_metadata}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.templates.read"]))
async def list_email_customizations(
    context: ToolContext,
    brand_id: Annotated[
        str,
        "The unique identifier for the brand whose email template customizations are to be retrieved.",  # noqa: E501
    ],
    email_template_name: Annotated[
        str, "The name of the email template to retrieve customizations for."
    ],
    pagination_cursor: Annotated[
        str | None,
        "The cursor string for pagination, used to specify the current list position. Obtain this from the 'Link' response header.",  # noqa: E501
    ] = None,
    result_limit: Annotated[
        int | None,
        "An integer specifying the maximum number of email template customizations to return.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listEmailCustomizations'."]:
    """Retrieve all customizations for an email template.

    Use this tool to list all available customizations of a specific email template. If custom languages are enabled, it retrieves customizations for those languages as well. Ideal for managing template variations."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/templates/email/{templateName}/customizations".format(  # noqa: UP032
            brandId=brand_id, templateName=email_template_name
        ),
        method="GET",
        params=remove_none_values({"after": pagination_cursor, "limit": result_limit}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.templates.manage"]))
async def delete_email_template_customizations(
    context: ToolContext,
    brand_id: Annotated[
        str, "The ID of the brand whose email template customizations are to be deleted."
    ],
    email_template_name: Annotated[str, "The name of the email template to delete customizations."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteAllCustomizations'."]:
    """Deletes all customizations for an email template.

    Use this tool to delete all customizations for a specific email template in Okta. If Custom languages for Okta Email Templates is enabled, all customizations, including those in additional languages, are removed. Otherwise, only customizations in Okta-supported languages are deleted."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/templates/email/{templateName}/customizations".format(  # noqa: UP032
            brandId=brand_id, templateName=email_template_name
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.templates.read"]))
async def retrieve_email_customization(
    context: ToolContext,
    brand_id: Annotated[
        str,
        "The unique identifier for the brand to retrieve the email customization associated with it.",  # noqa: E501
    ],
    email_template_name: Annotated[str, "The name of the email template to customize."],
    email_customization_id: Annotated[
        str, "The unique identifier for the specific email customization to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getEmailCustomization'."]:
    """Retrieve email customization details by ID.

    Use this tool to fetch the details of a specific email customization in Okta by its unique identifier. Note that if custom languages for Okta Email Templates are disabled, attempting to retrieve a customization by ID for an additional language will result in a '404 Not Found' error."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/templates/email/{templateName}/customizations/{customizationId}".format(  # noqa: UP032
            brandId=brand_id,
            templateName=email_template_name,
            customizationId=email_customization_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.templates.manage"]))
async def delete_email_customization(
    context: ToolContext,
    brand_id: Annotated[
        str, "The unique identifier for the brand whose email customization is to be deleted."
    ],
    email_template_name: Annotated[str, "The name of the email template to be deleted."],
    email_customization_id: Annotated[
        str, "The unique identifier for the email customization to delete."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteEmailCustomization'."]:
    """Deletes an Email Customization by its unique identifier.

    Use this tool to delete an email customization in Okta using its unique ID. Note that if custom languages for Okta Email Templates are disabled, the deletion of additional language customizations by ID won't be registered."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/templates/email/{templateName}/customizations/{customizationId}".format(  # noqa: UP032
            brandId=brand_id,
            templateName=email_template_name,
            customizationId=email_customization_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.templates.read"]))
async def email_customization_preview(
    context: ToolContext,
    brand_id: Annotated[
        str, "The ID of the brand for which the email customization preview is requested."
    ],
    email_template_name: Annotated[
        str, "The name of the email template to retrieve a customization preview."
    ],
    email_customization_id: Annotated[
        str, "The unique identifier for the email customization preview to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCustomizationPreview'."]:
    """Retrieve a preview of an email customization with user-context.

    Fetches a preview of an email customization, filling in variable references from the current user's context. Works unless custom language settings are disabled, in which case it may return a 404 error for additional languages."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/templates/email/{templateName}/customizations/{customizationId}/preview".format(  # noqa: UP032
            brandId=brand_id,
            templateName=email_template_name,
            customizationId=email_customization_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.templates.read"]))
async def retrieve_email_template_default_content(
    context: ToolContext,
    brand_id: Annotated[
        str, "The unique ID of the brand for which the email template content is being retrieved."
    ],
    email_template_name: Annotated[
        str, "Specify the name of the email template to retrieve its default content."
    ],
    email_language: Annotated[
        str | None,
        "Specify the language for the email content. Defaults to the user's current language if unspecified.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getEmailDefaultContent'."]:
    """Retrieves the default content of a specific email template.

    Use this tool to retrieve the default content for a specified email template in Okta. The content defaults to the current user's language, considering Okta's custom language settings and any additional language specified."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/templates/email/{templateName}/default-content".format(  # noqa: UP032
            brandId=brand_id, templateName=email_template_name
        ),
        method="GET",
        params=remove_none_values({"language": email_language}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.templates.read"]))
async def preview_email_template_content(
    context: ToolContext,
    brand_id: Annotated[
        str, "The ID of the brand for which the email template preview is to be retrieved."
    ],
    email_template_name: Annotated[
        str,
        "The name of the email template to preview. This specifies which template's content will be retrieved.",  # noqa: E501
    ],
    email_language: Annotated[
        str | None,
        "The language for the email template. Defaults to the current user's language if unspecified.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getEmailDefaultPreview'."]:
    """Retrieve a preview of an email template's default content.

    This tool fetches a preview of an email template's default content with populated variable references using the current user's context. It considers the user's language if custom languages for Okta Email Templates are enabled."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/templates/email/{templateName}/default-content/preview".format(  # noqa: UP032
            brandId=brand_id, templateName=email_template_name
        ),
        method="GET",
        params=remove_none_values({"language": email_language}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.templates.read"]))
async def get_email_template_settings(
    context: ToolContext,
    brand_id: Annotated[
        str, "The unique ID of the brand whose email template settings are to be retrieved."
    ],
    email_template_name: Annotated[str, "The name of the email template to retrieve settings for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getEmailSettings'."]:
    """Retrieve email template settings for a specified brand.

    This tool retrieves the settings of an email template based on the provided brand ID and template name. It should be called when there's a need to access or review the configuration details of a particular email template within Okta's system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/templates/email/{templateName}/settings".format(  # noqa: UP032
            brandId=brand_id, templateName=email_template_name
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.templates.read"]))
async def send_test_email(
    context: ToolContext,
    brand_id: Annotated[
        str,
        "The ID of the brand for which the test email is sent. Required if the brand is applicable.",  # noqa: E501
    ],
    email_template_name: Annotated[
        str, "Specify the name of the email template to use for the test email."
    ],
    email_language: Annotated[
        str | None,
        "The language to use for the email. Defaults to the current user's language if unspecified.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'sendTestEmail'."]:
    """Send a test email to user's primary and secondary emails.

    This tool sends a test email using the Okta service to the current user's primary and secondary email addresses. The email content is determined by customizations based on language priority and defaults if required. Ideal for verifying email template configurations."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/templates/email/{templateName}/test".format(  # noqa: UP032
            brandId=brand_id, templateName=email_template_name
        ),
        method="POST",
        params=remove_none_values({"language": email_language}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.read"]))
async def list_brand_themes(
    context: ToolContext,
    brand_id: Annotated[
        str, "The ID of the brand for which to list themes. Required for identifying the brand."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listBrandThemes'."]:
    """Retrieve all themes for a specific brand.

    Use this tool to list all the themes associated with a brand in your organization. Note that currently, each organization supports only one theme."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/themes".format(brandId=brand_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.read"]))
async def retrieve_brand_theme(
    context: ToolContext,
    brand_id: Annotated[str, "The unique identifier for the brand to retrieve the theme."],
    theme_id: Annotated[
        str, "Specify the ID of the theme to retrieve details for a particular brand."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getBrandTheme'."]:
    """Retrieve the theme for a specific brand.

    Use this tool to get the theme associated with a particular brand by specifying the brand and theme IDs."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/themes/{themeId}".format(  # noqa: UP032
            brandId=brand_id, themeId=theme_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.manage"]))
async def delete_theme_background_image(
    context: ToolContext,
    brand_id: Annotated[
        str, "The unique ID of the brand whose theme background image is to be deleted."
    ],
    theme_id: Annotated[
        str,
        "The unique identifier for the theme whose background image is to be deleted. This is required to specify which theme's image will be removed within the brand.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteBrandThemeBackgroundImage'."]:
    """Deletes the background image for a specified theme.

    Use this tool when you need to delete the background image of a specific theme within a brand. This is useful for managing theme visuals in applications that utilize Okta services."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/themes/{themeId}/background-image".format(  # noqa: UP032
            brandId=brand_id, themeId=theme_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.manage"]))
async def delete_theme_favicon(
    context: ToolContext,
    brand_id: Annotated[
        str, "The unique identifier for the brand whose theme favicon is to be deleted."
    ],
    theme_id: Annotated[str, "The ID of the theme you wish to delete the favicon from."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteBrandThemeFavicon'."]:
    """Delete a theme's favicon, reverting to the default.

    This tool removes the custom favicon for a specific theme in Okta, causing the theme to use the default Okta favicon. Use this tool when you want to revert to using the default favicon for a theme."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/themes/{themeId}/favicon".format(  # noqa: UP032
            brandId=brand_id, themeId=theme_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.manage"]))
async def delete_theme_logo(
    context: ToolContext,
    brand_id: Annotated[
        str, "The unique identifier for the brand whose theme logo is to be deleted."
    ],
    theme_id: Annotated[
        str,
        "The unique identifier of the theme to delete the logo from. This will revert the theme to the default Okta logo.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteBrandThemeLogo'."]:
    """Deletes a theme logo and reverts to the default Okta logo.

    Use this tool to delete a specific theme logo for a brand in Okta, reverting the theme to the default Okta logo. This is useful when a custom logo needs to be removed from a theme."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/themes/{themeId}/logo".format(  # noqa: UP032
            brandId=brand_id, themeId=theme_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.read"]))
async def retrieve_well_known_uris(
    context: ToolContext,
    brand_id: Annotated[
        str,
        "The unique identifier for the brand whose well-known URIs you want to retrieve. This is required to specify which brand's data to access.",  # noqa: E501
    ],
    additional_metadata: Annotated[
        list[str] | None,
        "An array of strings specifying additional metadata to include in the response.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAllWellKnownURIs'."]:
    """Retrieve well-known URIs for a specified brand.

    This tool retrieves the content from each of the well-known URIs for a specified brand. It should be called when you need to access information hosted at these URIs for a particular brand in Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/well-known-uris".format(  # noqa: UP032
            brandId=brand_id
        ),
        method="GET",
        params=remove_none_values({"expand": additional_metadata}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.read"]))
async def get_well_known_uri(
    context: ToolContext,
    brand_id: Annotated[str, "The unique identifier for the brand to retrieve its well-known URI."],
    well_known_uri_path: Annotated[
        str,
        "Specifies the path for the well-known URI. Choose from options like 'apple-app-site-association', 'assetlinks.json', or 'webauthn'.",  # noqa: E501
    ],
    include_metadata: Annotated[
        list[str] | None,
        "A list of metadata fields to include in the response. Provides extra details about the brand and URI.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getRootBrandWellKnownURI'."]:
    """Retrieve the well-known URI for a specified brand and path.

    Use this tool to obtain the well-known URI associated with a specific brand and URI path. Ideal for configurations or integrations requiring brand-specific information."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/well-known-uris/{path}".format(  # noqa: UP032
            brandId=brand_id, path=well_known_uri_path
        ),
        method="GET",
        params=remove_none_values({"expand": include_metadata}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.brands.read"]))
async def retrieve_brand_well_known_uri(
    context: ToolContext,
    brand_id: Annotated[
        str,
        "The unique identifier of the brand for which the well-known URI content is being retrieved.",  # noqa: E501
    ],
    well_known_uri_path: Annotated[
        str,
        "The specific path of the well-known URI. Expected values are 'apple-app-site-association', 'assetlinks.json', or 'webauthn'.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getBrandWellKnownURI'."]:
    """Retrieve customized content for a brand's well-known URI.

    This tool retrieves the customized content of a specific well-known URI for a given brand and URI path. It should be used when you need information on the customized settings or configurations associated with a brand's specific URI."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/brands/{brandId}/well-known-uris/{path}/customized".format(  # noqa: UP032
            brandId=brand_id, path=well_known_uri_path
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.captchas.read"]))
async def list_captcha_instances(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listCaptchaInstances'."]:
    """Retrieve and list all CAPTCHA instances with filters.

    This tool retrieves all CAPTCHA instances, supporting pagination and filtering to match specific criteria. Use it to obtain a comprehensive list of CAPTCHA instances available in the system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/captchas",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.captchas.read"]))
async def retrieve_captcha_details(
    context: ToolContext,
    captcha_instance_id: Annotated[
        str, "The unique key identifying the CAPTCHA instance to retrieve details for in Okta."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCaptchaInstance'."]:
    """Retrieve properties of a CAPTCHA instance.

    This tool fetches detailed properties of a specified CAPTCHA instance in the Okta system. Use it when you need information about a particular CAPTCHA by providing its ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/captchas/{captchaId}".format(  # noqa: UP032
            captchaId=captcha_instance_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.captchas.manage"]))
async def delete_captcha_instance(
    context: ToolContext,
    captcha_instance_id: Annotated[
        str,
        "The unique key used to identify your CAPTCHA instance. Ensure it is not associated with the organization settings before deletion.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteCaptchaInstance'."]:
    """Delete a specified CAPTCHA instance from Okta.

    Use this tool to delete a specific CAPTCHA instance in Okta. Ensure the CAPTCHA is not associated with your organization settings before deletion to avoid request failure."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/captchas/{captchaId}".format(  # noqa: UP032
            captchaId=captcha_instance_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.deviceAssurance.read"]))
async def list_device_assurance_policies(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listDeviceAssurancePolicies'."]:
    """Retrieve all device assurance policies from Okta.

    Use this tool to get an overview of all device assurance policies available in Okta, which can help in managing and securing devices."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/device-assurances",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.deviceAssurance.read"]))
async def get_device_assurance_policy(
    context: ToolContext,
    device_assurance_policy_id: Annotated[
        str, "The unique identifier for the device assurance policy to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getDeviceAssurancePolicy'."]:
    """Retrieve a specific device assurance policy by ID.

    Use this tool to get details about a device assurance policy using its unique ID. This can be helpful for verifying or reviewing policy specifications."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/device-assurances/{deviceAssuranceId}".format(  # noqa: UP032
            deviceAssuranceId=device_assurance_policy_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.deviceAssurance.manage"]))
async def delete_device_assurance_policy(
    context: ToolContext,
    device_assurance_policy_id: Annotated[
        str,
        "The unique identifier of the device assurance policy to delete. Ensure the policy is not used in authentication policies before deletion.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteDeviceAssurancePolicy'."]:
    """Deletes a device assurance policy if not in use.

    Use this tool to delete a device assurance policy by specifying the deviceAssuranceId. Deletion will be prevented if the policy is active in the organization's Authentication Policies."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/device-assurances/{deviceAssuranceId}".format(  # noqa: UP032
            deviceAssuranceId=device_assurance_policy_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.deviceIntegrations.read"]))
async def list_device_integrations(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listDeviceIntegrations'."]:
    """Retrieve all device integrations for your organization.

    Use this tool to list all the device integrations configured for your organization, such as Device Posture Provider, Windows Security Center, Chrome Device Trust, OSQuery, and Android Device Trust."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/device-integrations",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.deviceIntegrations.read"]))
async def retrieve_device_integration(
    context: ToolContext,
    device_integration_id: Annotated[
        str, "The unique ID of the device integration to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getDeviceIntegration'."]:
    """Retrieve details of a device integration by ID.

    Use this tool to get specific information about a device integration using its unique ID."""
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/device-integrations/{deviceIntegrationId}".format(  # noqa: UP032
            deviceIntegrationId=device_integration_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.deviceIntegrations.manage"]))
async def activate_device_integration(
    context: ToolContext,
    device_integration_id: Annotated[
        str,
        "The unique ID of the device integration to activate. This ID specifies which device integration to activate and update configurations for.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateDeviceIntegration'."]:
    """Activate a device integration using the deviceIntegrationId.

    Activates a specified device integration and updates the configurations accordingly. This should be called when a device integration needs to be activated by providing its ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/device-integrations/{deviceIntegrationId}/lifecycle/activate".format(  # noqa: UP032
            deviceIntegrationId=device_integration_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.deviceIntegrations.manage"]))
async def deactivate_device_integration(
    context: ToolContext,
    device_integration_id: Annotated[
        str, "The unique identifier for the device integration to deactivate."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivateDeviceIntegration'."]:
    """Deactivate a device integration using its ID.

    Deactivate a specific device integration by providing the deviceIntegrationId. This tool should be called when you need to disable a previously active device integration."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/device-integrations/{deviceIntegrationId}/lifecycle/deactivate".format(  # noqa: UP032
            deviceIntegrationId=device_integration_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.devicePostureChecks.read"]))
async def list_device_posture_checks(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listDevicePostureChecks'."]:
    """Lists all device posture checks from Okta.

    Use this tool to retrieve details of all device posture checks registered in Okta. This information is useful for security assessments and compliance monitoring within an organization."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/device-posture-checks",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.devicePostureChecks.read"]))
async def list_default_device_posture_checks(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listDefaultDevicePostureChecks'."]:
    """Retrieve all default device posture checks from Okta.

    This tool should be called to get a list of all default device posture checks defined by Okta. These posture checks are predefined and their type is always `BUILTIN`."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/device-posture-checks/default",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.devicePostureChecks.read"]))
async def retrieve_device_posture_check(
    context: ToolContext,
    device_posture_check_id: Annotated[
        str, "The unique identifier for the device posture check to retrieve."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getDevicePostureCheck'."]:
    """Retrieve a device posture check by ID.

    Use this tool to retrieve details of a specific device posture check using the `postureCheckId`. This is helpful for managing or verifying device compliance and security status."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/device-posture-checks/{postureCheckId}".format(  # noqa: UP032
            postureCheckId=device_posture_check_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.devicePostureChecks.manage"]))
async def delete_device_posture_check(
    context: ToolContext,
    device_posture_check_id: Annotated[str, "ID of the specific device posture check to delete."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteDevicePostureCheck'."]:
    """Deletes a specified device posture check.

    Use this tool to delete a device posture check using its postureCheckId, unless it is used in a device assurance policy."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/device-posture-checks/{postureCheckId}".format(  # noqa: UP032
            postureCheckId=device_posture_check_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.devices.read"]))
async def list_all_devices(
    context: ToolContext,
    pagination_cursor: Annotated[
        str | None,
        "A string used to paginate and retrieve the next set of results. Use this from the previous response to access more data.",  # noqa: E501
    ] = None,
    device_list_limit: Annotated[
        int | None, "Maximum number of devices to return. It's recommended to set this at 20."
    ] = None,
    scim_filter_expression: Annotated[
        str | None,
        "A SCIM filter expression to filter devices based on profile, id, status, or lastUpdated properties. Supports 'co' operator with specific attributes like profile.displayName, profile.serialNumber, etc.",  # noqa: E501
    ] = None,
    include_user_details_and_management_status: Annotated[
        str | None,
        "Specify whether to include associated user details and management status in the `_embedded` attribute. Options are 'user' or 'userSummary'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listDevices'."]:
    """Fetches a paginated list of devices with optional search criteria.

    This tool retrieves a list of all devices with support for pagination. It allows specifying search criteria to filter devices based on properties using SCIM filter specifications. It's important to note that search results are not suitable for critical flows due to potential data staleness. This tool is useful for querying device information, but not for operations needing real-time accuracy."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/devices",
        method="GET",
        params=remove_none_values({
            "after": pagination_cursor,
            "limit": device_list_limit,
            "search": scim_filter_expression,
            "expand": include_user_details_and_management_status,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.devices.read"]))
async def retrieve_device_information(
    context: ToolContext,
    device_id: Annotated[str, "The unique ID of the device to retrieve information for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getDevice'."]:
    """Retrieve information about a specific device using its ID.

    This tool is used to get detailed information about a device by its `deviceId`. It should be called when you need to access specific details or status of a device managed in the Okta system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/devices/{deviceId}".format(deviceId=device_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.devices.manage"]))
async def delete_deactivated_device(
    context: ToolContext,
    device_id: Annotated[
        str,
        "The unique identifier of the device to be permanently deleted. Must be in 'DEACTIVATED' status.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteDevice'."]:
    """Permanently delete a device with deactivated status.

    Use this tool to permanently delete a device if it is deactivated. This action cannot be undone and removes all associated profile data. Ensure the device is deactivated before proceeding to avoid errors."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/devices/{deviceId}".format(deviceId=device_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.devices.manage"]))
async def activate_device(
    context: ToolContext,
    device_id: Annotated[str, "The unique identifier (`id`) of the device to be activated."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateDevice'."]:
    """Activate a device by setting its status to ACTIVE.

    Use this tool to activate a device by its `deviceId`, changing its status to `ACTIVE`. This is typically needed for managing device-user links and ensuring the device is operational."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/devices/{deviceId}/lifecycle/activate".format(  # noqa: UP032
            deviceId=device_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.devices.manage"]))
async def deactivate_device(
    context: ToolContext,
    device_id: Annotated[
        str,
        "The ID of the device to deactivate. This identifier is required to set the device status to `DEACTIVATED`.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivateDevice'."]:
    """Deactivate a device by setting its status to DEACTIVATED.

    Use this tool to deactivate a device in Okta. Deactivation sets the device status to `DEACTIVATED`, causing it to lose all user links. Ensure the device is deactivated before deletion as this process is destructive for device factors and client certificates. Reenrollment allows users to set up new factors."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/devices/{deviceId}/lifecycle/deactivate".format(  # noqa: UP032
            deviceId=device_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.devices.manage"]))
async def suspend_device(
    context: ToolContext,
    device_id: Annotated[
        str,
        "The unique identifier (ID) of the device to be suspended. This ID is required for executing the suspension operation.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'suspendDevice'."]:
    """Suspend a device by setting its status to 'SUSPENDED'.

    This tool is used to suspend a device in Okta by changing its status to 'SUSPENDED'. This status allows for temporary suspension intended for operations like creating and deleting device user links. It is a non-destructive, reversible status that can be lifted by unsuspending or deactivating the device."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/devices/{deviceId}/lifecycle/suspend".format(  # noqa: UP032
            deviceId=device_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.devices.manage"]))
async def unsuspend_device(
    context: ToolContext,
    device_id: Annotated[
        str,
        "The unique `id` of the device to unsuspend. This ID is required and should refer to a device with a `SUSPENDED` status.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'unsuspendDevice'."]:
    """Unsuspend a device to return its status to ACTIVE.

    Use this tool to change a device's status from SUSPENDED to ACTIVE. It is applicable only for devices that are currently suspended."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/devices/{deviceId}/lifecycle/unsuspend".format(  # noqa: UP032
            deviceId=device_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.devices.read"]))
async def list_device_users(
    context: ToolContext,
    device_id: Annotated[
        str,
        "The ID of the device to fetch users for. This should match the device's unique identifier in the system.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listDeviceUsers'."]:
    """Retrieve all users for a specific device by device ID.

    Use this tool to get a list of users associated with a particular device, identified by its device ID. Call this tool when you need to find out which users have associated accounts with a specific device."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/devices/{deviceId}/users".format(deviceId=device_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.domains.read"]))
async def list_verified_custom_domains(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listCustomDomains'."]:
    """Retrieve verified custom domains for the organization.

    Use this tool to get a list of all the verified custom domains associated with your organization. It is useful for managing and reviewing domain settings."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/domains",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.domains.read"]))
async def retrieve_custom_domain(
    context: ToolContext,
    domain_id: Annotated[str, "The unique ID of the custom domain to retrieve details for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCustomDomain'."]:
    """Retrieve details of a custom domain by ID.

    Use this tool to obtain information about a specific custom domain in Okta by providing its domain ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/domains/{domainId}".format(domainId=domain_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.domains.manage"]))
async def delete_custom_domain(
    context: ToolContext,
    domain_id: Annotated[
        str,
        "The ID of the custom domain to be deleted. This should match the existing domain's identifier in Okta.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteCustomDomain'."]:
    """Deletes a custom domain using the specified domain ID.

    This tool is used to delete a custom domain in Okta by providing the domain ID. It should be called when a specific custom domain needs to be removed from the system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/domains/{domainId}".format(domainId=domain_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.domains.manage"]))
async def verify_domain_status(
    context: ToolContext,
    domain_id: Annotated[str, "The unique identifier for the domain to verify."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'verifyDomain'."]:
    """Verify the status of a custom domain and DNS records.

    This tool checks the verification status of a custom domain by domainId and validates DNS records. If the certificate source is OKTA_MANAGED, it attempts to manage, obtain, and install a certificate."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/domains/{domainId}/verify".format(domainId=domain_id),  # noqa: UP032
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.emailDomains.read"]))
async def list_email_domains(
    context: ToolContext,
    include_metadata: Annotated[
        list[str] | None,
        "A list of metadata fields to include in the response. Each entry is a string specifying a field name.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listEmailDomains'."]:
    """Lists all email domains in your organization.

    This tool retrieves all the email domains configured within your organization. It should be called when you need to view or manage the existing email domains."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/email-domains",
        method="GET",
        params=remove_none_values({"expand": include_metadata}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.emailDomains.read"]))
async def retrieve_email_domain(
    context: ToolContext,
    email_domain_id: Annotated[
        str, "The unique identifier for the email domain to retrieve information about in Okta."
    ],
    include_additional_metadata: Annotated[
        list[str] | None,
        "List of strings specifying additional metadata to include in the response.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getEmailDomain'."]:
    """Retrieve email domain details by ID.

    Fetches details of a specific email domain using the given `emailDomainId`. Ideal for obtaining information about a particular domain managed by Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/email-domains/{emailDomainId}".format(  # noqa: UP032
            emailDomainId=email_domain_id
        ),
        method="GET",
        params=remove_none_values({"expand": include_additional_metadata}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.emailDomains.manage"]))
async def delete_email_domain(
    context: ToolContext,
    email_domain_id: Annotated[str, "The unique identifier for the email domain to be deleted."],
    include_additional_metadata: Annotated[
        list[str] | None,
        "Specifies which additional metadata should be included in the response. Provide as an array of strings.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteEmailDomain'."]:
    """Deletes a specified email domain from Okta.

    Use this tool to delete an email domain by providing the `emailDomainId`. It is called when an email domain needs to be removed from the system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/email-domains/{emailDomainId}".format(  # noqa: UP032
            emailDomainId=email_domain_id
        ),
        method="DELETE",
        params=remove_none_values({"expand": include_additional_metadata}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.emailDomains.manage"]))
async def verify_email_domain(
    context: ToolContext,
    email_domain_id: Annotated[str, "The unique identifier for the email domain to be verified."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'verifyEmailDomain'."]:
    """Verify the status of an email domain.

    This tool verifies an email domain using the unique `emailDomainId`. It should be called when there's a need to confirm the verification status of a specific email domain."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/email-domains/{emailDomainId}/verify".format(  # noqa: UP032
            emailDomainId=email_domain_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.emailServers.read"]))
async def list_custom_email_servers(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listEmailServers'."]:
    """Fetch all enrolled custom SMTP server configurations.

    Use this tool to retrieve all configured custom SMTP server settings from Okta."""
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/email-servers",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.emailServers.read"]))
async def retrieve_smtp_server_config(
    context: ToolContext,
    email_server_identifier: Annotated[
        str, "The unique identifier for the custom SMTP server to retrieve its configuration."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getEmailServer'."]:
    """Retrieve custom SMTP server configuration details.

    Use this tool to get the configuration details of a specified custom SMTP server by providing the email server identifier."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/email-servers/{emailServerId}".format(  # noqa: UP032
            emailServerId=email_server_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.emailServers.manage"]))
async def delete_email_server(
    context: ToolContext,
    email_server_id: Annotated[
        str, "The unique identifier of the custom SMTP server to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteEmailServer'."]:
    """Delete a specified custom SMTP server configuration.

    Use this tool to delete a specific custom SMTP server configuration by providing the server's ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/email-servers/{emailServerId}".format(  # noqa: UP032
            emailServerId=email_server_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.eventHooks.read"]))
async def list_event_hooks(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listEventHooks'."]:
    """Retrieve all event hooks from the Okta API.

    Use this tool to get a list of all event hooks configured in Okta. It should be called when you need to audit, review, or manage event hooks in your Okta setup."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/eventHooks",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.eventHooks.read"]))
async def retrieve_event_hook(
    context: ToolContext,
    event_hook_id: Annotated[str, "The unique `id` of the event hook to retrieve details for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getEventHook'."]:
    """Retrieve details of a specific event hook by ID.

    Call this tool to get detailed information about a specific event hook in Okta using the eventHookId."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/eventHooks/{eventHookId}".format(  # noqa: UP032
            eventHookId=event_hook_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.eventHooks.manage"]))
async def delete_inactive_event_hook(
    context: ToolContext,
    event_hook_id: Annotated[
        str, "The ID of the event hook to delete. It must have a status of `INACTIVE`."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteEventHook'."]:
    """Delete an inactive event hook by ID.

    Use this tool to delete an event hook with a status of `INACTIVE` by providing its ID. Deletion is irreversible, so ensure that the event hook is no longer needed."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/eventHooks/{eventHookId}".format(  # noqa: UP032
            eventHookId=event_hook_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.eventHooks.manage"]))
async def activate_event_hook(
    context: ToolContext,
    event_hook_id: Annotated[
        str,
        "The ID of the Event Hook to be activated. This string identifies the event hook in Okta.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateEventHook'."]:
    """Activates an Okta event hook by ID.

    This tool activates the Okta event hook that matches the provided ID. It should be used when you need to enable an event hook to start receiving events. The confirmation of activation status is returned."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/eventHooks/{eventHookId}/lifecycle/activate".format(  # noqa: UP032
            eventHookId=event_hook_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.eventHooks.manage"]))
async def deactivate_event_hook(
    context: ToolContext,
    event_hook_id: Annotated[str, "The unique identifier of the event hook to deactivate."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivateEventHook'."]:
    """Deactivates a specified event hook by its ID.

    Use this tool to deactivate an event hook by providing its unique ID. It is useful for managing event hooks that are no longer needed or need to be temporarily disabled."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/eventHooks/{eventHookId}/lifecycle/deactivate".format(  # noqa: UP032
            eventHookId=event_hook_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.eventHooks.manage"]))
async def verify_event_hook(
    context: ToolContext,
    event_hook_id: Annotated[
        str, "The unique identifier for the Event Hook to verify its setup and status."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'verifyEventHook'."]:
    """Verify the status of an Okta event hook.

    This tool verifies if an Okta event hook is correctly set up by matching the `eventHookId`. It ensures the event hook can receive events by confirming its status as either `ACTIVE` or `VERIFIED`. Call this tool to check the readiness of an event hook in Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/eventHooks/{eventHookId}/lifecycle/verify".format(  # noqa: UP032
            eventHookId=event_hook_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.features.read"]))
async def list_self_service_features(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listFeatures'."]:
    """Lists all self-service features for your organization.

    Use this tool to retrieve a comprehensive list of self-service features available in your organization. Useful for understanding or displaying the capabilities enabled for users."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/features",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.features.read"]))
async def retrieve_okta_feature_by_id(
    context: ToolContext,
    feature_id: Annotated[
        str,
        "The ID of the Okta feature to retrieve. This should be a string representing the unique identifier of the feature.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getFeature'."]:
    """Retrieve details of a specific Okta feature by ID.

    Use this tool to get detailed information about a specific feature in Okta using its ID. Useful for accessing configuration or status of Okta features."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/features/{featureId}".format(featureId=feature_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.features.read"]))
async def list_feature_dependencies(
    context: ToolContext,
    feature_id: Annotated[
        str, "The unique identifier of the feature for which you want to list dependencies."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listFeatureDependencies'."]:
    """Retrieve dependencies for a specific feature.

    Use this tool to get a list of all features required to enable a specified feature. Ideal for understanding prerequisite features."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/features/{featureId}/dependencies".format(  # noqa: UP032
            featureId=feature_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.features.read"]))
async def list_feature_dependents(
    context: ToolContext,
    feature_id: Annotated[
        str,
        "The unique identifier for the feature to check dependencies for. This should be a string representing the feature's ID.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listFeatureDependents'."]:
    """Lists all feature dependents for a specified feature.

    This tool retrieves a list of features that must be disabled for the specified feature to be disabled. It is useful for understanding dependencies between features."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/features/{featureId}/dependents".format(  # noqa: UP032
            featureId=feature_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.features.manage"]))
async def update_feature_lifecycle(
    context: ToolContext,
    feature_id: Annotated[str, "The unique ID of the feature to update its lifecycle status."],
    feature_lifecycle_status: Annotated[str, "Indicates whether to ENABLE or DISABLE the feature."],
    force_mode: Annotated[
        str | None, "Set to 'force' to override dependencies when enabling or disabling a feature."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'updateFeatureLifecycle'."]:
    """Enable or disable a feature's lifecycle status in Okta.

    Use this tool to update the lifecycle status of a feature, enabling or disabling it within your organization in Okta. Optionally, use 'mode=force' to override dependencies and ensure the feature's status change."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/features/{featureId}/{lifecycle}".format(  # noqa: UP032
            featureId=feature_id, lifecycle=feature_lifecycle_status
        ),
        method="POST",
        params=remove_none_values({"mode": force_mode}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.apps.read"]))
async def get_okta_app_settings(
    context: ToolContext,
    okta_app_key_name: Annotated[
        str, "The key name for the Okta app. Supported apps include 'admin-console'."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getFirstPartyAppSettings'."]:
    """Retrieve settings for a specific Okta app.

    Use this tool to get the configuration settings of an Okta first-party app specified by its name."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/first-party-app-settings/{appName}".format(  # noqa: UP032
            appName=okta_app_key_name
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.groups.read"]))
async def get_all_okta_groups(
    context: ToolContext,
    group_search_expression: Annotated[
        str | None,
        "A URL-encoded filtering expression to search for groups based on various properties like profile attributes or top-level properties. Supported operators are `sw`, `eq`, and `co` for select attributes. Can involve pagination.",  # noqa: E501
    ] = None,
    group_filter_expression: Annotated[
        str | None,
        "URL-encoded filter expression to narrow down groups. Follow Okta's filter guidelines for proper syntax.",  # noqa: E501
    ] = None,
    group_name_query: Annotated[
        str | None,
        "Search for a group by its name. Note: This query returns up to 300 results and cannot be used with pagination.",  # noqa: E501
    ] = None,
    pagination_cursor_after: Annotated[
        str | None,
        "Specifies the cursor for retrieving the next page of groups. Obtain from the 'next' link relation for pagination.",  # noqa: E501
    ] = None,
    group_result_limit: Annotated[
        int | None,
        "Specifies the number of group results in a page. It is recommended to set a limit under 200 for optimal performance. If a request times out, try a smaller limit.",  # noqa: E501
    ] = None,
    include_additional_metadata: Annotated[
        str | None,
        "Specify additional metadata to include in the response. Options: 'stats' or 'app'.",
    ] = None,
    sort_by_field: Annotated[
        str | None,
        "Specifies the field to sort by for search queries. Can be any single property, like `profile.name`.",  # noqa: E501
    ] = None,
    sort_order_for_search: Annotated[
        str | None,
        "Defines the sort order (asc or desc) for search queries. Ignored if sortBy isn't specified.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listGroups'."]:
    """Retrieve a list of all Okta groups with pagination.

    This tool retrieves all groups in Okta with optional pagination. It can filter, search, or query to return specific subsets of groups based on given criteria. Recommended usage includes setting a limit under 200 for optimal performance. Note that the results are driven by an eventually consistent datasource with minimal synchronization lag."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups",
        method="GET",
        params=remove_none_values({
            "search": group_search_expression,
            "filter": group_filter_expression,
            "q": group_name_query,
            "after": pagination_cursor_after,
            "limit": group_result_limit,
            "expand": include_additional_metadata,
            "sortBy": sort_by_field,
            "sortOrder": sort_order_for_search,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.groups.manage"]))
async def create_okta_group(
    context: ToolContext,
    group_profile_details: Annotated[
        dict[str, dict[str, str]],
        "A JSON object containing the group's name and description for the new OKTA group. Must include a `name` key for the group name and a `description` key for the group description.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'addGroup'."]:
    """Create a new OKTA group in your organization.

    Use this tool to add a new group with the `OKTA_GROUP` type in your Okta organization. It should be called when there's a need to organize users into a new group for collaboration or permissions management."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({"requestBody": group_profile_details}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.groups.read"]))
async def list_group_rules(
    context: ToolContext,
    page_result_limit: Annotated[
        int | None,
        "Specifies the number of rule results to display per page. Provide an integer value.",
    ] = None,
    pagination_cursor_for_next_page: Annotated[
        str | None, "Specifies the pagination cursor for retrieving the next page of group rules."
    ] = None,
    search_keyword: Annotated[str | None, "Keyword to search for specific group rules."] = None,
    display_group_names: Annotated[
        str | None, "Set to `groupIdToGroupNameMap` to display group names in the response."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listGroupRules'."]:
    """Retrieve all group rules in your organization.

    This tool fetches a list of all group rules configured within your organization. Use it to review or manage group rules effectively."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/rules",
        method="GET",
        params=remove_none_values({
            "limit": page_result_limit,
            "after": pagination_cursor_for_next_page,
            "search": search_keyword,
            "expand": display_group_names,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.groups.read"]))
async def retrieve_group_rule_by_id(
    context: ToolContext,
    group_rule_id: Annotated[str, "The ID of the group rule to retrieve."],
    show_group_names: Annotated[
        str | None, "Set to 'groupIdToGroupNameMap' to show group names in the response."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getGroupRule'."]:
    """Retrieve detailed information about a group rule by ID.

    Use this tool to obtain details of a specific group rule from your organization by providing the rule ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/rules/{groupRuleId}".format(  # noqa: UP032
            groupRuleId=group_rule_id
        ),
        method="GET",
        params=remove_none_values({"expand": show_group_names}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.groups.manage"]))
async def delete_group_rule(
    context: ToolContext,
    group_rule_id: Annotated[
        str,
        "The unique ID of the group rule to be deleted. Required for identifying which group rule to remove.",  # noqa: E501
    ],
    remove_users: Annotated[
        bool | None, "Set to true to remove users from groups assigned by this rule."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteGroupRule'."]:
    """Deletes a specific group rule by its ID.

    Use this tool to delete a group rule from the Okta system by providing the specific group rule ID when the rule is no longer needed."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/rules/{groupRuleId}".format(  # noqa: UP032
            groupRuleId=group_rule_id
        ),
        method="DELETE",
        params=remove_none_values({"removeUsers": remove_users}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.groups.manage"]))
async def activate_group_rule(
    context: ToolContext,
    group_rule_id: Annotated[str, "The ID of the group rule to activate in Okta."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateGroupRule'."]:
    """Activate a specific group rule by ID in Okta.

    Use this tool to activate a group rule in your Okta organization by providing the specific rule ID. This is useful for managing and enforcing policies in your organization's group behaviors."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/rules/{groupRuleId}/lifecycle/activate".format(  # noqa: UP032
            groupRuleId=group_rule_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.groups.manage"]))
async def deactivate_group_rule(
    context: ToolContext,
    group_rule_id: Annotated[
        str,
        "The ID of the group rule to be deactivated. This is a unique string identifier for the group rule in your organization.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivateGroupRule'."]:
    """Deactivate a specific group rule by ID.

    Use this tool to deactivate a specific group rule in your organization by providing the group rule ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/rules/{groupRuleId}/lifecycle/deactivate".format(  # noqa: UP032
            groupRuleId=group_rule_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.groups.read"]))
async def retrieve_group_by_id(
    context: ToolContext,
    group_id: Annotated[
        str, "The unique identifier for the group to retrieve from the organization."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getGroup'."]:
    """Retrieve specific group details by ID from your org.

    Use this tool to get information about a specific group in your organization by providing the group's ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}".format(groupId=group_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.groups.manage"]))
async def update_okta_group_profile(
    context: ToolContext,
    group_id: Annotated[
        str,
        "The unique identifier for the group to be updated in Okta. This must be an OKTA_GROUP type.",  # noqa: E501
    ],
    group_profile: Annotated[
        dict[str, dict[str, str]],
        "JSON object containing standard and custom profile properties for an OKTA_GROUP type. It includes fields like 'name' and 'description'.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'replaceGroup'."]:
    """Update the profile of an OKTA_GROUP type in your organization.

    Use this tool to replace the profile for a group of the OKTA_GROUP type in your Okta organization. This tool is suitable for modifying group profiles not managed by app imports. Ensure the group type is OKTA_GROUP, as APP_GROUP types like Active Directory groups cannot be modified with this tool."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}".format(groupId=group_id),  # noqa: UP032
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({"requestBody": group_profile}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.groups.manage"]))
async def delete_group(
    context: ToolContext,
    group_id: Annotated[str, "The unique identifier of the group to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteGroup'."]:
    """Remove a specified group from your organization.

    Use this tool to delete a group of `OKTA_GROUP` or `APP_GROUP` type from your organization. Note: Groups of type `APP_GROUP` cannot be removed if they are used in a group push mapping."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}".format(groupId=group_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.groups.read"]))
async def list_group_assigned_apps(
    context: ToolContext,
    group_id: Annotated[
        str, "The unique identifier for the group. Used to fetch the assigned applications."
    ],
    pagination_cursor_next_page: Annotated[
        str | None,
        "The pagination cursor that indicates the starting point for the next page of app results. Use this to navigate through multiple pages of app data.",  # noqa: E501
    ] = None,
    page_result_limit: Annotated[
        int | None, "The number of application results to return per page."
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'listAssignedApplicationsForGroup'."
]:
    """Retrieve all applications assigned to a specific group in Okta.

    Use this tool to get a list of all the applications that have been assigned to a particular group in Okta. Useful for managing group access and permissions."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}/apps".format(groupId=group_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "after": pagination_cursor_next_page,
            "limit": page_result_limit,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.groups.read"]))
async def list_group_owners(
    context: ToolContext,
    group_id: Annotated[str, "The unique identifier of the group whose owners you want to list."],
    scim_filter_expression: Annotated[
        str | None, "SCIM filter expression to filter group owners by type in Okta."
    ] = None,
    pagination_cursor: Annotated[
        str | None, "Pagination cursor for fetching the next page of group owners."
    ] = None,
    owner_results_per_page: Annotated[
        int | None, "Specifies the number of owner results to return per page."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listGroupOwners'."]:
    """Retrieve owners for a specific group in Okta.

    Use this tool to obtain a list of all owners for a specified group using the group ID in Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}/owners".format(groupId=group_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "search": scim_filter_expression,
            "after": pagination_cursor,
            "limit": owner_results_per_page,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.groups.manage"]))
async def remove_group_owner(
    context: ToolContext,
    group_identifier: Annotated[
        str, "The unique identifier of the group from which the owner will be removed."
    ],
    group_owner_id: Annotated[str, "The ID of the group owner to be removed."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteGroupOwner'."]:
    """Removes a specific group owner from a group.

    This tool should be called when a user needs to delete an owner from a specified group. It removes the association of an owner with a particular group in Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}/owners/{ownerId}".format(  # noqa: UP032
            groupId=group_identifier, ownerId=group_owner_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def list_group_assigned_roles(
    context: ToolContext,
    group_id: Annotated[
        str,
        "The unique identifier for the group whose roles are being retrieved. This ID is required to list the assigned roles for the group.",  # noqa: E501
    ],
    expand_targets: Annotated[
        str | None,
        "Optional parameter to specify targets configured for standard role assignment. Supported values: 'targets/groups' or 'targets/catalog/apps'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listGroupAssignedRoles'."]:
    """Retrieves all roles assigned to a specific group.

    Use this tool to get a list of all roles assigned to a group by providing the group's ID."""
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}/roles".format(groupId=group_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"expand": expand_targets}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def retrieve_group_role_assignment(
    context: ToolContext,
    group_id: Annotated[str, "The unique ID of the group to retrieve the assigned role for."],
    role_assignment_id: Annotated[
        str, "The unique ID of the role assignment to fetch details for a group."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getGroupAssignedRole'."]:
    """Retrieve a role assignment for a specified group.

    Fetches the details of a role assigned to a group using group and role assignment identifiers. Use this to understand the role binding for a specific group in the system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}/roles/{roleAssignmentId}".format(  # noqa: UP032
            groupId=group_id, roleAssignmentId=role_assignment_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def unassign_role_from_group(
    context: ToolContext,
    group_id: Annotated[
        str, "The unique identifier of the group from which the role will be unassigned."
    ],
    role_assignment_id: Annotated[str, "The ID of the role assignment to unassign from a group."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'unassignRoleFromGroup'."]:
    """Unassign a role from a specified group.

    Use this tool to unassign a specific role from a group by providing the roleAssignmentId and groupId. This tool is helpful for managing group roles within an organization."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}/roles/{roleAssignmentId}".format(  # noqa: UP032
            groupId=group_id, roleAssignmentId=role_assignment_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def list_app_targets_for_group_app_admin(
    context: ToolContext,
    group_id: Annotated[str, "The unique identifier of the group for which to list app targets."],
    role_assignment_id: Annotated[
        str,
        "The identifier for the role assignment to a group. Use this to specify the role for which app targets are listed.",  # noqa: E501
    ],
    pagination_cursor: Annotated[
        str | None,
        "The cursor for pagination indicating current position in the list, obtained from the `Link` header.",  # noqa: E501
    ] = None,
    max_number_of_objects_returned: Annotated[
        int | None, "Specifies the maximum number of application targets to return in the response."
    ] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'listApplicationTargetsForApplicationAdministratorRoleForGroup'.",  # noqa: E501
]:
    """Retrieve app targets for APP_ADMIN group role assignments.

    Use this tool to list all application targets for a specific application's administrative role assigned to a group. It returns a list of either OIN-cataloged apps or specific app instances associated with the role within the group."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}/roles/{roleAssignmentId}/targets/catalog/apps".format(  # noqa: UP032
            groupId=group_id, roleAssignmentId=role_assignment_id
        ),
        method="GET",
        params=remove_none_values({
            "after": pagination_cursor,
            "limit": max_number_of_objects_returned,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def assign_app_target_to_admin_role(
    context: ToolContext,
    group_id: Annotated[str, "The unique identifier of the group to assign the app target to."],
    role_assignment_id: Annotated[
        str, "The unique identifier for the role assignment to which the app target is to be added."
    ],
    app_name: Annotated[
        str, "Name of the app definition from the OIN catalog, used as the key name."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'assignAppTargetToAdminRoleForGroup'."
]:
    """Assign an app target to a group's admin role.

    Use this tool to assign an OIN app target to the \"APP_ADMIN\" role for a group, reducing the role's scope to the specified app target. This action overrides any existing specific role assignments for that app."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}/roles/{roleAssignmentId}/targets/catalog/apps/{appName}".format(  # noqa: UP032
            groupId=group_id, roleAssignmentId=role_assignment_id, appName=app_name
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def unassign_app_target_from_admin_role(
    context: ToolContext,
    group_id: Annotated[
        str, "The unique identifier of the group from which the app target is unassigned."
    ],
    role_assignment_id: Annotated[
        str, "The ID of the role assignment to be unassigned from the group."
    ],
    app_name: Annotated[
        str, "Name of the app definition, corresponding to the OIN catalog app key name."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'unassignAppTargetToAdminRoleForGroup'."
]:
    """Unassign an app target from an admin role for a group.

    Use this tool to remove an OIN app target from an `APP_ADMIN` role assigned to a group in Okta. Note: You can't remove the last app target from a role assignment. If needed, delete the entire `APP_ADMIN` role and create a new one for all apps."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}/roles/{roleAssignmentId}/targets/catalog/apps/{appName}".format(  # noqa: UP032
            groupId=group_id, roleAssignmentId=role_assignment_id, appName=app_name
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def assign_app_instance_to_admin_role(
    context: ToolContext,
    group_id: Annotated[
        str, "The unique identifier of the group to which the app instance will be assigned."
    ],
    role_assignment_id: Annotated[
        str,
        "The `id` of the role assignment to which the app instance is being assigned. Required for scoping the admin role to the specific app instance.",  # noqa: E501
    ],
    app_name: Annotated[
        str,
        "Name of the app definition from the OIN catalog. This key identifies the specific app.",
    ],
    application_id: Annotated[
        str,
        "The unique identifier of the application to which the admin role will be assigned for the group.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'assignAppInstanceTargetToAppAdminRoleForGroup'.",
]:
    """Assign an app instance to a group admin role in Okta.

    Use this tool to assign a specific app instance to an `APP_ADMIN` role for a group in Okta. This action scopes the role assignment to the specified app instance, rather than applying it broadly to all apps. It is useful when you need to manage specific applications or configurations for a group."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}/roles/{roleAssignmentId}/targets/catalog/apps/{appName}/{appId}".format(  # noqa: UP032
            groupId=group_id,
            roleAssignmentId=role_assignment_id,
            appName=app_name,
            appId=application_id,
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def unassign_app_instance_role_group(
    context: ToolContext,
    group_id: Annotated[
        str,
        "The unique identifier of the group from which the app instance target will be unassigned.",
    ],
    role_assignment_id: Annotated[
        str, "The ID of the role assignment to be unassigned from the group."
    ],
    app_name: Annotated[
        str, "Name of the app definition from the OIN catalog used to identify the app instance."
    ],
    application_id: Annotated[
        str, "The unique identifier for the application to be unassigned from the group role."
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'unassignAppInstanceTargetToAppAdminRoleForGroup'.",
]:
    """Unassign an app instance target from a group's APP_ADMIN role.

    Use this tool to remove an app instance target from a group's APP_ADMIN role assignment. Note that this operation cannot remove the last app instance target. For a role assignment that applies to all apps, delete the role assignment instead."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}/roles/{roleAssignmentId}/targets/catalog/apps/{appName}/{appId}".format(  # noqa: UP032
            groupId=group_id,
            roleAssignmentId=role_assignment_id,
            appName=app_name,
            appId=application_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def list_group_targets_for_role(
    context: ToolContext,
    group_id: Annotated[str, "The ID of the group for which to list role assignment targets."],
    role_assignment_id: Annotated[
        str, "The unique identifier of the role assignment for which group targets are listed."
    ],
    pagination_cursor: Annotated[
        str | None,
        "The cursor for pagination, specifying the current location in the list. It is an opaque string obtained from the 'Link' response header.",  # noqa: E501
    ] = None,
    max_number_of_objects: Annotated[
        int | None, "Specify the maximum number of group targets to return."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listGroupTargetsForGroupRole'."]:
    """Retrieve group targets for specific role assignments to a group.

    Use this tool to get all group targets associated with a `USER_ADMIN`, `HELP_DESK_ADMIN`, or `GROUP_MEMBERSHIP_ADMIN` role assigned to a group. If no specific targets are scoped, the response will be an empty list."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}/roles/{roleAssignmentId}/targets/groups".format(  # noqa: UP032
            groupId=group_id, roleAssignmentId=role_assignment_id
        ),
        method="GET",
        params=remove_none_values({"after": pagination_cursor, "limit": max_number_of_objects}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def assign_group_target_to_role(
    context: ToolContext,
    group_id: Annotated[
        str, "The unique identifier for the group to which the role target is assigned."
    ],
    role_assignment_id: Annotated[
        str,
        "The unique identifier for the role assignment to which the group target is being assigned.",  # noqa: E501
    ],
    target_group_id: Annotated[
        str,
        "The ID of the group to be set as the target, narrowing the role scope to this group only.",
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'assignGroupTargetToGroupAdminRole'."
]:
    """Assign a group target to specific admin roles.

    Use this tool to assign a group target to a USER_ADMIN, HELP_DESK_ADMIN, or GROUP_MEMBERSHIP_ADMIN role for a specific group. It limits the role's scope to the specified target, removing its previous global application."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}/roles/{roleAssignmentId}/targets/groups/{targetGroupId}".format(  # noqa: UP032
            groupId=group_id, roleAssignmentId=role_assignment_id, targetGroupId=target_group_id
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def unassign_group_admin_role(
    context: ToolContext,
    group_id: Annotated[
        str, "The unique identifier of the group from which an admin role is being unassigned."
    ],
    role_assignment_id: Annotated[str, "The ID of the role assignment to unassign from the group."],
    target_group_id: Annotated[
        str, "The unique identifier of the group target to be unassigned from the admin role."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'unassignGroupTargetFromGroupAdminRole'."
]:
    """Unassign a group target from an admin role.

    Remove a group target from admin roles such as USER_ADMIN, HELP_DESK_ADMIN, or GROUP_MEMBERSHIP_ADMIN assigned to a group."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}/roles/{roleAssignmentId}/targets/groups/{targetGroupId}".format(  # noqa: UP032
            groupId=group_id, roleAssignmentId=role_assignment_id, targetGroupId=target_group_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.groups.read"]))
async def list_group_users(
    context: ToolContext,
    group_id: Annotated[str, "The unique identifier of the group whose members you want to list."],
    pagination_cursor: Annotated[
        str | None,
        "The cursor for pagination, obtained from the `Link` header indicating the current location in the list.",  # noqa: E501
    ] = None,
    page_user_limit: Annotated[
        int | None,
        "Specifies the maximum number of user results returned per page. Recommended limit is 200.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listGroupUsers'."]:
    """Retrieve users from a specified group in Okta.

    Use this tool to get a list of users who are members of a specific group in Okta. Suitable for managing group memberships and auditing user lists within an organization."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}/users".format(groupId=group_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"after": pagination_cursor, "limit": page_user_limit}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.groups.manage"]))
async def assign_user_to_group(
    context: ToolContext,
    group_id: Annotated[
        str, "The unique identifier for the OKTA_GROUP to which the user will be assigned."
    ],
    okta_user_id: Annotated[str, "ID of an existing Okta user to be assigned to the group."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'assignUserToGroup'."]:
    """Assign a user to a specified OKTA_GROUP.

    Use this tool to assign a user to a specific group of type `OKTA_GROUP` within Okta. This operation is only applicable for `OKTA_GROUP` type groups and is important for managing user memberships. Note that app imports handle memberships for `APP_GROUP` type groups, such as Active Directory."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}/users/{userId}".format(  # noqa: UP032
            groupId=group_id, userId=okta_user_id
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.groups.manage"]))
async def remove_user_from_okta_group(
    context: ToolContext,
    group_id: Annotated[
        str,
        "The ID of the OKTA group. Required to specify which group the user will be removed from.",
    ],
    user_id: Annotated[str, "The ID of an existing Okta user to be removed from the group."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'unassignUserFromGroup'."]:
    """Remove a user from an OKTA group.

    Use this tool to unassign a user from a specified OKTA group. It only works with groups of the 'OKTA_GROUP' type. This action cannot be performed on 'APP_GROUP' types, such as Active Directory groups."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/groups/{groupId}/users/{userId}".format(  # noqa: UP032
            groupId=group_id, userId=user_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.inlineHooks.read"]))
async def list_hook_keys(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listHookKeys'."]:
    """Retrieve all hook keys from the API.

    This tool is used to call the Okta API endpoint that lists all available hook keys. It should be called when you need to obtain a complete list of hook keys for management or integration purposes."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/hook-keys",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.inlineHooks.read"]))
async def retrieve_public_key(
    context: ToolContext,
    public_key_id: Annotated[
        str,
        "The unique identifier for the public key to retrieve. This is used for obtaining the specific public key details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPublicKey'."]:
    """Retrieve a public key by its keyId.

    Use the tool to obtain the public key details associated with a specified keyId. This is useful for validating signatures or for other security operations requiring the public key."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/hook-keys/public/{keyId}".format(keyId=public_key_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.inlineHooks.read"]))
async def retrieve_hook_key(
    context: ToolContext,
    key_id: Annotated[
        str | None, "A valid key ID to retrieve the public portion of the Key object."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getHookKey'."]:
    """Retrieve the public portion of a Key object by ID.

    Use this tool to obtain the public portion of a Key object using the specified ID. Optionally, you can expand the response to include full details of the public key."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/hook-keys/{id}".format(id=key_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.inlineHooks.manage"]))
async def delete_hook_key(
    context: ToolContext,
    hook_key_id: Annotated[
        str, "The unique identifier for the hook key to be deleted. Ensure the key is unused."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteHookKey'."]:
    """Delete an unused hook key by ID.

    Use this tool to permanently delete a hook key by its ID. Only keys that are not in use can be deleted. Once deleted, a key cannot be recovered."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/hook-keys/{id}".format(id=hook_key_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def list_users_with_roles(
    context: ToolContext,
    pagination_cursor: Annotated[
        str | None,
        "Specifies the pagination cursor for retrieving the next page of users with roles.",
    ] = None,
    results_limit: Annotated[
        int | None,
        "Specifies the maximum number of user results to return. Defaults to 100 if not set.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listUsersWithRoleAssignments'."]:
    """Lists all users with their role assignments.

    Use this tool to retrieve a list of users along with their assigned roles. This can be useful for managing user permissions and roles within an organization."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/assignees/users",
        method="GET",
        params=remove_none_values({"after": pagination_cursor, "limit": results_limit}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def list_governance_bundles(
    context: ToolContext,
    pagination_cursor: Annotated[
        str | None,
        "The cursor string for pagination, obtained from the `Link` response header, to specify the current location in the list.",  # noqa: E501
    ] = None,
    object_limit: Annotated[
        int | None,
        "Specify the maximum number of governance bundles to return. This helps in controlling the size of the response.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listGovernanceBundles'."]:
    """Retrieve all Governance Bundles for your organization's Admin Console.

    Use this tool to access a list of all Governance Bundles available in your organization's Admin Console. This is useful for administrators who need to manage or review available governance resources."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/governance/bundles",
        method="GET",
        params=remove_none_values({"after": pagination_cursor, "limit": object_limit}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def retrieve_governance_bundle(
    context: ToolContext,
    bundle_id: Annotated[str, "The unique identifier of the Governance Bundle to retrieve."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getGovernanceBundle'."]:
    """Retrieve a Governance Bundle from Okta RAMP.

    Use this tool to fetch information about a specific Governance Bundle from Okta's RAMP service using the bundle ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/governance/bundles/{bundleId}".format(  # noqa: UP032
            bundleId=bundle_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def delete_governance_bundle(
    context: ToolContext,
    bundle_id: Annotated[
        str, "The unique identifier of a governance bundle to delete from RAMP in Okta."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteGovernanceBundle'."]:
    """Deletes a Governance Bundle from RAMP in Okta.

    Use this tool to delete a specific governance bundle by its ID from Okta's RAMP. This is useful when a bundle is no longer needed or needs to be removed for compliance reasons."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/governance/bundles/{bundleId}".format(  # noqa: UP032
            bundleId=bundle_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def list_governance_bundle_entitlements(
    context: ToolContext,
    bundle_id: Annotated[
        str, "The ID of the governance bundle whose entitlements you want to list."
    ],
    pagination_cursor: Annotated[
        str | None,
        "The opaque cursor string for pagination, indicating the current position in the list. Obtainable from the `Link` response header.",  # noqa: E501
    ] = None,
    max_objects_to_return: Annotated[
        int | None,
        "Specifies the maximum number of entitlements to return in the response. Use to limit the results.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listBundleEntitlements'."]:
    """Retrieve entitlements for a specific governance bundle.

    Use this tool to obtain a list of all entitlements associated with a specific governance bundle in Okta. It is useful when you need to review or manage the entitlements tied to a particular bundle."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/governance/bundles/{bundleId}/entitlements".format(  # noqa: UP032
            bundleId=bundle_id
        ),
        method="GET",
        params=remove_none_values({"after": pagination_cursor, "limit": max_objects_to_return}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def list_entitlement_values(
    context: ToolContext,
    bundle_id: Annotated[
        str,
        "The ID of the bundle to retrieve entitlement values for. This is required to specify which bundle you are querying.",  # noqa: E501
    ],
    bundle_entitlement_id: Annotated[
        str, "The ID of the bundle entitlement for which to retrieve entitlement values."
    ],
    pagination_cursor: Annotated[
        str | None,
        "The cursor for pagination, indicating your current position in the list. Obtainable from the `Link` response header.",  # noqa: E501
    ] = None,
    max_results_to_return: Annotated[
        int | None,
        "Sets the maximum number of entitlement values to return in the response. Use to limit the returned data size.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listBundleEntitlementValues'."]:
    """Retrieve entitlement values for a specified bundle.

    Use this tool to get all entitlement values linked to a particular bundle entitlement. It is useful for accessing detailed governance information."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/governance/bundles/{bundleId}/entitlements/{entitlementId}/values".format(  # noqa: UP032
            bundleId=bundle_id, entitlementId=bundle_entitlement_id
        ),
        method="GET",
        params=remove_none_values({"after": pagination_cursor, "limit": max_results_to_return}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def retrieve_admin_console_opt_in_status(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOptInStatus'."]:
    """Retrieve the Admin Console opt-in status from RAMP.

    Use this tool to check the opt-in status of the Admin Console via the RAMP service."""
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/governance/optIn",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def opt_in_admin_console_ramp(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'optIn'."]:
    """Opt in the Admin Console to RAMP in Okta.

    This tool opts in the Admin Console to RAMP using Okta's API. Call this tool when you need to enable RAMP in the Admin Console."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/governance/optIn",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def opt_out_admin_console_ramp(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'optOut'."]:
    """Opt out the Admin Console from RAMP.

    This tool should be called to opt the Admin Console out of RAMP. Use this when you need to discontinue the RAMP service for the Admin Console."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/governance/optOut",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def list_resource_sets(
    context: ToolContext,
    pagination_cursor: Annotated[
        str | None,
        "The opaque cursor string for pagination, obtained from the `Link` response header.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listResourceSets'."]:
    """Retrieve all resource sets with pagination support.

    This tool calls the Okta API to list all resource sets, including pagination information. Use it to fetch comprehensive details about existing resource sets in your organization."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/resource-sets",
        method="GET",
        params=remove_none_values({"after": pagination_cursor}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def retrieve_resource_set_okta(
    context: ToolContext,
    resource_set_identifier: Annotated[
        str, "The ID or label of the resource set to retrieve from Okta."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getResourceSet'."]:
    """Retrieve a resource set by its ID or label from Okta.

    This tool is used to fetch details of a specific resource set from Okta using a resource set ID or label. It should be called when information about a particular resource set is needed."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/resource-sets/{resourceSetIdOrLabel}".format(  # noqa: UP032
            resourceSetIdOrLabel=resource_set_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def delete_resource_set(
    context: ToolContext,
    resource_set_identifier: Annotated[str, "The ID or label of the resource set to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteResourceSet'."]:
    """Deletes a resource set by ID or label.

    Use this tool to delete a specific resource set from the system by providing the resource set's ID or label. It is useful for managing and organizing resource allocations within the platform."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/resource-sets/{resourceSetIdOrLabel}".format(  # noqa: UP032
            resourceSetIdOrLabel=resource_set_identifier
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def list_resource_set_bindings(
    context: ToolContext,
    resource_set_id_or_label: Annotated[
        str, "The ID or label of the resource set to list bindings for."
    ],
    pagination_cursor: Annotated[
        str | None,
        "A string cursor for pagination, specifying the current position in the list. Obtained from the `Link` response header.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listBindings'."]:
    """Retrieve all bindings and roles for a specified resource set.

    Use this tool to list all bindings associated with a specified resource set in Okta. It supports pagination if there are more than 100 bindings. Useful for managing access and roles in a resource set."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/resource-sets/{resourceSetIdOrLabel}/bindings".format(  # noqa: UP032
            resourceSetIdOrLabel=resource_set_id_or_label
        ),
        method="GET",
        params=remove_none_values({"after": pagination_cursor}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def get_role_binding_for_resource(
    context: ToolContext,
    resource_set_identifier_or_label: Annotated[
        str,
        "The ID or label of the resource set to retrieve the role binding for. This identifies the specific resource set in the IAM system.",  # noqa: E501
    ],
    role_id_or_label: Annotated[
        str,
        "The ID or label of the role to retrieve the binding for. This identifies the specific role in the system.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getBinding'."]:
    """Retrieve a role binding for a specified resource set.

    Use this tool to get the binding details of a specific role for a given resource set by their identifiers or labels. This is useful for managing and reviewing access permissions in an IAM system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/resource-sets/{resourceSetIdOrLabel}/bindings/{roleIdOrLabel}".format(  # noqa: UP032
            resourceSetIdOrLabel=resource_set_identifier_or_label, roleIdOrLabel=role_id_or_label
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def delete_role_binding(
    context: ToolContext,
    resource_set_id_or_label: Annotated[
        str, "The `id` or `label` of the resource set to be unbound from the role."
    ],
    role_id_or_label: Annotated[
        str, "The identifier or label of the role to unbind from the resource set."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteBinding'."]:
    """Deletes a binding between a role and a resource set.

    Use this tool to remove the association between a specific role and a resource set in Okta by providing the role and resource set identifiers."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/resource-sets/{resourceSetIdOrLabel}/bindings/{roleIdOrLabel}".format(  # noqa: UP032
            resourceSetIdOrLabel=resource_set_id_or_label, roleIdOrLabel=role_id_or_label
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def list_role_resource_members(
    context: ToolContext,
    resource_set_id_or_label: Annotated[
        str, "The ID or label of the resource set to list members from."
    ],
    role_identifier: Annotated[
        str,
        "The ID or label of the role to list members for. It helps specify the role resource set binding.",  # noqa: E501
    ],
    pagination_cursor: Annotated[
        str | None,
        "The opaque cursor string for pagination, indicating your current position in the list. Obtain this from the `Link` response header.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listMembersOfBinding'."]:
    """List all members of a role resource set binding.

    This tool retrieves all members associated with a specified role resource set binding, supporting pagination for large datasets."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/resource-sets/{resourceSetIdOrLabel}/bindings/{roleIdOrLabel}/members".format(  # noqa: UP032
            resourceSetIdOrLabel=resource_set_id_or_label, roleIdOrLabel=role_identifier
        ),
        method="GET",
        params=remove_none_values({"after": pagination_cursor}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def retrieve_role_member(
    context: ToolContext,
    resource_set_identifier: Annotated[
        str,
        "The `id` or `label` of the resource set to identify which set to retrieve the member from.",  # noqa: E501
    ],
    role_id_or_label: Annotated[
        str, "The `id` or `label` of the role to identify which role the member belongs to."
    ],
    member_id: Annotated[str, "ID of the member to look up in the role resource set binding."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getMemberOfBinding'."]:
    """Retrieve member details in a role resource set binding.

    This tool retrieves information about a specific member identified by `memberId` within a role resource set binding using the given resource set and role identifiers. It should be called when you need details about a member's role or permissions in a resource set."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/resource-sets/{resourceSetIdOrLabel}/bindings/{roleIdOrLabel}/members/{memberId}".format(  # noqa: UP032
            resourceSetIdOrLabel=resource_set_identifier,
            roleIdOrLabel=role_id_or_label,
            memberId=member_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def unassign_member_from_role(
    context: ToolContext,
    resource_set_id_or_label: Annotated[
        str, "The `id` or `label` of the resource set to unassign a member from a role."
    ],
    role_identifier_or_label: Annotated[
        str, "Provide the ID or label of the role for unassignment."
    ],
    member_id: Annotated[
        str, "The unique identifier for the member to be unassigned from the role."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'unassignMemberFromBinding'."]:
    """Unassign a member from a role resource set binding.

    Use this tool to remove a member from a specific role resource set binding in Okta by providing the member ID, role ID, and resource set ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/resource-sets/{resourceSetIdOrLabel}/bindings/{roleIdOrLabel}/members/{memberId}".format(  # noqa: UP032
            resourceSetIdOrLabel=resource_set_id_or_label,
            roleIdOrLabel=role_identifier_or_label,
            memberId=member_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def list_resource_set_resources(
    context: ToolContext,
    resource_set_id_or_label: Annotated[
        str, "The ID or label of the resource set to list resources for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listResourceSetResources'."]:
    """Lists all resources for a specified resource set in Okta.

    Use this tool to retrieve all resources associated with a specific resource set in Okta, identified by the resource set ID or label."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/resource-sets/{resourceSetIdOrLabel}/resources".format(  # noqa: UP032
            resourceSetIdOrLabel=resource_set_id_or_label
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def retrieve_resource_set_details(
    context: ToolContext,
    resource_set_identifier: Annotated[
        str, "The ID or label of the resource set to retrieve the resource from."
    ],
    resource_identifier: Annotated[
        str, "The unique ID of the resource to be retrieved from the resource set."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getResourceSetResource'."]:
    """Retrieve details of a resource in a specific resource set.

    Use this tool to obtain details about a specific resource within a resource set using the resource ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/resource-sets/{resourceSetIdOrLabel}/resources/{resourceId}".format(  # noqa: UP032
            resourceSetIdOrLabel=resource_set_identifier, resourceId=resource_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def delete_resource_from_set(
    context: ToolContext,
    resource_set_id_or_label: Annotated[
        str, "Provide the id or label of the resource set from which to delete the resource."
    ],
    resource_id: Annotated[
        str, "The unique ID of the resource to be deleted from the specified resource set."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteResourceSetResource'."]:
    """Delete a resource from a specified resource set.

    Use this tool to delete a specific resource from a resource set identified by its ID or label in Okta. Ideal for managing and updating resource allocations efficiently."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/resource-sets/{resourceSetIdOrLabel}/resources/{resourceId}".format(  # noqa: UP032
            resourceSetIdOrLabel=resource_set_id_or_label, resourceId=resource_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def list_custom_roles(
    context: ToolContext,
    pagination_cursor: Annotated[
        str | None,
        "The cursor for pagination, an opaque string indicating your current location in the list. Obtained from the `Link` response header.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listRoles'."]:
    """Retrieve a paginated list of all custom roles.

    Use this tool to fetch and view all custom roles available in the system, with support for pagination to manage large sets of data."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/roles",
        method="GET",
        params=remove_none_values({"after": pagination_cursor}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def retrieve_okta_role(
    context: ToolContext,
    role_id_or_label: Annotated[str, "The ID or label of the role to retrieve details from Okta."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getRole'."]:
    """Retrieve role details from Okta using role ID or label.

    This tool is used to obtain detailed information about a specific role from Okta by providing either the role ID or its label. Use this tool when you need to access role specifications, permissions, or other role-related data within Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/roles/{roleIdOrLabel}".format(  # noqa: UP032
            roleIdOrLabel=role_id_or_label
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def delete_custom_role(
    context: ToolContext,
    role_id_or_label: Annotated[
        str, "The ID or label of the custom role to delete in the Okta system."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteRole'."]:
    """Delete a custom role using its role ID or label.

    Use this tool to delete a custom role in the Okta system by specifying the role ID or label. This tool is helpful for managing role configurations and ensuring only required roles exist."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/roles/{roleIdOrLabel}".format(  # noqa: UP032
            roleIdOrLabel=role_id_or_label
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def list_custom_role_permissions(
    context: ToolContext,
    role_identifier: Annotated[
        str, "The ID or label of the custom role to retrieve permissions for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listRolePermissions'."]:
    """Retrieve permissions for a specified custom role.

    Use this tool to list all permissions associated with a specific custom role in Okta by providing the role ID or label."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/roles/{roleIdOrLabel}/permissions".format(  # noqa: UP032
            roleIdOrLabel=role_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def retrieve_role_permission(
    context: ToolContext,
    role_id_or_label: Annotated[
        str, "Identifier or label of the custom role to retrieve permission for."
    ],
    permission_type: Annotated[
        str, "Specify the type of permission to retrieve for a custom role in Okta."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getRolePermission'."]:
    """Retrieve a specific permission for a custom role by type.

    Use this tool to obtain details about a specific permission associated with a custom role in Okta, identified by the permission type."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/roles/{roleIdOrLabel}/permissions/{permissionType}".format(  # noqa: UP032
            roleIdOrLabel=role_id_or_label, permissionType=permission_type
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def remove_role_permission(
    context: ToolContext,
    role_identifier: Annotated[
        str, "The `id` or `label` of the Okta role from which the permission will be removed."
    ],
    permission_type: Annotated[
        str,
        "Specify the type of Okta permission to remove from the custom role. It should match the defined permissions in Okta.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteRolePermission'."]:
    """Remove a permission from a custom role in Okta.

    Use this tool to delete a specific permission from a custom role in Okta by specifying the role and permission type."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/iam/roles/{roleIdOrLabel}/permissions/{permissionType}".format(  # noqa: UP032
            roleIdOrLabel=role_identifier, permissionType=permission_type
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.identitySources.read"]))
async def list_identity_source_sessions(
    context: ToolContext,
    identity_source_id: Annotated[
        str, "The ID of the identity source instance to list sessions for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listIdentitySourceSessions'."]:
    """Retrieve sessions for a specific identity source instance.

    This tool lists all identity source sessions for a specified identity source ID. It should be used to monitor or audit sessions associated with a particular identity source instance."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/identity-sources/{identitySourceId}/sessions".format(  # noqa: UP032
            identitySourceId=identity_source_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.identitySources.manage"]))
async def create_identity_source_session(
    context: ToolContext,
    identity_source_id: Annotated[
        str, "The unique ID of the identity source to create a session for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createIdentitySourceSession'."]:
    """Create a session for an identity source instance.

    This tool creates an identity source session for a specified identity source instance, allowing further authenticated interactions with that source."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/identity-sources/{identitySourceId}/sessions".format(  # noqa: UP032
            identitySourceId=identity_source_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.identitySources.read"]))
async def retrieve_identity_source_session(
    context: ToolContext,
    identity_source_id: Annotated[
        str,
        "The ID of the identity source for which the session is created. This ID is used to specify which identity source's session details are to be retrieved.",  # noqa: E501
    ],
    identity_source_session_id: Annotated[
        str, "The ID used to identify the specific identity source session."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getIdentitySourceSession'."]:
    """Retrieve an identity source session by ID and session.

    This tool fetches session details for a specified identity source and session ID, helping manage authentication and identity processes."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/identity-sources/{identitySourceId}/sessions/{sessionId}".format(  # noqa: UP032
            identitySourceId=identity_source_id, sessionId=identity_source_session_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.identitySources.manage"]))
async def delete_identity_source_session(
    context: ToolContext,
    identity_source_id: Annotated[
        str, "The ID of the identity source for which the session is created."
    ],
    identity_source_session_id: Annotated[
        str, "The ID of the identity source session to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteIdentitySourceSession'."]:
    """Deletes an identity source session by ID.

    Call this tool to delete a specific identity source session using the session's and the identity source's IDs."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/identity-sources/{identitySourceId}/sessions/{sessionId}".format(  # noqa: UP032
            identitySourceId=identity_source_id, sessionId=identity_source_session_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.identitySources.manage"]))
async def initiate_identity_import(
    context: ToolContext,
    identity_source_id: Annotated[
        str, "The ID of the identity source to start the import session for."
    ],
    identity_source_session_id: Annotated[
        str, "The ID of the identity source session to initiate the import process."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'startImportFromIdentitySource'."]:
    """Initiate import from a specified identity source.

    Use this tool to start the import process from an identity source specified by the uploaded bulk operations. Useful for syncing identity data into the system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/identity-sources/{identitySourceId}/sessions/{sessionId}/start-import".format(  # noqa: UP032
            identitySourceId=identity_source_id, sessionId=identity_source_session_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.read"]))
async def list_identity_providers(
    context: ToolContext,
    search_identity_provider_name: Annotated[
        str | None, "Search for matching identity provider names in the list."
    ] = None,
    pagination_cursor: Annotated[
        str | None, "The cursor to use for pagination, obtained from the `Link` response header."
    ] = None,
    object_limit: Annotated[
        int | None, "Specify the maximum number of identity provider objects to return."
    ] = None,
    filter_by_idp_type: Annotated[
        str | None,
        "Specify the type of IdP to filter the list. Options include providers like 'GOOGLE', 'FACEBOOK', etc.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listIdentityProviders'."]:
    """Retrieve a list of all identity provider integrations.

    This tool retrieves all identity provider (IdP) integrations from Okta, with support for filtering and pagination. Use this tool to obtain information about connected IdPs."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps",
        method="GET",
        params=remove_none_values({
            "q": search_identity_provider_name,
            "after": pagination_cursor,
            "limit": object_limit,
            "type": filter_by_idp_type,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.read"]))
async def list_identity_provider_keys(
    context: ToolContext,
    pagination_cursor: Annotated[
        str | None,
        "Cursor for pagination, specifying current location in the list; obtained from the `Link` response header.",  # noqa: E501
    ] = None,
    maximum_number_of_objects_to_return: Annotated[
        int | None, "Sets the maximum number of IdP key credentials to retrieve."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listIdentityProviderKeys'."]:
    """Retrieve all identity provider key credentials.

    Use this tool to obtain a list of all identity provider (IdP) key credentials. This is useful for managing and reviewing authentication setups."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/credentials/keys",
        method="GET",
        params=remove_none_values({
            "after": pagination_cursor,
            "limit": maximum_number_of_objects_to_return,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.read"]))
async def retrieve_identity_provider_key(
    context: ToolContext,
    identity_provider_key_id: Annotated[
        str,
        "The unique identifier (`kid`) of the identity provider key credential needed to retrieve its details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getIdentityProviderKey'."]:
    """Retrieve a specific IdP key credential by `kid`.

    Use this tool to obtain details of an identity provider key credential by providing the `kid` (key ID). This is useful for managing and auditing identity provider configurations."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/credentials/keys/{kid}".format(  # noqa: UP032
            kid=identity_provider_key_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.manage"]))
async def delete_idp_key(
    context: ToolContext,
    idp_key_id: Annotated[
        str, "Unique ID of the IdP key credential to be deleted. Ensure it's not in use by any IdP."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteIdentityProviderKey'."]:
    """Delete an unused identity provider key by ID.

    Use this tool to delete a specific identity provider key credential by its key ID if it's not being used by any active or inactive IdPs."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/credentials/keys/{kid}".format(kid=idp_key_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.read"]))
async def retrieve_identity_provider(
    context: ToolContext,
    identity_provider_id: Annotated[
        str, "The unique ID of the identity provider (IdP) to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getIdentityProvider'."]:
    """Retrieves an identity provider integration by ID.

    Use this tool to retrieve details about a specific identity provider (IdP) integration using its unique ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/{idpId}".format(idpId=identity_provider_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.manage"]))
async def delete_identity_provider(
    context: ToolContext,
    identity_provider_id: Annotated[
        str, "The unique identifier for the identity provider to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteIdentityProvider'."]:
    """Delete an identity provider integration by ID.

    This tool deletes an identity provider (IdP) integration using the specified `idpId`. Upon deletion, all existing IdP users are unlinked, with the highest order profile source taking precedence for each user. Unlinked users retain their current authentication provider, such as `FEDERATION` or `SOCIAL`."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/{idpId}".format(idpId=identity_provider_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.read"]))
async def list_idp_certificate_signing_requests(
    context: ToolContext,
    identity_provider_id: Annotated[str, "The ID of the Identity Provider to retrieve CSRs for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listCsrsForIdentityProvider'."]:
    """Retrieve CSRs for a given identity provider from Okta."""
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/{idpId}/credentials/csrs".format(  # noqa: UP032
            idpId=identity_provider_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.read"]))
async def get_identity_provider_csr(
    context: ToolContext,
    identity_provider_id: Annotated[str, "The unique identifier of the Identity Provider (IdP)."],
    identity_provider_csr_id: Annotated[
        str,
        "The ID of the Identity Provider's CSR used to retrieve the specific certificate signing request.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCsrForIdentityProvider'."]:
    """Retrieve CSR for a specific Identity Provider.

    Use this tool to fetch a specific certificate signing request (CSR) using the ID and CSR ID of an Identity Provider."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/{idpId}/credentials/csrs/{idpCsrId}".format(  # noqa: UP032
            idpId=identity_provider_id, idpCsrId=identity_provider_csr_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.manage"]))
async def revoke_identity_provider_csr(
    context: ToolContext,
    identity_provider_id: Annotated[str, "The unique identifier for the identity provider (IdP)."],
    identity_provider_csr_id: Annotated[
        str, "The unique identifier for the CSR of the identity provider that needs to be revoked."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'revokeCsrForIdentityProvider'."]:
    """Revoke a CSR and delete key pair from an IdP.

    This tool revokes a certificate signing request and deletes the associated key pair from a specified identity provider. It should be used when you need to remove an IdP's CSR and its keys from the system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/{idpId}/credentials/csrs/{idpCsrId}".format(  # noqa: UP032
            idpId=identity_provider_id, idpCsrId=identity_provider_csr_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.manage"]))
async def publish_csr_certificate(
    context: ToolContext,
    identity_provider_id: Annotated[
        str, "The unique `id` of the Identity Provider (IdP) for which the CSR is being published."
    ],
    identity_provider_csr_id: Annotated[
        str, "The unique identifier for the Identity Provider's Certificate Signing Request (CSR)."
    ],
    signed_x509_certificate: Annotated[
        str, "The signed X.509 certificate in string format to be published for the CSR."
    ],
    signed_certificate_x509: Annotated[
        str, "A string containing the signed X.509 certificate to be published for the IdP CSR."
    ],
    certificate_content: Annotated[
        str, "The signed X.509 certificate content in string format to publish for the IdP CSR."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'publishCsrForIdentityProvider'."]:
    """Publishes a signed X.509 certificate for an IdP CSR.

    Use this tool to complete the certificate signing request lifecycle by publishing a signed X.509 certificate for an identity provider (IdP). Note that once published, the CSR is no longer accessible. Publishing will fail if the certificate validity is under 90 days."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/{idpId}/credentials/csrs/{idpCsrId}/lifecycle/publish".format(  # noqa: UP032
            idpId=identity_provider_id, idpCsrId=identity_provider_csr_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({"requestBody": certificate_content}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.read"]))
async def list_idp_signing_keys(
    context: ToolContext,
    identity_provider_id: Annotated[
        str,
        "The unique identifier for the identity provider (IdP) whose signing keys are to be listed.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listIdentityProviderSigningKeys'."]:
    """Retrieve signing key credentials for an identity provider.

    This tool lists all signing key credentials associated with a specific identity provider (IdP). It should be called when there's a need to view or manage the signing keys for authentication or integration purposes."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/{idpId}/credentials/keys".format(  # noqa: UP032
            idpId=identity_provider_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.read"]))
async def list_active_signing_key_credential(
    context: ToolContext,
    identity_provider_id: Annotated[
        str, "The unique identifier of the identity provider (IdP) to retrieve the signing key for."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'listActiveIdentityProviderSigningKey'."
]:
    """Retrieve the active signing key for an identity provider.

    This tool retrieves the active signing key credential for a specified identity provider (IdP) in Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/{idpId}/credentials/keys/active".format(  # noqa: UP032
            idpId=identity_provider_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.manage"]))
async def generate_idp_signing_key(
    context: ToolContext,
    idp_key_credential_expiry_years: Annotated[
        int, "Enter the number of years the IdP certificate should remain valid."
    ],
    identity_provider_id: Annotated[str, "The unique identifier for the identity provider (IdP)."],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'generateIdentityProviderSigningKey'."
]:
    """Generate a new X.509 certificate for IdP signing.

    This tool generates a new X.509 certificate for an identity provider (IdP) signing key, used for signing assertions sent to the IdP. To utilize the new key, update your IdP using the returned key's `kid` in the signing credential."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/{idpId}/credentials/keys/generate".format(  # noqa: UP032
            idpId=identity_provider_id
        ),
        method="POST",
        params=remove_none_values({"validityYears": idp_key_credential_expiry_years}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.read"]))
async def get_idp_signing_key(
    context: ToolContext,
    identity_provider_id: Annotated[str, "The unique identifier for the identity provider (IdP)."],
    key_id: Annotated[str, "Unique identifier of the IdP key credential to retrieve."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getIdentityProviderSigningKey'."]:
    """Retrieve a specific IdP key credential by key ID.

    This tool calls the API to obtain details of a particular identity provider signing key using the provided key ID. It should be called when you need to access specific credential information for identity providers."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/{idpId}/credentials/keys/{kid}".format(  # noqa: UP032
            idpId=identity_provider_id, kid=key_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.manage"]))
async def clone_idp_certificate(
    context: ToolContext,
    target_identity_provider_id: Annotated[
        str, "The `id` of the target identity provider (IdP) where the certificate will be cloned."
    ],
    source_idp_id: Annotated[
        str,
        "The `id` of the source identity provider (IdP) from which the certificate is being cloned.",  # noqa: E501
    ],
    key_credential_id: Annotated[
        str, "Unique ID of the identity provider key credential to clone."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'cloneIdentityProviderKey'."]:
    """Clone an X.509 certificate between identity providers.

    This tool clones an X.509 certificate for an identity provider (IdP) signing key credential from a source IdP to a target IdP. Note that sharing certificates isn't recommended for security reasons, and if the key already exists for the target IdP, a 400 error will be returned."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/{idpId}/credentials/keys/{kid}/clone".format(  # noqa: UP032
            idpId=source_idp_id, kid=key_credential_id
        ),
        method="POST",
        params=remove_none_values({"targetIdpId": target_identity_provider_id}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.manage"]))
async def activate_identity_provider(
    context: ToolContext,
    identity_provider_id: Annotated[
        str, "The unique identifier of the identity provider to be activated."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateIdentityProvider'."]:
    """Activates an inactive identity provider.

    Use this tool to activate an inactive identity provider (IdP) for Okta services."""
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/{idpId}/lifecycle/activate".format(  # noqa: UP032
            idpId=identity_provider_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.manage"]))
async def deactivate_identity_provider(
    context: ToolContext,
    identity_provider_id: Annotated[
        str, "The unique identifier for the identity provider you wish to deactivate."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivateIdentityProvider'."]:
    """Deactivate an active identity provider (IdP).

    Use this tool to deactivate an active identity provider when it's no longer needed or needs to be temporarily disabled."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/{idpId}/lifecycle/deactivate".format(  # noqa: UP032
            idpId=identity_provider_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.read"]))
async def list_idp_linked_users(
    context: ToolContext,
    identity_provider_id: Annotated[
        str,
        "The unique identifier for the identity provider (IdP) whose linked users are to be listed.",  # noqa: E501
    ],
    search_query: Annotated[
        str | None, "A string to search records for matching values in linked user data."
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "The cursor for pagination, an opaque string indicating current list position. Retrieved from `Link` response header.",  # noqa: E501
    ] = None,
    result_limit: Annotated[
        int | None,
        "The maximum number of user records to return. Useful for controlling pagination and large dataset handling.",  # noqa: E501
    ] = None,
    expand_user_data: Annotated[
        str | None,
        "Specify if additional user details should be included in the response. Use the string 'user' to expand user data.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'listIdentityProviderApplicationUsers'."
]:
    """Lists users linked to an identity provider.

    Call this tool to obtain a list of users associated with a specific identity provider. It helps in managing and auditing user access linked with identity providers."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/{idpId}/users".format(idpId=identity_provider_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "q": search_query,
            "after": pagination_cursor,
            "limit": result_limit,
            "expand": expand_user_data,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.read"]))
async def retrieve_idp_user(
    context: ToolContext,
    identity_provider_id: Annotated[
        str, "The ID of the Identity Provider to retrieve the linked user from."
    ],
    okta_user_id: Annotated[
        str, "The unique ID of an existing Okta user to retrieve information for."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getIdentityProviderApplicationUser'."
]:
    """Retrieve a linked identity provider user by ID.

    This tool retrieves a linked identity provider (IdP) user by their ID, useful for accessing detailed IdP user information."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/{idpId}/users/{userId}".format(  # noqa: UP032
            idpId=identity_provider_id, userId=okta_user_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.manage"]))
async def unlink_user_from_identity_provider(
    context: ToolContext,
    identity_provider_id: Annotated[
        str, "The unique identifier for the Identity Provider (IdP) to unlink the user from."
    ],
    okta_user_id: Annotated[
        str, "The unique identifier of an existing Okta user to be unlinked from the IdP."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'unlinkUserFromIdentityProvider'."]:
    """Unlink a user from their identity provider in Okta.

    This tool unlinks an Okta user from their associated identity provider, requiring them to re-link their account upon next federation. Use this when you need to disconnect a user from a specific IdP."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/{idpId}/users/{userId}".format(  # noqa: UP032
            idpId=identity_provider_id, userId=okta_user_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.idps.read"]))
async def get_social_auth_tokens(
    context: ToolContext,
    identity_provider_id: Annotated[
        str, "The ID of the Identity Provider (IdP) for the social authentication."
    ],
    okta_user_id: Annotated[
        str,
        "The Okta user ID for whom to retrieve the social auth tokens. It must be a valid string identifying an existing Okta user.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listSocialAuthTokens'."]:
    """Retrieve tokens from social auth providers via Okta.

    Use this tool to list tokens minted by social authentication providers when a user authenticates using Okta via Social Auth. These tokens can be used by applications to obtain additional user information from the social provider."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/idps/{idpId}/users/{userId}/credentials/tokens".format(  # noqa: UP032
            idpId=identity_provider_id, userId=okta_user_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.inlineHooks.read"]))
async def list_okta_inline_hooks(
    context: ToolContext,
    inline_hook_type: Annotated[
        str | None,
        "Specify one of the supported inline hook types to filter results. Options include user import, token transformation, SAML assertion, telephony provider, password import, and registration.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listInlineHooks'."]:
    """Retrieve all inline hooks or those of a specific type in Okta.

    This tool retrieves all Okta inline hooks or can be used to list inline hooks of a specific type. Supported types include user import, token transformation, SAML assertion, telephony provider, password import, and registration inline hooks."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/inlineHooks",
        method="GET",
        params=remove_none_values({"type": inline_hook_type}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.inlineHooks.read"]))
async def retrieve_inline_hook(
    context: ToolContext,
    inline_hook_id: Annotated[
        str,
        "The ID of the inline hook to retrieve details for. This should be a string representing the unique identifier of the hook.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getInlineHook'."]:
    """Fetches details of a specific inline hook by its ID.

    Use this tool to obtain detailed information about an inline hook specified by its ID. Ideal for scenarios where identification and configuration details of a specific inline hook are required."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/inlineHooks/{inlineHookId}".format(  # noqa: UP032
            inlineHookId=inline_hook_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.inlineHooks.manage"]))
async def delete_inactive_inline_hook(
    context: ToolContext,
    inline_hook_id: Annotated[
        str,
        "The unique identifier of the inline hook to be deleted. Ensure the hook is inactive before deletion.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteInlineHook'."]:
    """Delete an inactive inline hook in Okta.

    Use this tool to permanently delete an inline hook from Okta, provided it is in an inactive state. Once deleted, the hook cannot be recovered, so ensure the status is 'INACTIVE' before proceeding."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/inlineHooks/{inlineHookId}".format(  # noqa: UP032
            inlineHookId=inline_hook_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.inlineHooks.manage"]))
async def activate_inline_hook(
    context: ToolContext,
    inline_hook_id: Annotated[str, "The ID of the inline hook to activate in Okta."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateInlineHook'."]:
    """Activates a specified inline hook in Okta by its ID.

    Use this tool to activate an inline hook in Okta by providing the inlineHookId. This is typically used when you need to enable a specific hook for processing logic in the Okta service."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/inlineHooks/{inlineHookId}/lifecycle/activate".format(  # noqa: UP032
            inlineHookId=inline_hook_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.inlineHooks.manage"]))
async def deactivate_inline_hook(
    context: ToolContext,
    inline_hook_id: Annotated[str, "Unique identifier of the inline hook to be deactivated."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivateInlineHook'."]:
    """Deactivates a specified inline hook.

    Use this tool to deactivate an inline hook by providing its unique identifier. Useful for managing hooks in web applications."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/inlineHooks/{inlineHookId}/lifecycle/deactivate".format(  # noqa: UP032
            inlineHookId=inline_hook_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.logStreams.read"]))
async def list_log_streams(
    context: ToolContext,
    pagination_cursor: Annotated[
        str | None,
        "The opaque string cursor used for pagination, obtained from the `Link` response header.",
    ] = None,
    max_number_of_log_streams: Annotated[
        int | None, "The maximum number of log stream objects to return."
    ] = None,
    filter_expression: Annotated[
        str | None,
        "A filter expression using the 'eq' operator on 'status' or 'type' properties to filter log streams.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listLogStreams'."]:
    """Retrieve all log stream objects in your organization.

    Use this tool to get a list of all log streams in your organization, with options for pagination and filtering."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/logStreams",
        method="GET",
        params=remove_none_values({
            "after": pagination_cursor,
            "limit": max_number_of_log_streams,
            "filter": filter_expression,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.logStreams.read"]))
async def fetch_log_stream_by_id(
    context: ToolContext,
    log_stream_id: Annotated[str, "Unique identifier for the log stream to be retrieved."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getLogStream'."]:
    """Retrieve log stream details by ID from Okta.

    Use this tool to access detailed information about a specific log stream in Okta by providing the log stream ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/logStreams/{logStreamId}".format(  # noqa: UP032
            logStreamId=log_stream_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.logStreams.manage"]))
async def delete_log_stream(
    context: ToolContext,
    log_stream_id: Annotated[str, "Unique identifier for the log stream you want to delete."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteLogStream'."]:
    """Delete a log stream from your organization by ID.

    Use this tool when you need to delete a specific log stream from your Okta organization. Provide the log stream ID to complete the operation."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/logStreams/{logStreamId}".format(  # noqa: UP032
            logStreamId=log_stream_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.logStreams.manage"]))
async def activate_log_stream(
    context: ToolContext,
    log_stream_id: Annotated[str, "Unique identifier for the log stream to be activated."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateLogStream'."]:
    """Activate a log stream using its ID.

    This tool activates a specified log stream by its logStreamId, enabling the log stream to begin operation."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/logStreams/{logStreamId}/lifecycle/activate".format(  # noqa: UP032
            logStreamId=log_stream_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.logStreams.manage"]))
async def deactivate_log_stream(
    context: ToolContext,
    log_stream_id: Annotated[str, "The unique identifier for the log stream to be deactivated."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivateLogStream'."]:
    """Deactivate a specified log stream using its ID.

    Use this tool to deactivate a log stream by providing the `logStreamId`. It is useful for managing log stream activity within the system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/logStreams/{logStreamId}/lifecycle/deactivate".format(  # noqa: UP032
            logStreamId=log_stream_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.logs.read"]))
async def list_system_log_events(
    context: ToolContext,
    start_time_filter: Annotated[
        str | None,
        "Filters events to those published after this time. Use ISO 8601 format, e.g., '2023-01-01T00:00:00Z'.",  # noqa: E501
    ] = None,
    upper_time_bound_for_events: Annotated[
        str | None,
        "Specifies the upper time boundary for filtering Okta log events, using the 'published' property.",  # noqa: E501
    ] = None,
    pagination_after_cursor: Annotated[
        str | None,
        "Retrieves the next page of log events using the token provided in the HTTP header ('rel=next').",  # noqa: E501
    ] = None,
    filter_expression: Annotated[
        str | None,
        "Filter the System Log events using a specific filter expression. All operators, except brackets, are supported. Refer to Okta's Filter and Operator documentation for detailed usage.",  # noqa: E501
    ] = None,
    keyword_filter: Annotated[
        str | None, "Filters log events by one or more case-insensitive keywords."
    ] = None,
    result_limit: Annotated[
        int | None,
        "Sets the number of results to be returned in the response. Default is 100; adjust to increase or decrease.",  # noqa: E501
    ] = None,
    event_sort_order: Annotated[
        str | None,
        "Specifies the sort order for returned events based on the `published` property. Choose either 'ASCENDING' or 'DESCENDING'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listLogEvents'."]:
    """Fetches recent Okta System Log events.

    Use this tool to retrieve Okta System Log events for monitoring and auditing purposes. It returns up to 100 events by default, with options to paginate or modify the limit."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/logs",
        method="GET",
        params=remove_none_values({
            "since": start_time_filter,
            "until": upper_time_bound_for_events,
            "after": pagination_after_cursor,
            "filter": filter_expression,
            "q": keyword_filter,
            "limit": result_limit,
            "sortOrder": event_sort_order,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.profileMappings.read"]))
async def list_profile_mappings(
    context: ToolContext,
    pagination_cursor_after: Annotated[
        str | None, "Mapping ID for pagination cursor to fetch the next page of profile mappings."
    ] = None,
    results_per_page: Annotated[
        int | None, "Number of profile mappings to return per page, used for pagination."
    ] = None,
    source_id: Annotated[
        str | None,
        "The user type or app instance ID acting as the source for the mappings. Filters results by this ID.",  # noqa: E501
    ] = None,
    target_id: Annotated[
        str | None,
        "The user type or app instance ID to be used as the target for expressions in a mapping. Filters returned mappings to have this as their `target.id`.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listProfileMappings'."]:
    """Retrieve all profile mappings in your Okta organization.

    Use this tool to list all profile mappings available in your Okta organization. It supports pagination and can filter results by `sourceId` and/or `targetId`. This helps users understand how properties map between Okta user profiles and app user profiles."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/mappings",
        method="GET",
        params=remove_none_values({
            "after": pagination_cursor_after,
            "limit": results_per_page,
            "sourceId": source_id,
            "targetId": target_id,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.profileMappings.read"]))
async def retrieve_profile_mapping_by_id(
    context: ToolContext,
    profile_mapping_id: Annotated[str, "The unique ID of the profile mapping to retrieve."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getProfileMapping'."]:
    """Retrieve profile mapping details by ID.

    Use this tool to get detailed information about a specific profile mapping using its unique identifier. Call this tool when you need to access details of a profile mapping from Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/mappings/{mappingId}".format(  # noqa: UP032
            mappingId=profile_mapping_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.schemas.read"]))
async def get_app_user_schema(
    context: ToolContext,
    application_id: Annotated[
        str, "The unique identifier of the application for which the user schema is retrieved."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getApplicationUserSchema'."]:
    """Retrieve the default schema for an app user.

    Use this tool to get the default schema for a user assigned to a specific app. This is useful when you need to understand the attributes and structure that apply uniformly to all users associated with the app."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/meta/schemas/apps/{appId}/default".format(  # noqa: UP032
            appId=application_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.schemas.read"]))
async def get_group_schema(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getGroupSchema'."]:
    """Retrieve the group schema from Okta.

    Use this tool to fetch the default group schema from Okta. This schema is used for all groups as Okta does not extend user types to groups. Useful for understanding the group structure and attributes."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/meta/schemas/group/default",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.logStreams.read"]))
async def list_log_stream_schemas(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listLogStreamSchemas'."]:
    """Retrieve schema for all log stream types for an organization.

    Use this tool to obtain the schema details for every log stream type accessible to the organization. This is useful for understanding the data structure and fields available for each log stream type."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/meta/schemas/logStream",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.logStreams.read"]))
async def retrieve_log_stream_schema(
    context: ToolContext,
    log_stream_type: Annotated[
        str,
        "Specify the log stream type: 'aws_eventbridge' for AWS EventBridge or 'splunk_cloud_logstreaming' for Splunk Cloud.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getLogStreamSchema'."]:
    """Retrieve the schema for a specific log stream type.

    This tool retrieves the schema for a specified log stream type in Okta. Use it to obtain schema details for either AWS EventBridge or Splunk Cloud log streaming by specifying the appropriate type."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/meta/schemas/logStream/{logStreamType}".format(  # noqa: UP032
            logStreamType=log_stream_type
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.linkedObjects.read"]))
async def list_linked_object_definitions(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listLinkedObjectDefinitions'."]:
    """Retrieve all Linked Object definitions from Okta.

    Use this tool to list all Linked Object definitions in your Okta instance. This is helpful for understanding relationships between different object schemas in your Okta environment."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/meta/schemas/user/linkedObjects",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.linkedObjects.read"]))
async def retrieve_linked_object_definition(
    context: ToolContext,
    linked_object_name: Annotated[
        str,
        "The Primary or Associated name of the Linked Object to retrieve its definition from Okta.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getLinkedObjectDefinition'."]:
    """Retrieve a Linked Object definition from Okta.

    Use this tool to get details about a specific Linked Object definition in Okta. It should be called when you need to understand the configuration or schema of a Linked Object by its name."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/meta/schemas/user/linkedObjects/{linkedObjectName}".format(  # noqa: UP032
            linkedObjectName=linked_object_name
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.linkedObjects.manage"]))
async def delete_linked_object_definition(
    context: ToolContext,
    linked_object_name: Annotated[
        str, "The primary or associated name of the linked object definition to delete in Okta."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteLinkedObjectDefinition'."]:
    """Delete a specified linked object definition in Okta.

    Use this tool to delete a linked object definition in Okta by specifying its primary or associated name. This action removes the entire definition."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/meta/schemas/user/linkedObjects/{linkedObjectName}".format(  # noqa: UP032
            linkedObjectName=linked_object_name
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.schemas.read"]))
async def retrieve_user_schema(
    context: ToolContext,
    schema_identifier: Annotated[
        str, "The ID for the user type schema to retrieve. Use 'default' for the default schema."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUserSchema'."]:
    """Retrieve the schema for a specified user type.

    This tool retrieves the schema information for a given user type using the provided schema ID. It is useful for obtaining details about the attributes and structure of specific user types."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/meta/schemas/user/{schemaId}".format(  # noqa: UP032
            schemaId=schema_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.userTypes.read"]))
async def list_all_user_types(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listUserTypes'."]:
    """Retrieve a list of all user types in your organization.

    Use this tool to get an overview of all user types defined in your Okta organization. Useful for managing user roles and permissions."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/meta/types/user",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.userTypes.read"]))
async def retrieve_user_type_by_id(
    context: ToolContext,
    user_type_id: Annotated[
        str, "The ID of the user type to retrieve. Use 'default' to fetch the default user type."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUserType'."]:
    """Retrieve user type information by ID from Okta.

    Use this tool to get details about a specific user type using its ID, including fetching the default type with 'default' as the ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/meta/types/user/{typeId}".format(typeId=user_type_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.userTypes.manage"]))
async def delete_user_type(
    context: ToolContext,
    user_type_id: Annotated[
        str,
        "The ID of the user type to delete. Must not be the default type or assigned to any users.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteUserType'."]:
    """Permantly remove a user type in Okta.

    Deletes a user type permanently unless it's the default or currently assigned to users."""
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/meta/types/user/{typeId}".format(typeId=user_type_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.uischemas.read"]))
async def list_ui_schemas(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listUISchemas'."]:
    """Retrieve all UI Schemas in your organization.

    This tool retrieves a list of all UI Schemas available in your organization from Okta. It should be called when you need to access or manage the UI configurations for various applications and components in your environment."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/meta/uischemas",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.uischemas.read"]))
async def retrieve_ui_schema(
    context: ToolContext,
    ui_schema_id: Annotated[str, "The unique ID of the UI Schema to retrieve from Okta."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUISchema'."]:
    """Retrieve UI Schema details by ID from Okta.

    Use this tool to fetch the UI Schema details from Okta by providing a specific ID. This is useful for accessing configuration details of the user interface schema."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/meta/uischemas/{id}".format(id=ui_schema_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.uischemas.manage"]))
async def delete_ui_schema(
    context: ToolContext,
    ui_schema_id: Annotated[str, "The unique identifier of the UI Schema to delete."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteUISchemas'."]:
    """Delete a UI Schema by its ID.

    Use this tool to delete a specific UI Schema in the Okta platform by providing the schema ID."""
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/meta/uischemas/{id}".format(id=ui_schema_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.orgs.read"]))
async def retrieve_org_general_settings(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOrgSettings'."]:
    """Retrieve the organization's general settings.

    This tool calls the Okta API to retrieve the organization's general settings, providing essential configuration details."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/org",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.captchas.read"]))
async def get_org_captcha_settings(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOrgCaptchaSettings'."]:
    """Retrieve CAPTCHA settings for your organization.

    Call this tool to get the current CAPTCHA settings configured for your organization. If no settings are configured, the tool returns an empty object."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/org/captcha",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.captchas.manage"]))
async def delete_org_captcha_settings(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteOrgCaptchaSettings'."]:
    """Deletes the CAPTCHA settings for your organization.

    Use this tool to delete the CAPTCHA settings object for your organization in Okta. This is useful when CAPTCHA protections are no longer needed or being replaced. The tool confirms the deletion of the settings."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/org/captcha",
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.orgs.read"]))
async def list_okta_org_contact_types(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listOrgContactTypes'."]:
    """List all organization contact types in Okta.

    Use this tool to retrieve all organization contact types for your Okta organization. This can help in understanding the roles and contact information available within the organization."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/org/contacts",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.orgs.read"]))
async def retrieve_org_contact_user(
    context: ToolContext,
    contact_type: Annotated[
        str,
        "Specify the contact type within the organization. Possible values: 'BILLING', 'TECHNICAL'.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOrgContactUser'."]:
    """Retrieve ID and user resource for a specific contact type in an organization.

    This tool retrieves the ID and user resource associated with a specified contact type within an organization using Okta. It is useful for accessing contact details for organizational roles or responsibilities."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/org/contacts/{contactType}".format(  # noqa: UP032
            contactType=contact_type
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def list_yubikey_otp_tokens(
    context: ToolContext,
    pagination_cursor_for_next_page: Annotated[
        str | None, "Specifies the pagination cursor for the next page of YubiKey OTP tokens."
    ] = None,
    expand_user_resource: Annotated[
        str | None, "Set to 'user' to embed the User resource if assigned to a YubiKey token."
    ] = None,
    filter_tokens_by: Annotated[
        str | None,
        "Filter expression to narrow down tokens (e.g., by email, serial, status, etc.).",
    ] = None,
    results_per_page: Annotated[
        int | None, "Specifies the number of YubiKey OTP tokens returned per page."
    ] = None,
    sort_tokens_by: Annotated[
        str | None,
        "Specify how to sort the YubiKey tokens. Options: profile.email, profile.serial, activated, user.id, created, status, lastVerified.",  # noqa: E501
    ] = None,
    sort_order: Annotated[
        str | None,
        "Specifies the sort order for the YubiKey OTP tokens, either `ASC` for ascending or `DESC` for descending.",  # noqa: E501
    ] = None,
    download_as_csv: Annotated[
        bool | None,
        "Set to True to return tokens as a downloadable CSV. The default limit changes to 1000.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listYubikeyOtpTokens'."]:
    """Lists all YubiKey OTP tokens in the organization.

    Use this tool to retrieve all YubiKey OTP tokens associated with the organization. It helps in managing and auditing YubiKey token deployments."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/org/factors/yubikey_token/tokens",
        method="GET",
        params=remove_none_values({
            "after": pagination_cursor_for_next_page,
            "expand": expand_user_resource,
            "filter": filter_tokens_by,
            "forDownload": download_as_csv,
            "limit": results_per_page,
            "sortBy": sort_tokens_by,
            "sortOrder": sort_order,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def retrieve_yubikey_otp_token(
    context: ToolContext,
    yubikey_otp_token_id: Annotated[str, "The unique ID of the YubiKey OTP token to retrieve."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getYubikeyOtpTokenById'."]:
    """Retrieve a YubiKey OTP token using its ID.

    This tool retrieves detailed information about a specific YubiKey OTP token by its ID. Use this tool when you need to access the details of a YubiKey OTP token from Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/org/factors/yubikey_token/tokens/{tokenId}".format(  # noqa: UP032
            tokenId=yubikey_otp_token_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.orgs.read"]))
async def retrieve_third_party_admin_setting(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getThirdPartyAdminSetting'."]:
    """Retrieve the third-party admin setting from Okta.

    Call this tool to obtain the current third-party admin settings configured in Okta. Useful for managing and auditing access settings."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/org/orgSettings/thirdPartyAdminSetting",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.orgs.read"]))
async def get_okta_org_preferences(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOrgPreferences'."]:
    """Retrieve preferences of your Okta organization.

    Use this tool to fetch the preferences set up for your Okta organization, helping you stay informed about organizational settings."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/org/preferences",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.orgs.manage"]))
async def hide_okta_user_dashboard_footer(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'setOrgHideOktaUIFooter'."]:
    """Hide the Okta End-User Dashboard footer for all users.

    This tool configures the Okta organization settings to hide the footer on the End-User Dashboard for all users. It should be called when there is a need to remove the dashboard footer for a cleaner UI experience."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/org/preferences/hideEndUserFooter",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.orgs.manage"]))
async def set_show_footer_preference(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'setOrgShowOktaUIFooter'."]:
    """Set the preference to show the Okta UI footer for end users.

    This tool is used to configure the display of the Okta UI footer for all end users in your organization. It should be called when there is a need to update the visibility of the footer across the end-user interface."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/org/preferences/showEndUserFooter",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.orgs.manage"]))
async def get_aerial_consent_details(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAerialConsent'."]:
    """Retrieve Okta Aerial consent grant details for your Org.

    Use this tool to check if your organization has granted consent for Okta Aerial. It returns detailed consent information or a 404 error if no consent has been granted."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/org/privacy/aerial",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.orgs.read"]))
async def get_okta_communication_settings(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOktaCommunicationSettings'."]:
    """Retrieve the Okta communication settings for your organization.

    Use this tool to access the communication settings configured in Okta for your organization. It retrieves preferences related to communication with Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/org/privacy/oktaCommunication",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.orgs.manage"]))
async def opt_in_users_to_okta_emails(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'optInUsersToOktaCommunicationEmails'."
]:
    """Opt in all users to Okta communication emails.

    Use this tool to opt in all users of an organization to receive communication emails from Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/org/privacy/oktaCommunication/optIn",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.orgs.manage"]))
async def opt_out_okta_emails(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'optOutUsersFromOktaCommunicationEmails'."
]:
    """Opt out all users from Okta communication emails.

    Use this tool to opt out all users in the organization from receiving Okta communication emails."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/org/privacy/oktaCommunication/optOut",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.orgs.read"]))
async def get_okta_support_settings(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getOrgOktaSupportSettings'."]:
    """Retrieves Okta Support Settings for your organization.

    Call this tool to get the current Okta Support Settings for your organization. Useful for understanding support configuration and privacy details in your Okta setup."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/org/privacy/oktaSupport",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.orgs.read"]))
async def list_okta_support_cases(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listOktaSupportCases'."]:
    """Retrieve a list of Okta Support cases.

    This tool retrieves all Okta Support cases that the user has permission to view. It should be called when a user needs to access their Okta Support cases."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/org/privacy/oktaSupport/cases",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.orgs.read"]))
async def get_auto_assign_admin_app_setting(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAutoAssignAdminAppSetting'."]:
    """Fetches the setting for auto-assigning the Okta Admin Console.

    Use this tool to retrieve the organization setting that determines if the Okta Admin Console is automatically assigned when an admin role is given."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/org/settings/autoAssignAdminAppSetting",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.orgs.read"]))
async def get_super_admin_privilege_setting(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getClientPrivilegesSetting'."]:
    """Retrieve Super Admin privilege setting for client apps.

    Use this tool to get the organization setting that determines if the Super Admin role is assigned to new public client applications."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/org/settings/clientPrivilegesSetting",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.policies.read"]))
async def list_policies_by_type(
    context: ToolContext,
    policy_type: Annotated[
        str,
        "Specifies the type of policy to return. Available types include `OKTA_SIGN_ON`, `PASSWORD`, `MFA_ENROLL`, `IDP_DISCOVERY`, and those exclusive to Okta Identity Engine like `ACCESS_POLICY`, `DEVICE_SIGNAL_COLLECTION`, `PROFILE_ENROLLMENT`, `POST_AUTH_SESSION`, and `ENTITY_RISK`.",  # noqa: E501
    ],
    filter_by_policy_status: Annotated[
        str | None, "Filter policies by their status. Acceptable values are `ACTIVE` or `INACTIVE`."
    ] = None,
    policy_name_prefix_query: Annotated[
        str | None,
        "Refines the query by specifying the prefix of the policy name using the startWith method.",
    ] = None,
    expand_policy_details: Annotated[
        str | None, "Determines if additional policy details should be included in the response."
    ] = None,
    sort_policies_by_name: Annotated[
        str | None,
        "Set to refine the query by sorting policies based on their names in ascending order.",
    ] = None,
    max_policies_to_return: Annotated[
        str | None,
        "Specifies the maximum number of policies to return. Use this for controlling pagination size.",  # noqa: E501
    ] = None,
    authorization_server_reference: Annotated[
        str | None, "Reference ID for the associated authorization server to filter policies."
    ] = None,
    pagination_end_cursor: Annotated[
        str | None,
        "End page cursor for pagination. Use to retrieve the next set of results in a paginated list.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listPolicies'."]:
    """Lists all policies of a specified type.

    Use this tool to retrieve a list of policies filtered by a specified type. It is useful for managing or reviewing specific policy sets within the Okta platform."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/policies",
        method="GET",
        params=remove_none_values({
            "type": policy_type,
            "status": filter_by_policy_status,
            "q": policy_name_prefix_query,
            "expand": expand_policy_details,
            "sortBy": sort_policies_by_name,
            "limit": max_policies_to_return,
            "resourceId": authorization_server_reference,
            "after": pagination_end_cursor,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.policies.read"]))
async def retrieve_policy(
    context: ToolContext,
    policy_id: Annotated[str, "The unique ID of the policy to retrieve details for."],
    expand_policy_details: Annotated[
        str | None,
        "Include additional policy details in the response. Provide parameters like 'groups'.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPolicy'."]:
    """Retrieve details of a specific policy using its ID.

    This tool should be called when a user wants to retrieve detailed information about a specific policy by providing the policy ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/policies/{policyId}".format(policyId=policy_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"expand": expand_policy_details}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.policies.manage"]))
async def delete_policy(
    context: ToolContext,
    policy_id: Annotated[str, "The ID of the policy to be deleted in Okta."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deletePolicy'."]:
    """Deletes a specified policy in Okta.

    Use this tool to delete a specific policy in Okta by its ID. Appropriate when you need to remove an existing policy from the system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/policies/{policyId}".format(policyId=policy_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.policies.manage"]))
async def clone_policy(
    context: ToolContext,
    policy_id: Annotated[
        str, "The unique identifier of the policy to be cloned. It must be a valid string ID."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'clonePolicy'."]:
    """Clone an existing policy in the system.

    Use this tool to create a copy of an existing policy by cloning it. This can be useful for quickly setting up similar policies without manually configuring each one."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/policies/{policyId}/clone".format(policyId=policy_id),  # noqa: UP032
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.policies.manage"]))
async def activate_policy(
    context: ToolContext,
    policy_id: Annotated[str, "The unique identifier for the policy to be activated."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activatePolicy'."]:
    """Activates a specified policy in Okta.

    Use this tool to activate a policy by its ID using Okta's API. It should be called when a policy needs to be enabled."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/policies/{policyId}/lifecycle/activate".format(  # noqa: UP032
            policyId=policy_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.policies.manage"]))
async def deactivate_policy(
    context: ToolContext,
    policy_id: Annotated[str, "The unique identifier (`id`) of the policy to deactivate in Okta."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivatePolicy'."]:
    """Deactivate a specified policy in Okta.

    This tool deactivates a policy in Okta using its policy ID. It should be called when a policy needs to be disabled, preventing it from being applied."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/policies/{policyId}/lifecycle/deactivate".format(  # noqa: UP032
            policyId=policy_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.policies.read"]))
async def list_policy_mappings(
    context: ToolContext,
    policy_id: Annotated[str, "The unique `id` of the policy to list its mapped resources."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listPolicyMappings'."]:
    """Retrieve resources mapped to a specific policy using its ID.

    Use this tool to obtain a list of all resources that are associated with a given policy, identified by its `policyId`. This can be helpful for auditing and managing policy resource links."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/policies/{policyId}/mappings".format(  # noqa: UP032
            policyId=policy_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.policies.read"]))
async def retrieve_policy_mapping(
    context: ToolContext,
    policy_id: Annotated[
        str, "The unique identifier of the policy to retrieve the resource mapping for."
    ],
    policy_resource_mapping_id: Annotated[
        str,
        "The unique `id` of the policy resource Mapping. Required to retrieve the specific mapping details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPolicyMapping'."]:
    """Retrieves resource mapping for a specific policy.

    Use this tool to get the resource mapping for a policy by providing the `policyId` and `mappingId`. It is useful for viewing the details of how a policy is mapped to resources."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/policies/{policyId}/mappings/{mappingId}".format(  # noqa: UP032
            policyId=policy_id, mappingId=policy_resource_mapping_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.policies.manage"]))
async def delete_policy_resource_mapping(
    context: ToolContext,
    policy_id: Annotated[
        str, "ID of the policy to identify which policy's resource mapping to delete."
    ],
    policy_resource_mapping_id: Annotated[
        str, "The unique ID of the policy resource mapping to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deletePolicyResourceMapping'."]:
    """Deletes a specific resource mapping for a policy identified by policyId and mappingId.

    Use this tool to remove the resource mapping associated with a specified policy in Okta by providing the policy ID and mapping ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/policies/{policyId}/mappings/{mappingId}".format(  # noqa: UP032
            policyId=policy_id, mappingId=policy_resource_mapping_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.policies.read"]))
async def list_policy_rules(
    context: ToolContext,
    policy_id: Annotated[str, "The unique `id` of the Okta policy to retrieve rules for."],
    number_of_policy_rules: Annotated[
        str | None,
        "Defines the maximum number of policy rules to return. Refer to Okta's pagination guidelines for more information.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listPolicyRules'."]:
    """Retrieve all rules for a specified Okta policy.

    Call this tool to fetch all the policy rules associated with a specific Okta policy. Useful for managing policy configurations and understanding rule details."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/policies/{policyId}/rules".format(policyId=policy_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"limit": number_of_policy_rules}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.policies.read"]))
async def retrieve_policy_rule(
    context: ToolContext,
    policy_id: Annotated[str, "The unique ID of the Policy to retrieve the rule from."],
    policy_rule_id: Annotated[str, "The unique ID of the policy rule to retrieve from Okta."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPolicyRule'."]:
    """Retrieve details of a specific policy rule by its ID.

    This tool is used to retrieve the details of a specific policy rule from Okta by providing the policy ID and rule ID. Use this when you need information about a particular rule within a policy."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/policies/{policyId}/rules/{ruleId}".format(  # noqa: UP032
            policyId=policy_id, ruleId=policy_rule_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.policies.manage"]))
async def delete_policy_rule(
    context: ToolContext,
    policy_id: Annotated[str, "The unique ID of the policy to be deleted."],
    policy_rule_id: Annotated[str, "The unique identifier of the policy rule to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deletePolicyRule'."]:
    """Deletes a specified policy rule in Okta.

    Use this tool to delete a policy rule by providing the appropriate `policyId` and `ruleId`."""
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/policies/{policyId}/rules/{ruleId}".format(  # noqa: UP032
            policyId=policy_id, ruleId=policy_rule_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.policies.manage"]))
async def activate_policy_rule(
    context: ToolContext,
    policy_id: Annotated[str, "The unique identifier of the Policy to be activated."],
    policy_rule_id: Annotated[
        str, "The unique identifier of the policy rule to be activated in Okta."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activatePolicyRule'."]:
    """Activates a specific Okta policy rule.

    This tool activates a policy rule in Okta identified by the given `policyId` and `ruleId`. Use it to enable specific rules within a policy."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/policies/{policyId}/rules/{ruleId}/lifecycle/activate".format(  # noqa: UP032
            policyId=policy_id, ruleId=policy_rule_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.policies.manage"]))
async def disable_policy_rule(
    context: ToolContext,
    policy_id: Annotated[str, "The ID of the policy to be deactivated."],
    policy_rule_id: Annotated[str, "The `id` of the policy rule to be deactivated in Okta."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivatePolicyRule'."]:
    """Deactivates a specified policy rule in Okta.

    Use this tool to deactivate a policy rule by providing the `policyId` and `ruleId`. It should be called when a policy rule needs to be deactivated within an Okta system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/policies/{policyId}/rules/{ruleId}/lifecycle/deactivate".format(  # noqa: UP032
            policyId=policy_id, ruleId=policy_rule_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.principalRateLimits.read"]))
async def list_principal_rate_limit_entities(
    context: ToolContext,
    principal_type_filter: Annotated[
        str, "Filters the list by principal type, e.g., `SSWS_TOKEN` or `OAUTH_CLIENT`."
    ],
    pagination_cursor: Annotated[
        str | None,
        "The cursor for pagination, an opaque string specifying current location in the list, obtained from the `Link` response header.",  # noqa: E501
    ] = None,
    page_size: Annotated[
        int | None, "The number of items to return in a single response page."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listPrincipalRateLimitEntities'."]:
    """Retrieve all Principal Rate Limit entities.

    This tool lists all Principal Rate Limit entities considering the provided parameters, helping to manage and monitor rate limits effectively."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/principal-rate-limits",
        method="GET",
        params=remove_none_values({
            "filter": principal_type_filter,
            "after": pagination_cursor,
            "limit": page_size,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.principalRateLimits.read"]))
async def retrieve_principal_rate_limit(
    context: ToolContext,
    principal_rate_limit_id: Annotated[
        str, "The ID of the principal rate limit entity to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPrincipalRateLimitEntity'."]:
    """Retrieve details of a principal rate limit entity by ID.

    Use this tool to obtain comprehensive information about a specific principal rate limit entity by providing the `principalRateLimitId`. This helps in understanding the rate limits applied to a principal."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/principal-rate-limits/{principalRateLimitId}".format(  # noqa: UP032
            principalRateLimitId=principal_rate_limit_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.pushProviders.read"]))
async def list_push_providers(
    context: ToolContext,
    provider_type_filter: Annotated[
        str | None,
        "Filters push providers by `providerType`. Possible values are 'APNS' and 'FCM'.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listPushProviders'."]:
    """Retrieve a list of all push providers.

    This tool should be called when there's a need to obtain information about all available push providers. It returns a list detailing each provider."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/push-providers",
        method="GET",
        params=remove_none_values({"type": provider_type_filter}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.pushProviders.read"]))
async def retrieve_push_provider(
    context: ToolContext,
    push_provider_id: Annotated[str, "The ID of the push provider to retrieve details for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPushProvider'."]:
    """Fetch details of a push provider by ID.

    Use this tool to get information about a specific push provider using its ID. It's helpful when you need to retrieve detailed information about push notification configurations."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/push-providers/{pushProviderId}".format(  # noqa: UP032
            pushProviderId=push_provider_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.pushProviders.manage"]))
async def delete_push_provider(
    context: ToolContext,
    push_provider_id: Annotated[
        str, "The unique identifier for the push provider to be deleted. Must be a valid ID string."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deletePushProvider'."]:
    """Delete a push provider by ID with usage checks.

    Call this tool to delete a specified push provider by ID. If the push provider is in use by a custom authenticator within the organization, the deletion will not proceed."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/push-providers/{pushProviderId}".format(  # noqa: UP032
            pushProviderId=push_provider_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.rateLimits.read"]))
async def get_rate_limit_notification_settings(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getRateLimitSettingsAdminNotifications'."
]:
    """Retrieve rate limit admin notification settings.

    This tool retrieves the currently configured settings for admin notifications related to rate limits. It should be called to check or review the notification settings for rate limit alerts."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/rate-limit-settings/admin-notifications",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.rateLimits.read"]))
async def get_okta_rate_limit_settings(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getRateLimitSettingsPerClient'."]:
    """Retrieve Okta's per-client rate limit settings.

    This tool retrieves the current configuration of Per-Client Rate Limit Settings from Okta. It's used when you need to understand or review the rate limit settings applied per client in Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/rate-limit-settings/per-client",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.rateLimits.read"]))
async def get_rate_limit_warning_threshold(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getRateLimitSettingsWarningThreshold'."
]:
    """Fetches the warning threshold for API rate limit notifications.

    Use this tool to retrieve the configured threshold for sending warning notifications when the API's rate limit is exceeded."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/rate-limit-settings/warning-threshold",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.realmAssignments.read"]))
async def list_realm_assignments(
    context: ToolContext,
    max_results: Annotated[int | None, "The maximum number of realm assignments to return."] = None,
    pagination_cursor: Annotated[
        str | None,
        "The cursor for pagination to continue listing from the last fetched realm assignment.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listRealmAssignments'."]:
    """Retrieve all realm assignments from Okta.

    Use this tool to list all realm assignments in Okta. It is helpful for managing and reviewing current realm assignments."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/realm-assignments",
        method="GET",
        params=remove_none_values({"limit": max_results, "after": pagination_cursor}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.realmAssignments.read"]))
async def list_realm_assignment_operations(
    context: ToolContext,
    return_limit: Annotated[
        int | None,
        "The maximum number of realm assignment operations to return. The upper limit is 200.",
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "The cursor for pagination. An opaque string from the `Link` response header indicating the current list position.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listRealmAssignmentOperations'."]:
    """Retrieve a list of realm assignment operations.

    This tool lists all realm assignment operations, with a limit of 200, sorted from most recent to oldest by ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/realm-assignments/operations",
        method="GET",
        params=remove_none_values({"limit": return_limit, "after": pagination_cursor}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.realmAssignments.read"]))
async def get_realm_assignment(
    context: ToolContext,
    realm_assignment_id: Annotated[str, "ID of the realm assignment to retrieve details for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getRealmAssignment'."]:
    """Retrieve a specific realm assignment using its ID.

    Use this tool to get details of a realm assignment by providing the assignment ID. This can be useful for managing user access and permissions within a specific realm."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/realm-assignments/{assignmentId}".format(  # noqa: UP032
            assignmentId=realm_assignment_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.realmAssignments.manage"]))
async def delete_realm_assignment(
    context: ToolContext,
    realm_assignment_id: Annotated[
        str, "The unique identifier for the realm assignment to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteRealmAssignment'."]:
    """Deletes a realm assignment by ID.

    This tool removes a specified realm assignment in Okta. It should be called when an assignment needs to be deleted based on its assignment ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/realm-assignments/{assignmentId}".format(  # noqa: UP032
            assignmentId=realm_assignment_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.realmAssignments.manage"]))
async def activate_realm_assignment(
    context: ToolContext,
    realm_assignment_id: Annotated[
        str, "The unique ID of the realm assignment to activate in Okta."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateRealmAssignment'."]:
    """Activates a specified realm assignment in Okta.

    Use this tool to activate a specific realm assignment by providing the assignment ID. This is useful for enabling access or functionality related to a realm assignment in Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/realm-assignments/{assignmentId}/lifecycle/activate".format(  # noqa: UP032
            assignmentId=realm_assignment_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.realmAssignments.manage"]))
async def deactivate_realm_assignment(
    context: ToolContext,
    realm_assignment_id: Annotated[
        str, "The unique identifier for the realm assignment to deactivate."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivateRealmAssignment'."]:
    """Deactivate a specified realm assignment in Okta.

    This tool deactivates a realm assignment using the specified assignment ID. Useful for disabling specific realm assignments in Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/realm-assignments/{assignmentId}/lifecycle/deactivate".format(  # noqa: UP032
            assignmentId=realm_assignment_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.realms.read"]))
async def list_realms(
    context: ToolContext,
    results_limit: Annotated[
        int | None,
        "Specifies the number of results to return. Defaults to 10 when `search` is used.",
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "The opaque string cursor for pagination, obtained from the `Link` response header to specify the current location in the list.",  # noqa: E501
    ] = None,
    search_expression: Annotated[
        str | None,
        "Filter realms using the 'co' operator with 'profile.name'. Only supports searching by 'profile.name'.",  # noqa: E501
    ] = None,
    sort_by_field: Annotated[
        str | None,
        "Specifies the field to sort the search results by. Only applicable if `search` is used.",
    ] = None,
    sort_order_for_search: Annotated[
        str | None,
        "Specifies the sorting order as 'asc' or 'desc' when search queries are used. Ignored if 'sort_by' isn't present.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listRealms'."]:
    """Retrieve a list of all Realms available.

    Use this tool to obtain a comprehensive list of all Realms from the service, providing essential information about the Realms configuration and availability."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/realms",
        method="GET",
        params=remove_none_values({
            "limit": results_limit,
            "after": pagination_cursor,
            "search": search_expression,
            "sortBy": sort_by_field,
            "sortOrder": sort_order_for_search,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.realms.read"]))
async def retrieve_realm_info(
    context: ToolContext,
    realm_id: Annotated[str, "The unique identifier for the realm to retrieve information for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getRealm'."]:
    """Retrieve information about a specified realm.

    This tool retrieves details about a specific realm identified by its ID. Use it to access information such as configuration and properties associated with a realm."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/realms/{realmId}".format(realmId=realm_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.realms.manage"]))
async def delete_realm(
    context: ToolContext,
    realm_id: Annotated[str, "The unique ID of the realm to be permanently deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteRealm'."]:
    """Permanently delete a realm in Okta after disassociation.

    Use this tool to permanently delete a realm from Okta, ensuring all associated entities like users and identity providers are disassociated beforehand."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/realms/{realmId}".format(realmId=realm_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def list_role_subscriptions(
    context: ToolContext,
    role_reference: Annotated[
        str,
        "A reference to an existing role. Use `roleType` for standard roles and `roleId` for custom roles.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listSubscriptionsRole'."]:
    """Retrieve all subscriptions for a specific role.

    Use this tool to get a detailed list of all subscriptions associated with a particular role in Okta, providing insight into the role's permissions and access."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/roles/{roleRef}/subscriptions".format(  # noqa: UP032
            roleRef=role_reference
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def get_role_subscription_notification(
    context: ToolContext,
    role_reference: Annotated[
        str,
        "The reference to an existing role. Provide `roleType` for standard roles and `roleId` for custom roles. Refer to Okta documentation for [Standard Roles](https://example.com/okta-management/guides/roles/#standard-roles).",  # noqa: E501
    ],
    notification_type: Annotated[
        str,
        "The type of notification to retrieve for the role. Options include AD_AGENT, AGENT_AUTO_UPDATE_NOTIFICATION, and others.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getSubscriptionsNotificationTypeRole'."
]:
    """Get subscription details by role and notification type.

    This tool retrieves subscription information for a given notification type associated with a specified role. It is useful for understanding which notifications are enabled for certain roles."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/roles/{roleRef}/subscriptions/{notificationType}".format(  # noqa: UP032
            roleRef=role_reference, notificationType=notification_type
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def subscribe_role_to_notification(
    context: ToolContext,
    role_reference: Annotated[
        str,
        "Reference to an existing role. Use `roleType` for standard roles and `roleId` for custom roles. Check documentation for details.",  # noqa: E501
    ],
    notification_type: Annotated[
        str,
        "The type of notification to subscribe the role to. Choose from: AD_AGENT, AGENT_AUTO_UPDATE_NOTIFICATION, AGENT_AUTO_UPDATE_NOTIFICATION_LDAP, APP_IMPORT, CONNECTOR_AGENT, IWA_AGENT, LDAP_AGENT, OKTA_ANNOUNCEMENT, OKTA_UPDATE, RATELIMIT_NOTIFICATION, REPORT_SUSPICIOUS_ACTIVITY, USER_DEPROVISION, USER_LOCKED_OUT.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'subscribeByNotificationTypeRole'."]:
    """Subscribe a role to a specific notification type.

    This tool subscribes a specific role to a designated notification type in Okta, overriding individual user subscriptions within that role."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/roles/{roleRef}/subscriptions/{notificationType}/subscribe".format(  # noqa: UP032
            roleRef=role_reference, notificationType=notification_type
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def unsubscribe_role_from_notification(
    context: ToolContext,
    role_reference: Annotated[
        str,
        "A reference to an existing role. Standard roles require a `roleType`, while Custom Roles require a `roleId`.",  # noqa: E501
    ],
    notification_type: Annotated[
        str,
        "Specifies the type of notification to unsubscribe the role from. Options include system updates, user actions, and agent alerts.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'unsubscribeByNotificationTypeRole'."
]:
    """Unsubscribes a role from a specific notification type.

    Use this tool to unsubscribe a specified role from a particular notification type in Okta. Role unsubscriptions take precedence over individual user settings for notifications."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/roles/{roleRef}/subscriptions/{notificationType}/unsubscribe".format(  # noqa: UP032
            roleRef=role_reference, notificationType=notification_type
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.securityEventsProviders.read"]))
async def list_security_events_providers(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'listSecurityEventsProviderInstances'."
]:
    """Retrieve all Security Events Provider instances from Okta.

    This tool is used to list all instances of Security Events Providers configured in Okta. It should be called when there is a need to retrieve information about these provider instances."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/security-events-providers",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.securityEventsProviders.read"]))
async def retrieve_security_event_provider(
    context: ToolContext,
    security_event_provider_id: Annotated[
        str, "The ID of the Security Events Provider instance to retrieve details for."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getSecurityEventsProviderInstance'."
]:
    """Retrieve details of a specific Security Events Provider.

    This tool retrieves the details of a Security Events Provider instance using the specified ID. It is useful when you need to obtain information about a particular security events provider associated with your organization."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/security-events-providers/{securityEventProviderId}".format(  # noqa: UP032
            securityEventProviderId=security_event_provider_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.securityEventsProviders.manage"]))
async def delete_security_events_provider_instance(
    context: ToolContext,
    security_events_provider_id: Annotated[
        str,
        "The ID of the security events provider instance to be deleted. This is a required field and must be a valid string representing the instance ID.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deleteSecurityEventsProviderInstance'."
]:
    """Deletes a specified security events provider instance.

    Use this tool to delete a specific security events provider instance by its ID. This action is irreversible and should be called when you need to remove an existing security events provider."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/security-events-providers/{securityEventProviderId}".format(  # noqa: UP032
            securityEventProviderId=security_events_provider_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.securityEventsProviders.manage"]))
async def activate_security_events_provider(
    context: ToolContext,
    security_event_provider_id: Annotated[
        str, "The `id` of the Security Events Provider instance to activate."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'activateSecurityEventsProviderInstance'."
]:
    """Activate a Security Events Provider instance.

    Use this tool to set the status of a Security Events Provider instance to 'ACTIVE', resuming the flow of events from the provider to Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/security-events-providers/{securityEventProviderId}/lifecycle/activate".format(  # noqa: UP032
            securityEventProviderId=security_event_provider_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.securityEventsProviders.manage"]))
async def deactivate_security_events_provider(
    context: ToolContext,
    security_event_provider_id: Annotated[
        str, "The unique `id` of the Security Events Provider instance to be deactivated."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deactivateSecurityEventsProviderInstance'."
]:
    """Deactivate a Security Events Provider instance in Okta.

    Use this tool to deactivate a Security Events Provider instance, stopping the flow of events from the provider to Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/security-events-providers/{securityEventProviderId}/lifecycle/deactivate".format(  # noqa: UP032
            securityEventProviderId=security_event_provider_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta"))
async def get_user_session_status(
    context: ToolContext,
    session_cookie: Annotated[
        str | None,
        "The session cookie for the current user, required to retrieve session information.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCurrentSession'."]:
    """Retrieve session info for the current signed-in user.

    Use this tool in browser-based applications to check if a user is signed in. Requires a session cookie for the user."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/sessions/me",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Cookie": session_cookie,
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta"))
async def sign_out_current_user(
    context: ToolContext,
    session_cookie: Annotated[
        str | None,
        "The session cookie string required to identify and terminate the active user session. This must be obtained from the user's browser to log them out.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'closeCurrentSession'."]:
    """Terminate the current user's session in a browser-based app.

    This tool closes the session for a user currently signed in. It should be used in browser-based applications to log out a user. Note that a session cookie is required, and an API token is not allowed for this operation."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/sessions/me",
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Cookie": session_cookie,
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta"))
async def refresh_user_session(
    context: ToolContext,
    session_cookie: Annotated[
        str | None,
        "The session cookie for the current user is required to refresh their session. Must be a valid session cookie.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'refreshCurrentSession'."]:
    """Refresh the current user's session.

    Use this tool to refresh the session for the current user. This requires a session cookie and cannot be performed with an API token."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/sessions/me/lifecycle/refresh",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Cookie": session_cookie,
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.sessions.read"]))
async def retrieve_session_info(
    context: ToolContext,
    session_id: Annotated[
        str,
        "The ID of the session to retrieve information for. Required to identify and obtain session details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getSession'."]:
    """Retrieve session details using a session ID.

    Use this tool to obtain detailed information about a specific session by providing the session ID. Ideal for managing user sessions and tracking session activities."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/sessions/{sessionId}".format(sessionId=session_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.sessions.manage"]))
async def revoke_user_session(
    context: ToolContext,
    session_id: Annotated[
        str, "The ID of the session to be revoked. Must be a valid session identifier string."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'revokeSession'."]:
    """Revoke a user's session using their session ID.

    This tool is used to revoke a specific user session by providing the session ID. It should be called when a user's session needs to be terminated for security or administrative purposes."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/sessions/{sessionId}".format(sessionId=session_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.sessions.manage"]))
async def update_session_expiry(
    context: ToolContext,
    session_id: Annotated[
        str,
        "The unique ID of the session to be refreshed. This ID is necessary to identify and update the session's expiration.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'refreshSession'."]:
    """Refresh an existing user session by ID for updated expiration.

    This tool is used to refresh an existing user session by providing the session ID. It returns the refreshed session with an updated expiration timestamp after a successful operation."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/sessions/{sessionId}/lifecycle/refresh".format(  # noqa: UP032
            sessionId=session_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["ssf.read"]))
async def retrieve_ssf_streams(
    context: ToolContext,
    stream_id: Annotated[
        str | None,
        "The ID of the specified SSF Stream configuration to retrieve. If not provided, all configurations are retrieved.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getSsfStreams'."]:
    """Retrieve SSF Stream configurations by client ID.

    This tool retrieves either a list of all known SSF Stream configurations or an individual configuration specified by ID. Only streams associated with the Client ID of the OAuth 2.0 access token can be viewed."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/ssf/stream",
        method="GET",
        params=remove_none_values({"stream_id": stream_id}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["ssf.manage"]))
async def delete_ssf_stream(
    context: ToolContext,
    stream_id_for_deletion: Annotated[
        str | None,
        "The ID of the SSF Stream to delete. If not provided, deletes the stream associated with the Client ID from the OAuth token.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteSsfStream'."]:
    """Delete a specified SSF Stream.

    Use this tool to delete an SSF Stream by providing a stream ID. If no stream ID is provided, it deletes the stream associated with the Client ID from the OAuth token."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/ssf/stream",
        method="DELETE",
        params=remove_none_values({"stream_id": stream_id_for_deletion}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["ssf.read"]))
async def retrieve_ssf_stream_status(
    context: ToolContext,
    ssf_stream_id: Annotated[
        str, "The unique ID of the specified SSF Stream configuration to retrieve its status."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getSsfStreamStatus'."]:
    """Retrieve the status of an SSF Stream transmission.

    Use this tool to check if the SSF Stream is able to transmit events. It returns the current status of the stream's transmission capability."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/ssf/stream/status",
        method="GET",
        params=remove_none_values({"stream_id": ssf_stream_id}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.templates.read"]))
async def list_sms_templates(
    context: ToolContext,
    sms_template_type: Annotated[
        str | None, "Specify the type of SMS templates to filter, e.g., 'SMS_VERIFY_CODE'."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listSmsTemplates'."]:
    """Retrieve all custom SMS templates from Okta.

    Use this tool to get a list of custom SMS templates. You can optionally filter the templates by type if needed."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/templates/sms",
        method="GET",
        params=remove_none_values({"templateType": sms_template_type}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.templates.read"]))
async def retrieve_sms_template(
    context: ToolContext,
    template_id: Annotated[str, "The unique identifier for the SMS template to be retrieved."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getSmsTemplate'."]:
    """Retrieve details of a specific SMS template by ID.

    Use this tool to get the details of an SMS template using its unique identifier. Ideal for when you need to view or manage specific SMS templates in the system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/templates/sms/{templateId}".format(  # noqa: UP032
            templateId=template_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.templates.manage"]))
async def delete_sms_template(
    context: ToolContext,
    template_id: Annotated[str, "The unique identifier of the SMS template to delete."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteSmsTemplate'."]:
    """Deletes an SMS template by template ID.

    This tool is used to delete a specific SMS template given its template ID. It should be called when there's a need to permanently remove an SMS template from the system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/templates/sms/{templateId}".format(  # noqa: UP032
            templateId=template_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.threatInsights.read"]))
async def get_threat_insight_configuration(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCurrentConfiguration'."]:
    """Retrieve the ThreatInsight configuration for your organization.

    Use this tool to get the current ThreatInsight configuration settings for your organization. It provides details about how threats are managed and configured within your Okta setup."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/threats/configuration",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.trustedOrigins.read"]))
async def list_trusted_origins(
    context: ToolContext,
    search_prefix_string: Annotated[
        str | None,
        "A search string to filter origins, matching the beginning of `name` or `origin`.",
    ] = None,
    filter_trusted_origins: Annotated[
        str | None,
        "Filter trusted origins using expressions for properties like `name`, `origin`, `status`, and `type`.",  # noqa: E501
    ] = None,
    cursor_after_prior_request: Annotated[
        str | None, "Use this cursor to continue listing from where the previous request left off."
    ] = None,
    results_limit: Annotated[
        int | None, "Specifies the maximum number of trusted origins to return in the response."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listTrustedOrigins'."]:
    """Retrieve all trusted origins from Okta.

    This tool should be used to obtain a list of all trusted origins configured in Okta. It is useful for managing security settings by identifying domains that are trusted by your Okta instance."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/trustedOrigins",
        method="GET",
        params=remove_none_values({
            "q": search_prefix_string,
            "filter": filter_trusted_origins,
            "after": cursor_after_prior_request,
            "limit": results_limit,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.trustedOrigins.read"]))
async def retrieve_trusted_origin(
    context: ToolContext,
    trusted_origin_id: Annotated[str, "The ID of the trusted origin to retrieve details for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getTrustedOrigin'."]:
    """Retrieve details of a trusted origin by ID.

    This tool retrieves information about a specific trusted origin using its ID. Use this to get details of trusted origins configured in the system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/trustedOrigins/{trustedOriginId}".format(  # noqa: UP032
            trustedOriginId=trusted_origin_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.trustedOrigins.manage"]))
async def delete_trusted_origin(
    context: ToolContext,
    trusted_origin_id: Annotated[
        str,
        "The ID of the trusted origin to be deleted. This is required to identify which origin entry to remove.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteTrustedOrigin'."]:
    """Deletes a specified trusted origin in Okta.

    Use this tool to delete a trusted origin in Okta by providing its ID. This can be useful for managing and updating security settings related to trusted origins."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/trustedOrigins/{trustedOriginId}".format(  # noqa: UP032
            trustedOriginId=trusted_origin_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.trustedOrigins.manage"]))
async def activate_trusted_origin(
    context: ToolContext,
    trusted_origin_id: Annotated[
        str,
        "The unique `id` of the trusted origin to activate. It identifies the specific origin in Okta.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateTrustedOrigin'."]:
    """Activates a trusted origin by setting its status to ACTIVE.

    Use this tool to activate a trusted origin within Okta by setting the status to ACTIVE. It is ideal when you need to enable a trusted origin that has been added but not yet activated."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/trustedOrigins/{trustedOriginId}/lifecycle/activate".format(  # noqa: UP032
            trustedOriginId=trusted_origin_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.trustedOrigins.manage"]))
async def deactivate_trusted_origin(
    context: ToolContext,
    trusted_origin_id: Annotated[
        str,
        "The unique identifier for the trusted origin to be deactivated. This is required to set its status to INACTIVE.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivateTrustedOrigin'."]:
    """Deactivate a trusted origin to set its status to INACTIVE.

    Use this tool to deactivate a trusted origin in Okta by setting its status to 'INACTIVE'. It should be called when you need to disable a trusted origin temporarily or permanently."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/trustedOrigins/{trustedOriginId}/lifecycle/deactivate".format(  # noqa: UP032
            trustedOriginId=trusted_origin_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def list_organization_users(
    context: ToolContext,
    user_search_query: Annotated[
        str | None,
        "Search for users using a filtering expression. Supports various properties and must be URL encoded. Warning: Complex or overly long queries can cause errors.",  # noqa: E501
    ] = None,
    filter_expression: Annotated[
        str | None,
        "A URL-encoded string to filter users by supported properties like `status`, `lastUpdated`, `id`, `profile.login`, `profile.email`, `profile.firstName`, and `profile.lastName`. Supports `eq` and some inequality operators for `lastUpdated`. Logical operators `and` and `or` are also supported.",  # noqa: E501
    ] = None,
    query_user_search: Annotated[
        str | None,
        "Retrieve users by matching queries against firstName, lastName, or email. Omits `DEPROVISIONED` users.",  # noqa: E501
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "An opaque string used as a cursor for pagination to specify the current location in the user list.",  # noqa: E501
    ] = None,
    result_limit: Annotated[
        int | None,
        "Specifies the number of user records to return. Defaults to 10 if `q` is provided.",
    ] = None,
    sort_users_by_field: Annotated[
        str | None,
        "Specify the field to sort users by. Use for search queries only. Example: `profile.lastName`. Users with the same value will be ordered by `id`.",  # noqa: E501
    ] = None,
    sort_order: Annotated[
        str | None,
        "Specifies the sort order for user listing, either 'asc' for ascending or 'desc' for descending. This is relevant only when 'sort_by' is used.",  # noqa: E501
    ] = None,
    include_metadata_classification: Annotated[
        str | None,
        "Include metadata in the `_embedded` property to retrieve user classification details. Supported value: `classification`.",  # noqa: E501
    ] = None,
    response_media_type: Annotated[
        str | None,
        "Specifies the media type of the resource with optional `okta-response` values for performance optimization. Enum values are `omitCredentials`, `omitCredentialsLinks`, and `omitTransitioningToStatus`.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listUsers'."]:
    """Retrieve a list of active users in the organization.

    Use this tool to obtain a list of active users within your organization. You can filter or search for a specific subset of users, but users with a status of 'DEPROVISIONED' are excluded from the default response."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users",
        method="GET",
        params=remove_none_values({
            "search": user_search_query,
            "filter": filter_expression,
            "q": query_user_search,
            "after": pagination_cursor,
            "limit": result_limit,
            "sortBy": sort_users_by_field,
            "sortOrder": sort_order,
            "expand": include_metadata_classification,
        }),
        headers=remove_none_values({
            "Content-Type": response_media_type,
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def get_user_info(
    context: ToolContext,
    user_identifier: Annotated[
        str,
        "An ID, login, or unambiguous login shortname of an Okta user. Use 'me' to get the current user linked to the API token.",  # noqa: E501
    ],
    include_metadata_in_embedded: Annotated[
        str | None,
        "An optional parameter to include metadata in the `_embedded` attribute. Valid values: `blocks` or `classification`.",  # noqa: E501
    ] = None,
    media_type: Annotated[
        str | None,
        "Specifies the media type of the resource. Use optional values like `omitCredentials`, `omitCredentialsLinks`, or `omitTransitioningToStatus` for performance optimization.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUser'."]:
    """Retrieve detailed information about a user in Okta.

    This tool retrieves a user's details from an Okta organization, using their user ID or the keyword 'me' to fetch the current user linked to the API token. It's useful for obtaining user information such as credentials and profiles. Note that to fetch by login, parameters must be URL encoded."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{id}".format(id=user_identifier),  # noqa: UP032
        method="GET",
        params=remove_none_values({"expand": include_metadata_in_embedded}),
        headers=remove_none_values({
            "Content-Type": media_type,
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def delete_deprovisioned_user(
    context: ToolContext,
    user_identifier: Annotated[
        str, "The ID, login, or unambiguous login shortname of a deprovisioned Okta user to delete."
    ],
    enable_async: Annotated[
        str | None, "Set to `respond-async` to perform the user deletion asynchronously."
    ] = None,
    send_deactivation_email: Annotated[
        bool | None,
        "If true, sends a deactivation email to the admin upon user deactivation or deletion.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteUser'."]:
    """Permanently delete a deprovisioned user account.

    Use this tool to permanently delete a user with the `DEPROVISIONED` status in Okta. Ensure the user is deprovisioned before performing this action, as deleting an active user requires deactivation first. This action is irreversible."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{id}".format(id=user_identifier),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({"sendEmail": send_deactivation_email}),
        headers=remove_none_values({
            "Prefer": enable_async,
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def list_user_app_links(
    context: ToolContext,
    user_identifier: Annotated[
        str, "An ID, login, or login shortname of an existing Okta user to list app links for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAppLinks'."]:
    """Retrieve app links for a user's assigned applications.

    This tool lists all app links for applications directly or indirectly assigned to a user through group membership. Use this tool to fetch application access links for a specific user by their ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{id}/appLinks".format(id=user_identifier),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def get_user_block_info(
    context: ToolContext,
    user_identifier: Annotated[
        str,
        "An ID, login, or unambiguous shortname of an existing Okta user to retrieve block information for.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listUserBlocks'."]:
    """Retrieve details about a user's account access blocks.

    This tool provides information on how a user is blocked from accessing their account. It should be used when you need to know the reasons for and details about a user's access restrictions."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{id}/blocks".format(id=user_identifier),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def get_user_groups(
    context: ToolContext,
    user_identifier: Annotated[
        str,
        "A unique identifier for an existing Okta user. This can be an ID, login, or an unambiguous login shortname. Used to fetch user groups.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listUserGroups'."]:
    """Retrieve all groups a user belongs to.

    This tool fetches all the groups for a specified user, helping identify the memberships of the user within an organization."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{id}/groups".format(id=user_identifier),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def get_user_identity_providers(
    context: ToolContext,
    user_identifier: Annotated[
        str,
        "An ID, login, or unambiguous login shortname of an existing Okta user to list associated identity providers.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listUserIdentityProviders'."]:
    """Retrieve identity providers associated with a user in Okta.

    Use this tool to fetch and list identity providers connected to a specified user in Okta. It helps in managing and understanding user-associated IdPs."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{id}/idps".format(id=user_identifier),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def activate_user_okta(
    context: ToolContext,
    user_identifier: Annotated[
        str, "An ID, login, or unique shortname of an existing Okta user to be activated."
    ],
    send_activation_email: Annotated[
        bool | None, "Set to true to send an activation email to the user upon activation."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateUser'."]:
    """Activate a staged or deprovisioned Okta user.

    Use this tool to activate a user with a `STAGED` or `DEPROVISIONED` status in Okta. This is an asynchronous operation where the user gains an `ACTIVE` status upon completion. Optionally, users can complete an activation link to finalize the process. Suitable for starting user activation workflows."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{id}/lifecycle/activate".format(  # noqa: UP032
            id=user_identifier
        ),
        method="POST",
        params=remove_none_values({"sendEmail": send_activation_email}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def deactivate_user_account(
    context: ToolContext,
    user_identifier: Annotated[
        str, "An ID, login, or unambiguous shortname of an existing Okta user to be deactivated."
    ],
    enable_asynchronous_processing: Annotated[
        str | None,
        "Set to `true` to request asynchronous user deactivation processing, otherwise defaults to synchronous processing.",  # noqa: E501
    ] = None,
    send_deactivation_email: Annotated[
        bool | None, "If true, sends a deactivation email to the admin."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivateUser'."]:
    """Permanently deactivate a user account.

    Use this tool to deactivate a user account that is not already deprovisioned. This action deprovisions the user from all assigned applications and cannot be undone. Ensure deactivation is intended, as it may result in data loss like emails or files. Asynchronous deactivation is supported by including the 'Prefer: respond-async' HTTP header."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{id}/lifecycle/deactivate".format(  # noqa: UP032
            id=user_identifier
        ),
        method="POST",
        params=remove_none_values({"sendEmail": send_deactivation_email}),
        headers=remove_none_values({
            "Prefer": enable_asynchronous_processing,
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            ),
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def expire_user_password(
    context: ToolContext,
    user_identifier: Annotated[
        str, "An ID, login, or login shortname of an existing Okta user. Must be unambiguous."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'expirePassword'."]:
    """Expires a user password, requiring a change at next login.

    Use this tool to set a user's password to expired status. This forces the user to change their password upon next login. If integrated with AD, the password in AD will also expire, prompting a change during the next sign-in attempt."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{id}/lifecycle/expire_password".format(  # noqa: UP032
            id=user_identifier
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def reset_password_with_temp(
    context: ToolContext,
    user_identifier: Annotated[
        str,
        "An ID, login, or unambiguous shortname of an existing Okta user for whom the password will be reset.",  # noqa: E501
    ],
    revoke_user_sessions: Annotated[
        bool | None,
        "Set to true to revoke the user's existing sessions, forcing re-authentication.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'expirePasswordWithTempPassword'."]:
    """Reset a user's password to a temporary one and expire it.

    This tool expires a user's password and resets it to a temporary password, transitioning the user's status to `PASSWORD_EXPIRED`. It requires the user to change their password upon next sign-in. Optionally, it can revoke the user's current sessions. This is especially useful in scenarios needing immediate password changes for security reasons."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{id}/lifecycle/expire_password_with_temp_password".format(  # noqa: UP032
            id=user_identifier
        ),
        method="POST",
        params=remove_none_values({"revokeSessions": revoke_user_sessions}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def reactivate_user(
    context: ToolContext,
    user_identifier: Annotated[
        str, "An ID, login, or unambiguous shortname of an existing Okta user to be reactivated."
    ],
    send_activation_email: Annotated[
        bool | None,
        "Set to true to send an activation email to the user; false to generate an activation link.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reactivateUser'."]:
    """Reactivates a user in PROVISIONED or RECOVERY status.

    Use this tool to reactivate a user who is in 'PROVISIONED' or 'RECOVERY' status. It restarts the activation workflow, providing either a direct reactivation via email or an activation link if email sending is disabled. The user may need to complete password reset and MFA enrollment to become 'ACTIVE'."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{id}/lifecycle/reactivate".format(  # noqa: UP032
            id=user_identifier
        ),
        method="POST",
        params=remove_none_values({"sendEmail": send_activation_email}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def reset_mfa_factors(
    context: ToolContext,
    user_identifier: Annotated[
        str,
        "An ID, login, or unambiguous login shortname of an existing Okta user to reset MFA factors.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'resetFactors'."]:
    """Reset all MFA factors for a specified user.

    This tool should be called to reset all MFA factors for a specific user, returning them to the unenrolled state. It is used when a user needs to re-enroll in MFA factors without affecting their active status."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{id}/lifecycle/reset_factors".format(  # noqa: UP032
            id=user_identifier
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def reset_user_password(
    context: ToolContext,
    user_identifier: Annotated[
        str,
        "An ID, login, or unambiguous shortname of an existing Okta user for whom the password reset is initiated.",  # noqa: E501
    ],
    send_ott_email: Annotated[
        bool,
        "Set to true to automatically email the one-time token link to the user for password reset.",  # noqa: E501
    ],
    revoke_all_sessions_except_current: Annotated[
        bool | None, "If true, revokes all user sessions except the current one."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'resetPassword'."]:
    """Reset user's password and generate a one-time token link.

    This tool resets a user's password, generating a one-time token (OTT) for a password reset. It transitions the user to 'RECOVERY' status, preventing sign-in until the reset is complete. An option to delete all user sessions is available, except in the current session's context. The tool can convert users to and from Okta credential providers. Can email the OTT or return it for custom distribution."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{id}/lifecycle/reset_password".format(  # noqa: UP032
            id=user_identifier
        ),
        method="POST",
        params=remove_none_values({
            "sendEmail": send_ott_email,
            "revokeSessions": revoke_all_sessions_except_current,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def suspend_user(
    context: ToolContext,
    user_identifier: Annotated[
        str,
        "An ID, login, or unambiguous login shortname of an existing active Okta user to suspend.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'suspendUser'."]:
    """Suspend an active user in Okta.

    This tool suspends a user with an active status in Okta, preventing sign-ins but retaining group and app assignments. It should be used only for users who are currently active."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{id}/lifecycle/suspend".format(  # noqa: UP032
            id=user_identifier
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def unlock_user_account(
    context: ToolContext,
    user_identifier: Annotated[
        str, "An ID, login name, or unique shortname of the existing Okta user to be unlocked."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'unlockUser'."]:
    """Unlock a user account with a LOCKED_OUT status.

    This tool unlocks a user account that is either in a `LOCKED_OUT` status or an `ACTIVE` status blocked from unknown devices, making it `ACTIVE` so they can sign in. Works with Okta-sourced users."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{id}/lifecycle/unlock".format(  # noqa: UP032
            id=user_identifier
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def unsuspend_user(
    context: ToolContext,
    user_identifier: Annotated[
        str, "An ID, login, or login shortname (unambiguous) of an existing Okta user to unsuspend."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'unsuspendUser'."]:
    """Unsuspend a user and return them to ACTIVE state.

    Use this tool to activate a user who is currently suspended, provided they have a SUSPENDED status. This is useful for reactivating users who were previously deactivated."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{id}/lifecycle/unsuspend".format(  # noqa: UP032
            id=user_identifier
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def assign_user_linked_object(
    context: ToolContext,
    user_id_or_login: Annotated[
        str, "ID or login of the associated user. Use 'me' for the current session user."
    ],
    primary_relationship_name: Annotated[
        str, "Specify the name of the primary relationship to assign to the associated user."
    ],
    primary_user_id: Annotated[
        str,
        "User ID to assign as the `primary` relationship for the `associated` user. Provide the specific user ID.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'assignLinkedObjectValueForPrimary'."
]:
    """Assign a primary user to an associated user in Okta.

    Use this tool to assign a primary user relationship to an associated user in Okta. If the associated user already has a different primary user for this relationship, the previous link will be removed, ensuring only one primary user per associated user."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userIdOrLogin}/linkedObjects/{primaryRelationshipName}/{primaryUserId}".format(  # noqa: UP032
            userIdOrLogin=user_id_or_login,
            primaryRelationshipName=primary_relationship_name,
            primaryUserId=primary_user_id,
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def list_linked_users(
    context: ToolContext,
    user_identifier_or_login: Annotated[
        str,
        "The ID or login of the user to get the primary user ID or associated users. Use 'me' for the current session user.",  # noqa: E501
    ],
    relationship_name: Annotated[
        str,
        "Specify the name of the primary or associated relationship to be queried for linked users.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listLinkedObjectsForUser'."]:
    """Retrieve linked or associated users for a given relationship.

    Utilize this tool to list either the self link for a primary user or all associated users based on a specified relationship name. If no associations exist, it returns an empty array. Suitable for retrieving user associations in applications using Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userIdOrLogin}/linkedObjects/{relationshipName}".format(  # noqa: UP032
            userIdOrLogin=user_identifier_or_login, relationshipName=relationship_name
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def delete_user_linked_object(
    context: ToolContext,
    user_identifier_or_login: Annotated[
        str,
        "The ID or login of the user to delete the relationship for. Use 'me' to represent the current session user.",  # noqa: E501
    ],
    relationship_name: Annotated[
        str, "Name of the `primary` or `associated` relationship to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteLinkedObjectForUser'."]:
    """Delete a user's linked object relationship.

    Use this tool to delete an existing linked object relationship between a specified user and their associated primary relationship. It's successful whether or not such a relationship exists."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userIdOrLogin}/linkedObjects/{relationshipName}".format(  # noqa: UP032
            userIdOrLogin=user_identifier_or_login, relationshipName=relationship_name
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def list_authenticator_enrollments(
    context: ToolContext,
    user_id: Annotated[
        str, "The ID of an existing Okta user for whom to list authenticator enrollments."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAuthenticatorEnrollments'."]:
    """Retrieve all authenticator enrollments for a user.

    Use this tool to get a list of all authenticator enrollments associated with a specified user. This is useful for understanding which authentication methods are enrolled for a user in Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/authenticator-enrollments".format(  # noqa: UP032
            userId=user_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def enroll_phone_authenticator(
    context: ToolContext,
    okta_user_id: Annotated[
        str,
        "The unique ID of an existing user in Okta for whom the phone authenticator enrollment will be created.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createAuthenticatorEnrollment'."]:
    """Enroll a phone authenticator for a user automatically.

    This tool should be called to enroll and automatically activate a phone authenticator for a specific user. It's useful when a user needs to secure their account with a phone-based authentication method."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/authenticator-enrollments/phone".format(  # noqa: UP032
            userId=okta_user_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def create_tac_authenticator_enrollment(
    context: ToolContext,
    user_id: Annotated[
        str,
        "The unique ID of an existing Okta user for whom the TAC authenticator enrollment will be created.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'createTacAuthenticatorEnrollment'."
]:
    """Creates an auto-activated TAC authenticator enrollment for a user.

    Use this tool to automatically activate a Temporary Access Code (TAC) authenticator enrollment for a specified user in Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/authenticator-enrollments/tac".format(  # noqa: UP032
            userId=user_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def retrieve_user_authenticator_enrollment(
    context: ToolContext,
    okta_user_id: Annotated[
        str,
        "The ID of an existing Okta user whose authenticator enrollment details are to be retrieved.",  # noqa: E501
    ],
    authenticator_enrollment_id: Annotated[
        str, "Unique identifier for the user's authenticator enrollment."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAuthenticatorEnrollment'."]:
    """Retrieve a user's authenticator enrollment details.

    This tool fetches a user's authenticator enrollment details using the enrollment ID. It should be called when you need information about a user's security device or mechanism enrollment status."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/authenticator-enrollments/{enrollmentId}".format(  # noqa: UP032
            userId=okta_user_id, enrollmentId=authenticator_enrollment_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def delete_enrollment(
    context: ToolContext,
    user_id: Annotated[
        str, "ID of an existing Okta user to identify whom the enrollment will be deleted for."
    ],
    enrollment_id: Annotated[
        str, "Unique identifier for the user's authenticator enrollment to be deleted."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteAuthenticatorEnrollment'."]:
    """Delete a user's authenticator enrollment.

    This tool deletes an existing authenticator enrollment for a specified user. It should be used when there is a need to remove a user's current enrollment, allowing them to enroll the authenticator again."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/authenticator-enrollments/{enrollmentId}".format(  # noqa: UP032
            userId=user_id, enrollmentId=enrollment_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def retrieve_user_classification(
    context: ToolContext,
    user_id: Annotated[str, "The unique identifier for an existing Okta user."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUserClassification'."]:
    """Retrieve a user's classification from Okta.

    Use this tool to get classification details for a specific user in Okta. It should be called when user classification information is needed for decision making or display."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/classification".format(userId=user_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def list_user_clients(
    context: ToolContext,
    okta_user_id: Annotated[
        str, "ID of an existing Okta user to list associated client resources."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listUserClients'."]:
    """List client resources for a user with grants or tokens.

    Retrieves all client resources associated with the specified user that have grants or tokens. Useful for managing user client access and identifying resource associations."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/clients".format(userId=okta_user_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def list_user_client_grants(
    context: ToolContext,
    user_id: Annotated[
        str, "The ID of an existing Okta user for whom the grants are to be listed."
    ],
    client_app_id: Annotated[
        str,
        "The unique identifier of the client application for which you want to list the grants.",
    ],
    include_scope_details: Annotated[
        str | None,
        "Set to 'scope' to include scope details in the response's `_embedded` attribute.",
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "The cursor string for pagination, indicating your current position in the list. Obtained from the `Link` response header.",  # noqa: E501
    ] = None,
    number_of_tokens_to_return: Annotated[
        int | None, "Specifies the maximum number of grants to return for the user and client."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listGrantsForUserAndClient'."]:
    """Lists all grants for a specified user and client.

    Use this tool to retrieve all grants associated with a specific user and client. It's useful when you need to check the permissions or access rights granted to a user for a particular client application."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/clients/{clientId}/grants".format(  # noqa: UP032
            userId=user_id, clientId=client_app_id
        ),
        method="GET",
        params=remove_none_values({
            "expand": include_scope_details,
            "after": pagination_cursor,
            "limit": number_of_tokens_to_return,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def revoke_user_client_grants(
    context: ToolContext,
    okta_user_id: Annotated[str, "The ID of an existing Okta user whose grants will be revoked."],
    client_app_id: Annotated[
        str,
        "The ID of the client application for which to revoke grants. This identifies the specific client in the Okta system for the operation.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'revokeGrantsForUserAndClient'."]:
    """Revoke all grants for a specified user and client.

    Use this tool to revoke all access grants for a specific user and client in the Okta system. It is called when needing to revoke permissions for user and client combinations."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/clients/{clientId}/grants".format(  # noqa: UP032
            userId=okta_user_id, clientId=client_app_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def list_user_client_refresh_tokens(
    context: ToolContext,
    user_id: Annotated[str, "ID of an existing Okta user to retrieve refresh tokens for."],
    client_id: Annotated[str, "The ID of the client application for which to list refresh tokens."],
    include_scope_details: Annotated[
        str | None, "Set to 'true' to include scope details in the response. Valid value: `scope`."
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "An opaque string for continuing pagination, obtained from the `Link` response header.",
    ] = None,
    token_return_limit: Annotated[
        int | None, "Specifies the maximum number of refresh tokens to return."
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'listRefreshTokensForUserAndClient'."
]:
    """Retrieve refresh tokens for a specific user and client.

    This tool retrieves all refresh tokens issued for a specified user and client in the Okta system. It should be called when you need to manage or audit tokens related to user access."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/clients/{clientId}/tokens".format(  # noqa: UP032
            userId=user_id, clientId=client_id
        ),
        method="GET",
        params=remove_none_values({
            "expand": include_scope_details,
            "after": pagination_cursor,
            "limit": token_return_limit,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def revoke_user_tokens(
    context: ToolContext,
    user_id: Annotated[
        str, "Specify the ID of an existing Okta user whose tokens are to be revoked."
    ],
    client_application_id: Annotated[
        str, "The unique identifier for the client application whose tokens you want to revoke."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'revokeTokensForUserAndClient'."]:
    """Revoke all refresh tokens for a user and client.

    This tool revokes all refresh tokens issued for a specified user and client. It should be used when you need to invalidate a user's access through a particular client, such as in security cases or session management."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/clients/{clientId}/tokens".format(  # noqa: UP032
            userId=user_id, clientId=client_application_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def get_user_refresh_token(
    context: ToolContext,
    user_id: Annotated[str, "ID of an existing Okta user to retrieve the refresh token for."],
    client_app_id: Annotated[
        str, "The unique ID of the client application associated with the user token."
    ],
    token_id: Annotated[
        str,
        "The ID of the token for which details are being retrieved. This identifies the specific refresh token issued for a user and client combination.",  # noqa: E501
    ],
    include_scope_details: Annotated[
        str | None, "Include scope details in the response by setting this to `scope`."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getRefreshTokenForUserAndClient'."]:
    """Retrieve a user's refresh token for a specified client.

    This tool retrieves a refresh token that was issued for a specified user and client combination. It should be called when there's a need to access or verify the refresh token details for a user."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/clients/{clientId}/tokens/{tokenId}".format(  # noqa: UP032
            userId=user_id, clientId=client_app_id, tokenId=token_id
        ),
        method="GET",
        params=remove_none_values({"expand": include_scope_details}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def revoke_tokens_for_user_client(
    context: ToolContext,
    okta_user_id: Annotated[
        str, "The unique ID of an existing Okta user whose tokens are to be revoked."
    ],
    client_app_id: Annotated[str, "Client app ID associated with the tokens to be revoked."],
    token_id: Annotated[
        str,
        "The unique ID of the token to be revoked. Required for identifying which token to revoke.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'revokeTokenForUserAndClient'."]:
    """Revoke refresh and access tokens for a user and client.

    Use this tool to revoke specified refresh and access tokens associated with a particular user and client. This will terminate any sessions linked to these tokens."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/clients/{clientId}/tokens/{tokenId}".format(  # noqa: UP032
            userId=okta_user_id, clientId=client_app_id, tokenId=token_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def initiate_password_reset_flow(
    context: ToolContext,
    okta_user_id: Annotated[
        str, "The unique ID of an existing Okta user to initiate the password reset process."
    ],
    send_email: Annotated[
        bool | None,
        "If true, sends a forgot password email to the user. If false, returns a reset link.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'forgotPassword'."]:
    """Initiates the password reset process for a user in Okta.

    This tool starts the forgot password flow, generating a one-time token for password reset. It's used for users with 'ACTIVE' status and a valid recovery question credential. If 'sendEmail' is false, it returns a password reset link."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/credentials/forgot_password".format(  # noqa: UP032
            userId=okta_user_id
        ),
        method="POST",
        params=remove_none_values({"sendEmail": send_email}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def list_user_devices(
    context: ToolContext,
    user_id: Annotated[
        str, "The unique identifier of an existing Okta user whose devices you want to list."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listUserDevices'."]:
    """Retrieve a user's enrolled devices from Okta.

    Use this tool to list all devices enrolled by a specific user in Okta. Specify the user's ID to get their device list. Useful for managing user devices within an organization."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/devices".format(userId=user_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def list_user_factors(
    context: ToolContext,
    user_id: Annotated[
        str, "ID of an existing Okta user for whom the enrolled factors are retrieved."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listFactors'."]:
    """Retrieve enrolled factors for a user from Okta.

    This tool retrieves all enrolled authentication factors for a specified user from Okta, according to the applicable authenticator enrollment policy. It only returns factors that are either \"REQUIRED\" or \"OPTIONAL\" in the highest priority policy applicable to the user. Admins can use this tool for other users, but the client's conditions affect policy evaluation."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/factors".format(userId=user_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def list_supported_auth_factors(
    context: ToolContext,
    okta_user_id: Annotated[
        str,
        "The unique identifier of an existing Okta user for whom the supported authentication factors are to be listed.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listSupportedFactors'."]:
    """Retrieve supported authentication factors for a user.

    Use this tool to list all the supported authentication factors that can be enrolled for a specified user, based on the highest priority authenticator enrollment policy applicable to them. Only factors within the categories of 'REQUIRED' or 'OPTIONAL' are included. This is useful for understanding which security measures a user can set up in Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/factors/catalog".format(  # noqa: UP032
            userId=okta_user_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def retrieve_user_factor(
    context: ToolContext,
    user_id: Annotated[str, "ID of an existing Okta user to retrieve the security factor for."],
    user_factor_id: Annotated[
        str, "ID of an existing user factor to retrieve details for a specific user."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getFactor'."]:
    """Retrieve security factor for a specific user.

    Use this tool to retrieve information about an existing security factor associated with a specified user in the Okta system. It helps in managing and reviewing user security settings."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/factors/{factorId}".format(  # noqa: UP032
            userId=user_id, factorId=user_factor_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def unenroll_user_factor(
    context: ToolContext,
    user_id: Annotated[str, "ID of an existing Okta user to unenroll the factor from."],
    user_factor_id: Annotated[str, "ID of the existing user factor to be unenrolled."],
    remove_phone_number_as_recovery_method: Annotated[
        bool | None,
        "If true, removes the phone number as both a recovery method and a factor. Applicable only for 'sms' and 'call' factors.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'unenrollFactor'."]:
    """Unenroll a factor from a specified user.

    This tool unenrolls an existing factor for a specified user in Okta. It cannot unenroll a factor from a deactivated user. Use this to allow a user to enroll a new factor instead. Unenrolling certain factors may automatically unenroll related factors."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/factors/{factorId}".format(  # noqa: UP032
            userId=user_id, factorId=user_factor_id
        ),
        method="DELETE",
        params=remove_none_values({
            "removeRecoveryEnrollment": remove_phone_number_as_recovery_method
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def activate_user_factor(
    context: ToolContext,
    okta_user_id: Annotated[str, "The ID of an existing Okta user to activate the factor for."],
    user_factor_id: Annotated[
        str,
        "The ID of an existing user factor to be activated. Required to specify which factor to activate for the user.",  # noqa: E501
    ],
    activation_request_body: Annotated[
        dict[str, str] | None,
        "A JSON object containing the details required for activating the factor. The structure depends on the specific factor being activated.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateFactor'."]:
    """Activates user authentication factors for completing enrollment.

    Use this tool to activate authentication factors like call, email, push, SMS, token, U2F, and WebAuthn to complete the enrollment process for a user. Activation is essential for certain factors, and a rate limit of five attempts per five minutes is enforced."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/factors/{factorId}/lifecycle/activate".format(  # noqa: UP032
            userId=okta_user_id, factorId=user_factor_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({"requestBody": activation_request_body}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def get_push_verification_status(
    context: ToolContext,
    okta_user_id: Annotated[
        str,
        "The unique ID of the existing Okta user whose push verification status is being retrieved.",  # noqa: E501
    ],
    user_factor_id: Annotated[
        str, "ID of an existing user factor in Okta to check its verification status."
    ],
    factor_verification_transaction_id: Annotated[
        str, "Provide the ID of an existing factor verification transaction."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getFactorTransactionStatus'."]:
    """Retrieve the status of a push factor verification transaction.

    Use this tool to get the status of an Okta push factor verification transaction. It is useful for determining the outcome of a push verification attempt, including specific details for a number matching push challenge if applicable."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/factors/{factorId}/transactions/{transactionId}".format(  # noqa: UP032
            userId=okta_user_id,
            factorId=user_factor_id,
            transactionId=factor_verification_transaction_id,
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def list_user_grants(
    context: ToolContext,
    user_id: Annotated[str, "ID of an existing Okta user for whom to list grants."],
    scope_id_filter: Annotated[str | None, "The scope ID used to filter user grants."] = None,
    include_scope_details: Annotated[
        str | None,
        "Include scope details in the response using the `_embedded` attribute. Use `scope` as the value.",  # noqa: E501
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "The cursor string for pagination, obtained from the `Link` header to track the current position in the list.",  # noqa: E501
    ] = None,
    grant_limit: Annotated[
        int | None,
        "Specifies the maximum number of grants to return for a user. Use an integer value to determine how many results you want to retrieve.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listUserGrants'."]:
    """Retrieve all grants for a specific user in Okta.

    Use this tool to list all the grants assigned to a specified user in the Okta system. It's useful for understanding user permissions and access levels."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/grants".format(userId=user_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "scopeId": scope_id_filter,
            "expand": include_scope_details,
            "after": pagination_cursor,
            "limit": grant_limit,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def revoke_user_grants(
    context: ToolContext,
    user_id: Annotated[str, "The unique ID of an existing Okta user whose grants will be revoked."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'revokeUserGrants'."]:
    """Revokes all user grants in Okta.

    Call this tool to revoke all access grants for a specified user in the Okta system. Use it when you need to remove a user's permissions or access rights."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/grants".format(userId=user_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def retrieve_user_grant(
    context: ToolContext,
    okta_user_id: Annotated[
        str, "The unique identifier for an existing Okta user to fetch the grant for."
    ],
    grant_id: Annotated[
        str, "The unique identifier of the grant to retrieve details for a specific user."
    ],
    include_scope_details: Annotated[
        str | None,
        "Specify `True` to include scope details in the `_embedded` attribute. Accepts only the value 'scope'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUserGrant'."]:
    """Fetches a specific grant for a given user.

    Use this tool to retrieve details about a specific grant assigned to a user, identified by user ID and grant ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/grants/{grantId}".format(  # noqa: UP032
            userId=okta_user_id, grantId=grant_id
        ),
        method="GET",
        params=remove_none_values({"expand": include_scope_details}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def revoke_user_grant(
    context: ToolContext,
    okta_user_id: Annotated[
        str, "The unique identifier of an existing user in Okta whose grant is to be revoked."
    ],
    grant_id: Annotated[
        str, "The unique identifier of the grant to be revoked for the specified user."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'revokeUserGrant'."]:
    """Revoke a specific grant for a user in Okta.

    This tool revokes a specific access grant for a specified user in the Okta system, identified by user ID and grant ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/grants/{grantId}".format(  # noqa: UP032
            userId=okta_user_id, grantId=grant_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.userRisk.read"]))
async def retrieve_user_risk(
    context: ToolContext,
    user_id: Annotated[str, "ID of an existing Okta user to retrieve the risk profile for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUserRisk'."]:
    """Get the risk profile of a specific user by ID.

    Use this tool to obtain the risk profile associated with a specific user by their ID. It provides insights into potential security concerns or anomalies related to the user."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/risk".format(userId=user_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def get_user_roles(
    context: ToolContext,
    user_id: Annotated[str, "The ID of an existing Okta user to retrieve assigned roles for."],
    include_role_targets: Annotated[
        str | None,
        "Optional parameter to include targets configured for standard role assignments. Use `targets/groups` or `targets/catalog/apps`.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAssignedRolesForUser'."]:
    """Retrieve roles assigned to a specific user by user ID.

    Use this tool to list all roles that have been assigned to a user by their `userId`. It should be called when there's a need to determine a user's permissions or access within a system."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/roles".format(userId=user_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"expand": include_role_targets}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def assign_role_to_user(
    context: ToolContext,
    user_id: Annotated[
        str, "The unique ID of an existing Okta user to whom the role will be assigned."
    ],
    role_assignment_details: Annotated[
        dict[str, str],
        "Details of the role assignment including type (standard or custom) and relevant configuration.",  # noqa: E501
    ],
    disable_notifications: Annotated[
        bool | None, "Set to `true` to grant the user third-party admin status."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'assignRoleToUser'."]:
    """Assign a standard role to a specified user.

    This tool assigns a standard role to a user in the Okta system. It should be used when you need to add a role to a user. Note that standard and custom role assignments require different request payloads."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/roles".format(userId=user_id),  # noqa: UP032
        method="POST",
        params=remove_none_values({"disableNotifications": disable_notifications}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({"requestBody": role_assignment_details}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def get_user_assigned_role(
    context: ToolContext,
    user_id: Annotated[
        str, "Provide the ID of an existing Okta user to retrieve their role assignment."
    ],
    role_assignment_id: Annotated[
        str,
        "The unique identifier of the role assignment for a user. This ID is required to specify which role is being retrieved.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUserAssignedRole'."]:
    """Retrieve a specific role assigned to a user.

    Use this tool to get information about a role assigned to a specific user by providing the user's `userId` and the `roleAssignmentId`. This can be used to access details about standard or custom role assignments."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/roles/{roleAssignmentId}".format(  # noqa: UP032
            userId=user_id, roleAssignmentId=role_assignment_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def unassign_user_role(
    context: ToolContext,
    user_id: Annotated[str, "ID of an existing Okta user to unassign the role from."],
    role_assignment_id: Annotated[
        str, "The ID of the role assignment to be unassigned from the user."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'unassignRoleFromUser'."]:
    """Unassign a role from a specific user.

    This tool removes a role assignment from a user based on provided `userId` and `roleAssignmentId`. It should be called when a user's role needs to be unassigned."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/roles/{roleAssignmentId}".format(  # noqa: UP032
            userId=user_id, roleAssignmentId=role_assignment_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def get_user_role_governance_sources(
    context: ToolContext,
    okta_user_id: Annotated[
        str, "ID of an existing Okta user to retrieve role governance sources."
    ],
    role_assignment_id: Annotated[
        str,
        "The ID of the role assignment associated with the user. This is required to retrieve governance sources for the role.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUserAssignedRoleGovernance'."]:
    """Retrieve governance sources for a user's assigned role.

    This tool fetches the governance sources associated with a specific role assigned to a user, identified by their `roleAssignmentId` and `userId`. Use this when you need detailed governance information for a user's role."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/roles/{roleAssignmentId}/governance".format(  # noqa: UP032
            userId=okta_user_id, roleAssignmentId=role_assignment_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def retrieve_role_assignment_governance_details(
    context: ToolContext,
    user_id: Annotated[
        str,
        "The unique identifier for an existing Okta user. This ID is required to retrieve governance details related to their role assignments.",  # noqa: E501
    ],
    role_assignment_id: Annotated[
        str,
        "The ID of the role assignment linked to the user. Required for retrieving governance details.",  # noqa: E501
    ],
    grant_id: Annotated[
        str,
        "The ID for the specific grant related to the user's role assignment. This is used to retrieve governance details.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getRoleAssignmentGovernanceGrant'."
]:
    """Retrieve governance details for a user's role assignment.

    This tool retrieves governance source information for a specific role assigned to a user. It should be called when you need detailed governance data about a user's role assignment identified by specific role and grant IDs."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/roles/{roleAssignmentId}/governance/{grantId}".format(  # noqa: UP032
            userId=user_id, roleAssignmentId=role_assignment_id, grantId=grant_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def retrieve_user_role_governance_resources(
    context: ToolContext,
    okta_user_id: Annotated[
        str, "ID of an existing Okta user for which the resources are being retrieved."
    ],
    role_assignment_id: Annotated[
        str, "The ID of the role assignment. Required to fetch governance resources for the user."
    ],
    grant_id: Annotated[
        str,
        "Specify the Grant ID to retrieve role governance resources for a user. This ID identifies the governance source related to the role.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getRoleAssignmentGovernanceGrantResources'."
]:
    """Retrieve resources for a user's role governance.

    Fetches resources associated with a specific governance source for a role assigned to a user by using the user ID, role assignment ID, and grant ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/roles/{roleAssignmentId}/governance/{grantId}/resources".format(  # noqa: UP032
            userId=okta_user_id, roleAssignmentId=role_assignment_id, grantId=grant_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def list_app_targets_for_user_admin_role(
    context: ToolContext,
    user_id: Annotated[
        str, "The ID of an existing Okta user for which app targets are being retrieved."
    ],
    role_assignment_id: Annotated[str, "The ID of the role assignment for the user."],
    pagination_cursor: Annotated[
        str | None,
        "The cursor for pagination to specify the current list location, obtained from the 'Link' response header.",  # noqa: E501
    ] = None,
    max_objects_to_return: Annotated[
        int | None, "Specifies the maximum number of app targets to return."
    ] = None,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'listApplicationTargetsForApplicationAdministratorRoleForUser'.",  # noqa: E501
]:
    """Retrieve app targets for a user's admin role in Okta.

    Use this tool to get a list of application targets associated with an 'APP_ADMIN' role assigned to a specific user in Okta. The returned list includes OIN-cataloged applications or app instances, with the 'id' property for app instances."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/roles/{roleAssignmentId}/targets/catalog/apps".format(  # noqa: UP032
            userId=user_id, roleAssignmentId=role_assignment_id
        ),
        method="GET",
        params=remove_none_values({"after": pagination_cursor, "limit": max_objects_to_return}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def assign_apps_to_role_for_user(
    context: ToolContext,
    okta_user_id: Annotated[str, "ID of an existing Okta user to assign apps to their role."],
    role_assignment_id: Annotated[
        str,
        "The ID of the specific role assignment to which all apps will be assigned for the user.",
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'assignAllAppsAsTargetToRoleForUser'."
]:
    """Assigns all applications to a user's role in Okta.

    Use this tool to assign all available applications to a specified user's `APP_ADMIN` role in Okta. It should be called when you need to automate the process of granting a user access to all applications under a specific role."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/roles/{roleAssignmentId}/targets/catalog/apps".format(  # noqa: UP032
            userId=okta_user_id, roleAssignmentId=role_assignment_id
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def set_app_admin_role_target(
    context: ToolContext,
    user_id: Annotated[str, "ID of an existing Okta user to whom the app target will be assigned."],
    role_assignment_id: Annotated[
        str,
        "The ID of the role assignment to identify which admin role to assign the app target to.",
    ],
    app_name: Annotated[
        str,
        "Specify the name of the app definition as listed in the OIN catalog. This targets the app for admin role assignment.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'assignAppTargetToAdminRoleForUser'."
]:
    """Assign an app target to an admin role for a user.

    Assigns a specific OIN app target to an admin user's APP_ADMIN role, reducing the role's scope to the specified app. Overrides existing app instance targets for the OIN app, making the user admin for all instances of the specified app."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/roles/{roleAssignmentId}/targets/catalog/apps/{appName}".format(  # noqa: UP032
            userId=user_id, roleAssignmentId=role_assignment_id, appName=app_name
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def remove_app_target_from_role(
    context: ToolContext,
    okta_user_id: Annotated[
        str, "ID of an existing Okta user to unassign an app target from the role."
    ],
    role_assignment_id: Annotated[
        str, "The unique identifier of the role assignment to be unassigned from the user."
    ],
    app_name: Annotated[str, "Name of the app definition from the OIN catalog (the app key name)."],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'unassignAppTargetFromAppAdminRoleForUser'."
]:
    """Unassign an app target from an admin role for a user.

    This tool is used to unassign an OIN app target from an `APP_ADMIN` role assigned to an admin user in Okta. Note that the last app target cannot be removed if it causes an exception. To cover all apps, delete the role assignment and recreate it with the desired settings."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/roles/{roleAssignmentId}/targets/catalog/apps/{appName}".format(  # noqa: UP032
            userId=okta_user_id, roleAssignmentId=role_assignment_id, appName=app_name
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def assign_app_target_to_user_role(
    context: ToolContext,
    user_id: Annotated[
        str, "ID of an existing Okta user to which the app instance target is assigned."
    ],
    role_assignment_id: Annotated[
        str, "The ID of the role assignment for the user to which the app target will be assigned."
    ],
    app_name: Annotated[str, "The name of the app definition in the OIN catalog key name format."],
    application_id: Annotated[
        str,
        "The unique identifier for a specific application. Used to narrow the user's admin role to this app instance.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'assignAppInstanceTargetToAppAdminRoleForUser'."
]:
    """Assign an app target to a user's admin role.

    This tool assigns a specific app instance target to a user's `APP_ADMIN` role, thereby reducing the role's scope to the specified target. It should be used when limiting a user's app management permissions to particular app instances."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/roles/{roleAssignmentId}/targets/catalog/apps/{appName}/{appId}".format(  # noqa: UP032
            userId=user_id,
            roleAssignmentId=role_assignment_id,
            appName=app_name,
            appId=application_id,
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def unassign_app_instance_from_admin_role(
    context: ToolContext,
    okta_user_id: Annotated[
        str, "ID of an existing Okta user to unassign the app instance target from."
    ],
    role_assignment_id: Annotated[
        str, "The unique identifier for the role assignment to unassign the app instance from."
    ],
    app_name: Annotated[
        str, "The official name of the app definition, as found in the OIN catalog."
    ],
    application_id: Annotated[
        str,
        "The unique identifier for the application instance to be unassigned from the admin role.",
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'unassignAppInstanceTargetFromAdminRoleForUser'.",
]:
    """Unassign an app instance target from an admin role.

    Use this tool to unassign a specific app instance target from an `APP_ADMIN` role assigned to an admin user. Note that you cannot remove the last app instance target from a role assignment to avoid exceptions. If a role needs to apply to all apps, consider deleting and recreating the `APP_ADMIN` role assignment."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/roles/{roleAssignmentId}/targets/catalog/apps/{appName}/{appId}".format(  # noqa: UP032
            userId=okta_user_id,
            roleAssignmentId=role_assignment_id,
            appName=app_name,
            appId=application_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def get_group_targets_for_role(
    context: ToolContext,
    user_id: Annotated[str, "The ID of an existing Okta user to fetch group targets for."],
    role_assignment_id: Annotated[
        str, "The ID of the role assignment for which to list group targets."
    ],
    pagination_cursor: Annotated[
        str | None,
        "The cursor string for pagination, obtained from the `Link` response header to specify the current location in the list.",  # noqa: E501
    ] = None,
    max_results_to_return: Annotated[
        int | None,
        "The maximum number of group targets to return. Specify an integer value to limit the results.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listGroupTargetsForRole'."]:
    """Retrieve group targets for specific admin roles in Okta.

    Use this tool to list all group targets for a specified `USER_ADMIN`, `HELP_DESK_ADMIN`, or `GROUP_MEMBERSHIP_ADMIN` role assigned to an admin user. Returns an empty list if the role has no specific group targets."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/roles/{roleAssignmentId}/targets/groups".format(  # noqa: UP032
            userId=user_id, roleAssignmentId=role_assignment_id
        ),
        method="GET",
        params=remove_none_values({"after": pagination_cursor, "limit": max_results_to_return}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def assign_group_target_to_user_role(
    context: ToolContext,
    okta_user_id: Annotated[
        str, "The ID of an existing Okta user to whom the group target is assigned."
    ],
    role_assignment_id: Annotated[
        str,
        "The unique identifier of the role assignment to which the group target will be assigned.",
    ],
    group_id: Annotated[
        str, "The unique identifier of the group to assign to the user's admin role."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'assignGroupTargetToUserRole'."]:
    """Assign a group target to a specified user role.

    Use this tool to assign a specified group target to a user's admin role, such as USER_ADMIN, HELP_DESK_ADMIN, or GROUP_MEMBERSHIP_ADMIN. This allows narrowing the scope of the role to specific groups, rather than applying universally."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/roles/{roleAssignmentId}/targets/groups/{groupId}".format(  # noqa: UP032
            userId=okta_user_id, roleAssignmentId=role_assignment_id, groupId=group_id
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def unassign_group_from_user_admin_role(
    context: ToolContext,
    okta_user_id: Annotated[
        str,
        "The unique identifier for an existing Okta user to be used in unassigning a group from their admin role.",  # noqa: E501
    ],
    role_assignment_id: Annotated[str, "The ID of the role assignment to unassign a group from."],
    group_id: Annotated[
        str, "The unique identifier for the group to be unassigned from the admin role."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'unassignGroupTargetFromUserAdminRole'."
]:
    """Unassign a group from a user's admin role.

    Use this tool to unassign a group target from a `USER_ADMIN`, `HELP_DESK_ADMIN`, or `GROUP_MEMBERSHIP_ADMIN` role for an admin user. Note that you cannot remove the last group target if it causes an exception. Consider deleting and recreating the role assignment if needed."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/roles/{roleAssignmentId}/targets/groups/{groupId}".format(  # noqa: UP032
            userId=okta_user_id, roleAssignmentId=role_assignment_id, groupId=group_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def get_role_targets_by_user_and_role(
    context: ToolContext,
    user_id: Annotated[
        str,
        "The unique ID of an existing Okta user to retrieve role targets for, required for identifying the user within Okta.",  # noqa: E501
    ],
    role_id_or_encoded_role_name: Annotated[
        str,
        "The ID of the role or its Base32 encoded name to specify which role's targets to retrieve.",  # noqa: E501
    ],
    user_assignment_type: Annotated[
        str | None, "Specifies the assignment type of the user, either 'USER' or 'GROUP'."
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "The opaque string used for pagination, indicating your current position in the list, obtained from the `Link` response header.",  # noqa: E501
    ] = None,
    object_limit: Annotated[
        int | None, "Specify the maximum number of role targets to return."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getRoleTargetsByUserIdAndRoleId'."]:
    """Retrieve role targets for a user's specific role.

    This tool retrieves all role targets assigned to a specific user with a given role in Okta. It is useful for identifying which applications or groups a user with a certain administrative role can manage. If there are no specific targets, an empty list is returned."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/roles/{roleIdOrEncodedRoleId}/targets".format(  # noqa: UP032
            userId=user_id, roleIdOrEncodedRoleId=role_id_or_encoded_role_name
        ),
        method="GET",
        params=remove_none_values({
            "assignmentType": user_assignment_type,
            "after": pagination_cursor,
            "limit": object_limit,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def revoke_user_sessions(
    context: ToolContext,
    okta_user_id: Annotated[
        str, "The unique identifier for an existing Okta user whose sessions will be revoked."
    ],
    revoke_oauth_tokens: Annotated[
        bool | None,
        "Set to true to revoke issued OpenID Connect and OAuth refresh and access tokens.",
    ] = None,
    clear_remembered_factors_for_all_devices: Annotated[
        bool | None,
        "Set to true to clear the user's remembered factors for all devices. Defaults to false in Classic Engine.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'revokeUserSessions'."]:
    """Revoke all active sessions for a user in Okta.

    Use this tool to revoke all active identity provider sessions for a specified user in Okta. This action requires the user to re-authenticate on the next action. Optionally, you can also revoke associated OpenID Connect and OAuth tokens and clear remembered factors across devices. This does not affect sessions for web or native apps."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/sessions".format(userId=okta_user_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({
            "oauthTokens": revoke_oauth_tokens,
            "forgetDevices": clear_remembered_factors_for_all_devices,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def list_user_subscriptions(
    context: ToolContext,
    user_id: Annotated[
        str,
        "The unique identifier for the user whose subscriptions you want to retrieve. Ensure you have access rights to this user's data to avoid an `AccessDeniedException`.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listSubscriptionsUser'."]:
    """Retrieve all subscriptions for a specified user.

    Use this tool to get a list of all subscriptions that are available to a specific user in Okta. Ensure that you request for a user you have access to, as requests for other users will result in an `AccessDeniedException`."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/subscriptions".format(userId=user_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def get_user_subscription_by_notification_type(
    context: ToolContext,
    user_id: Annotated[
        str, "The unique identifier for the user whose subscription details are being retrieved."
    ],
    notification_type: Annotated[
        str,
        "Specify the type of notification to retrieve user subscription details. Valid values include: AD_AGENT, AGENT_AUTO_UPDATE_NOTIFICATION, AGENT_AUTO_UPDATE_NOTIFICATION_LDAP, APP_IMPORT, CONNECTOR_AGENT, IWA_AGENT, LDAP_AGENT, OKTA_ANNOUNCEMENT, OKTA_UPDATE, RATELIMIT_NOTIFICATION, REPORT_SUSPICIOUS_ACTIVITY, USER_DEPROVISION, USER_LOCKED_OUT.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getSubscriptionsNotificationTypeUser'."
]:
    """Retrieve a user's subscription by notification type.

    Use this tool to get subscription information for a specified user's notification type. It should be called when you need to access a user's subscription details for a particular notification type. Access is restricted to the specified user only."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/subscriptions/{notificationType}".format(  # noqa: UP032
            userId=user_id, notificationType=notification_type
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def subscribe_user_to_notification(
    context: ToolContext,
    current_user_id: Annotated[
        str,
        "The unique identifier of the current user to subscribe to the notification. Only the current user's ID is allowed.",  # noqa: E501
    ],
    notification_type: Annotated[
        str,
        "Specify the type of notification to subscribe the user to. Choose from: AD_AGENT, AGENT_AUTO_UPDATE_NOTIFICATION, AGENT_AUTO_UPDATE_NOTIFICATION_LDAP, APP_IMPORT, CONNECTOR_AGENT, IWA_AGENT, LDAP_AGENT, OKTA_ANNOUNCEMENT, OKTA_UPDATE, RATELIMIT_NOTIFICATION, REPORT_SUSPICIOUS_ACTIVITY, USER_DEPROVISION, USER_LOCKED_OUT.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'subscribeByNotificationTypeUser'."]:
    """Subscribe a user to a specific notification type.

    Use this tool to subscribe the current user to a specified notification type in Okta. Access is denied if attempting to subscribe for another user."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/subscriptions/{notificationType}/subscribe".format(  # noqa: UP032
            userId=current_user_id, notificationType=notification_type
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def unsubscribe_user_notification(
    context: ToolContext,
    current_user_id: Annotated[
        str,
        "The ID of the current user unsubscribing from the notification type. Must be the ID of the user making the request.",  # noqa: E501
    ],
    notification_type: Annotated[
        str,
        "Specifies the type of notification to unsubscribe from. Valid types include 'AD_AGENT', 'APP_IMPORT', 'USER_LOCKED_OUT', etc.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'unsubscribeByNotificationTypeUser'."
]:
    """Unsubscribe a user from a specific notification type.

    Use this tool to unsubscribe the current user from a specified notification type. This should be called when a user wants to stop receiving certain notifications. Only applicable to the current user; will return an error if attempted for another user."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/users/{userId}/subscriptions/{notificationType}/unsubscribe".format(  # noqa: UP032
            userId=current_user_id, notificationType=notification_type
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.networkZones.read"]))
async def list_network_zones(
    context: ToolContext,
    pagination_cursor_after: Annotated[
        str | None,
        "The cursor for retrieving the next page of results. Used for pagination to specify the starting point after the given item.",  # noqa: E501
    ] = None,
    max_results: Annotated[
        int | None,
        "The maximum number of network zones to retrieve in one call. This helps control pagination.",  # noqa: E501
    ] = None,
    filter_expression: Annotated[
        str | None,
        "A URL-encoded string to filter network zones by id, usage, or system properties.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listNetworkZones'."]:
    """Retrieve all network zones with optional filtering.

    This tool retrieves all network zones from Okta, allowing for optional filtering based on zone ID, usage, or system properties. It supports pagination and URL-encoded filter expressions."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/zones",
        method="GET",
        params=remove_none_values({
            "after": pagination_cursor_after,
            "limit": max_results,
            "filter": filter_expression,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.networkZones.read"]))
async def get_network_zone(
    context: ToolContext,
    network_zone_id: Annotated[str, "The unique identifier of the Network Zone to retrieve."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getNetworkZone'."]:
    """Retrieve details of a network zone by ID from Okta.

    Use this tool to fetch detailed information about a specific network zone in Okta using the zone ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/zones/{zoneId}".format(zoneId=network_zone_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.networkZones.manage"]))
async def delete_network_zone(
    context: ToolContext,
    network_zone_id: Annotated[
        str,
        "The ID of the network zone to be deleted. Ensure it is not in use by a policy or rule.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteNetworkZone'."]:
    """Delete a specific network zone by its ID.

    Deletes a network zone identified by `zoneId`. Ensure the network zone is not used by a policy or rule and has an appropriate status for deletion in Okta Identity Engine orgs."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/zones/{zoneId}".format(zoneId=network_zone_id),  # noqa: UP032
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.networkZones.manage"]))
async def activate_network_zone(
    context: ToolContext,
    network_zone_id: Annotated[
        str,
        "The unique identifier (`id`) of the Network Zone to be activated. This is required to specify which network zone you want to activate in Okta.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'activateNetworkZone'."]:
    """Activate a specified network zone by zoneId.

    Use this tool to activate a network zone in Okta by providing the zone ID. Call this when you need to enable or re-enable a network zone that is currently inactive."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/zones/{zoneId}/lifecycle/activate".format(  # noqa: UP032
            zoneId=network_zone_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.networkZones.manage"]))
async def deactivate_network_zone(
    context: ToolContext,
    network_zone_id: Annotated[str, "The ID of the Network Zone to be deactivated."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deactivateNetworkZone'."]:
    """Deactivate a network zone by its ID using Okta.

    This tool deactivates a specified network zone in Okta based on the provided `zoneId`. It should be used when you need to disable access or function of a particular network zone."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/api/v1/zones/{zoneId}/lifecycle/deactivate".format(  # noqa: UP032
            zoneId=network_zone_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.orgs.read"]))
async def get_authenticator_settings(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAuthenticatorSettings'."]:
    """Retrieve Authenticator Settings for your organization.

    Use this tool to get the current Authenticator Settings for your organization, useful for security configuration and management."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/attack-protection/api/v1/authenticator-settings",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.orgs.read"]))
async def get_user_lockout_settings(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getUserLockoutSettings'."]:
    """Retrieve user lockout settings for an organization.

    This tool fetches the user lockout settings for an organization. It should be called when you need to know how user lockouts are configured in a given organization."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/attack-protection/api/v1/user-lockout-settings",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.orgs.read"]))
async def check_mfa_number_matching_status(
    context: ToolContext,
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'getDesktopMFAEnforceNumberMatchingChallengeOrgSetting'.",
]:
    """Check if MFA Number Matching is enabled for your org.

    Use this tool to determine whether the Desktop MFA Enforce Number Matching Challenge feature is enabled or disabled for your organization."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/device-access/api/v1/desktop-mfa/enforce-number-matching-challenge-settings",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.orgs.read"]))
async def check_mfa_recovery_pin_status(
    context: ToolContext,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getDesktopMFARecoveryPinOrgSetting'."
]:
    """Check if the Desktop MFA Recovery PIN feature is enabled.

    Use this tool to determine whether the Desktop MFA Recovery PIN feature is enabled for your organization."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/device-access/api/v1/desktop-mfa/recovery-pin-settings",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.oauthIntegrations.read"]))
async def list_api_service_integrations(
    context: ToolContext,
    pagination_cursor: Annotated[
        str | None,
        "Opaque string for pagination to specify the current location in the list, obtained from the `Link` header.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'listApiServiceIntegrationInstances'."
]:
    """Retrieve all API Service Integration instances.

    Use this tool to list all API Service Integration instances available in Okta, with optional pagination for navigating through results."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/integrations/api/v1/api-services",
        method="GET",
        params=remove_none_values({"after": pagination_cursor}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.oauthIntegrations.read"]))
async def retrieve_api_service_integration(
    context: ToolContext,
    api_service_integration_id: Annotated[
        str, "The ID of the API Service Integration instance to retrieve details for."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getApiServiceIntegrationInstance'."
]:
    """Retrieve an API Service Integration instance by ID.

    Use this tool to get detailed information about a specific API Service Integration instance by providing its ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/integrations/api/v1/api-services/{apiServiceId}".format(  # noqa: UP032
            apiServiceId=api_service_integration_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.oauthIntegrations.manage"]))
async def delete_api_service_integration_instance(
    context: ToolContext,
    api_service_integration_id: Annotated[
        str, "`id` of the API Service Integration instance to be deleted."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deleteApiServiceIntegrationInstance'."
]:
    """Delete an API Service Integration instance by ID.

    This tool deletes an API Service Integration instance using its ID. It should be called when you need to remove an integration and revoke all associated access scopes."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/integrations/api/v1/api-services/{apiServiceId}".format(  # noqa: UP032
            apiServiceId=api_service_integration_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.oauthIntegrations.read"]))
async def list_api_service_secrets(
    context: ToolContext,
    api_service_id: Annotated[
        str,
        "The unique identifier of the API Service Integration instance to retrieve secrets for.",
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'listApiServiceIntegrationInstanceSecrets'."
]:
    """Retrieve client secrets for an API service integration.

    Use this tool to list all client secrets for a specific API Service Integration instance using the `apiServiceId`."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/integrations/api/v1/api-services/{apiServiceId}/credentials/secrets".format(  # noqa: UP032
            apiServiceId=api_service_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.oauthIntegrations.manage"]))
async def create_api_service_secret(
    context: ToolContext,
    integration_instance_id: Annotated[
        str,
        "The ID of the Okta API Service Integration instance for which the secret is being created.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'createApiServiceIntegrationInstanceSecret'."
]:
    """Create an API Service Integration Secret in Okta.

    Generates a new active client secret for an Okta API Service Integration instance. This tool should be called when you need to create a secret object, with a limit of two secrets per instance. An error occurs if more than two are attempted."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/integrations/api/v1/api-services/{apiServiceId}/credentials/secrets".format(  # noqa: UP032
            apiServiceId=integration_instance_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.oauthIntegrations.manage"]))
async def delete_inactive_secret(
    context: ToolContext,
    api_service_integration_instance_id: Annotated[
        str, "The ID of the API Service Integration instance to which the secret belongs."
    ],
    secret_id: Annotated[
        str,
        "The ID of the API Service Integration instance Secret to be deleted. It must refer to an inactive secret.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deleteApiServiceIntegrationInstanceSecret'."
]:
    """Delete an inactive API service integration secret.

    Use this tool to delete an inactive secret from an API service integration using the specified `secretId`. This operation is only possible for secrets that are no longer active."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/integrations/api/v1/api-services/{apiServiceId}/credentials/secrets/{secretId}".format(  # noqa: UP032
            apiServiceId=api_service_integration_instance_id, secretId=secret_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.oauthIntegrations.manage"]))
async def activate_service_integration_secret(
    context: ToolContext,
    service_integration_instance_id: Annotated[
        str, "The `id` of the API Service Integration instance to activate the secret for."
    ],
    secret_id: Annotated[
        str,
        "The ID of the API Service Integration instance Secret to activate. Provide a valid secret identifier.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'activateApiServiceIntegrationInstanceSecret'."
]:
    """Activate an API Service Integration instance secret.

    Use this tool to activate a specific secret for an API service integration instance by providing the `secretId`."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/integrations/api/v1/api-services/{apiServiceId}/credentials/secrets/{secretId}/lifecycle/activate".format(  # noqa: UP032
            apiServiceId=service_integration_instance_id, secretId=secret_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.oauthIntegrations.manage"]))
async def deactivate_service_secret(
    context: ToolContext,
    api_service_integration_instance_id: Annotated[
        str, "The ID of the API Service Integration instance to deactivate the secret for."
    ],
    secret_id: Annotated[
        str, "The ID of the API Service Integration instance secret to be deactivated."
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'deactivateApiServiceIntegrationInstanceSecret'.",
]:
    """Deactivate an API Service Integration instance secret.

    Use this tool to deactivate a specific secret in an API Service Integration instance, identified by `secretId`. It should be called when you need to revoke access associated with that secret."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/integrations/api/v1/api-services/{apiServiceId}/credentials/secrets/{secretId}/lifecycle/deactivate".format(  # noqa: UP032
            apiServiceId=api_service_integration_instance_id, secretId=secret_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def list_roles_for_client(
    context: ToolContext,
    client_app_id: Annotated[
        str, "The unique identifier of the client application for which roles are being listed."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listRolesForClient'."]:
    """Lists all roles assigned to a specific client app.

    Use this tool to retrieve all roles assigned to a client application by providing the client ID. This can help in understanding client access and permissions."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/oauth2/v1/clients/{clientId}/roles".format(  # noqa: UP032
            clientId=client_app_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def get_client_role_assignment(
    context: ToolContext,
    client_app_id: Annotated[
        str,
        "The unique identifier for the client application. Required for fetching its role assignment.",  # noqa: E501
    ],
    role_assignment_id: Annotated[
        str, "The ID of the role assignment to retrieve for the client app."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'retrieveClientRole'."]:
    """Retrieve a specific role assignment for a client app.

    Fetches the role assignment details for a client application using the specified client ID and role assignment ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/oauth2/v1/clients/{clientId}/roles/{roleAssignmentId}".format(  # noqa: UP032
            clientId=client_app_id, roleAssignmentId=role_assignment_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def unassign_role_from_client(
    context: ToolContext,
    client_app_id: Annotated[
        str,
        "The unique identifier for the client application from which the role will be unassigned.",
    ],
    role_assignment_id: Annotated[
        str, "The unique identifier for the role assignment to be unassigned from the client app."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteRoleFromClient'."]:
    """Unassigns a role from a client app in Okta.

    Use this tool to remove a specific role assignment from a client app in Okta, specified by the role assignment ID and client ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/oauth2/v1/clients/{clientId}/roles/{roleAssignmentId}".format(  # noqa: UP032
            clientId=client_app_id, roleAssignmentId=role_assignment_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def list_app_targets_for_admin_role(
    context: ToolContext,
    client_application_id: Annotated[
        str,
        "The unique identifier for the client application. Use this ID to specify which client's APP_ADMIN role targets to list.",  # noqa: E501
    ],
    role_assignment_id: Annotated[
        str,
        "The ID of the role assignment to identify the specific role assignment for the client.",
    ],
    pagination_cursor: Annotated[
        str | None, "The cursor for pagination, an opaque string from the `Link` response header."
    ] = None,
    max_results_limit: Annotated[
        int | None, "Maximum number of objects to return in the response."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAppTargetRoleToClient'."]:
    """Retrieve OIN app targets for a specified APP_ADMIN role.

    This tool is used to list all OIN app targets for an APP_ADMIN role assigned to a client, identified by clientId. It is useful for managing and reviewing application targets associated with specific administrative roles."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/oauth2/v1/clients/{clientId}/roles/{roleAssignmentId}/targets/catalog/apps".format(  # noqa: UP032
            clientId=client_application_id, roleAssignmentId=role_assignment_id
        ),
        method="GET",
        params=remove_none_values({"after": pagination_cursor, "limit": max_results_limit}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def assign_app_target_role_to_client(
    context: ToolContext,
    client_app_id: Annotated[
        str, "The unique identifier for the client application to which the role is being assigned."
    ],
    role_assignment_id: Annotated[
        str, "The ID of the role assignment to specify which role to assign to the client."
    ],
    oin_app_key_name: Annotated[
        str, "The key name of the app from the OIN catalog to assign for the role."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'assignAppTargetRoleToClient'."]:
    """Assign an OIN app target role to a client.

    This tool assigns a specific app target from the OIN catalog for an `APP_ADMIN` role to a client. It should be called when you want to narrow the scope of an app role assignment, affecting only app instances specified by the app name. It updates any existing app instance targets with the assigned app target."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/oauth2/v1/clients/{clientId}/roles/{roleAssignmentId}/targets/catalog/apps/{appName}".format(  # noqa: UP032
            clientId=client_app_id, roleAssignmentId=role_assignment_id, appName=oin_app_key_name
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def unassign_app_role_from_client(
    context: ToolContext,
    client_app_id: Annotated[
        str, "The unique identifier for the client application from which to unassign the role."
    ],
    role_assignment_id: Annotated[
        str,
        "The ID of the role assignment to unassign from the client app. Must be a valid string identifier.",  # noqa: E501
    ],
    app_name: Annotated[
        str,
        "The name of the app definition from the OIN catalog, used to unassign the target role.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'removeAppTargetRoleFromClient'."]:
    """Unassigns a role target from a client app in Okta.

    Use this tool to unassign an OIN app target for a role assignment from a client app in Okta. Note that you cannot remove the last OIN app target from a role assignment. If a role assignment needs to apply to all apps, delete the existing assignment and create a new one."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/oauth2/v1/clients/{clientId}/roles/{roleAssignmentId}/targets/catalog/apps/{appName}".format(  # noqa: UP032
            clientId=client_app_id, roleAssignmentId=role_assignment_id, appName=app_name
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def assign_app_instance_role_to_client(
    context: ToolContext,
    client_app_id: Annotated[
        str,
        "The unique identifier for the client application. This specifies which client the app instance target will be assigned to under the APP_ADMIN role.",  # noqa: E501
    ],
    role_assignment_id: Annotated[
        str,
        "The `id` of the role assignment for the client. This is required to specify which role is being assigned to the app instance target.",  # noqa: E501
    ],
    app_definition_name: Annotated[
        str, "The name of the app definition as listed in the OIN catalog."
    ],
    application_id: Annotated[
        str, "Unique identifier for the application instance to assign a role."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'assignAppTargetInstanceRoleForClient'."
]:
    """Assigns an app instance target to a client's APP_ADMIN role.

    This tool assigns a specific app instance target to an APP_ADMIN role for a client, reducing the role's scope to only the specified target. It should be called when you need to manage permissions at the app instance level for a client."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/oauth2/v1/clients/{clientId}/roles/{roleAssignmentId}/targets/catalog/apps/{appName}/{appId}".format(  # noqa: UP032
            clientId=client_app_id,
            roleAssignmentId=role_assignment_id,
            appName=app_definition_name,
            appId=application_id,
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def unassign_app_instance_target(
    context: ToolContext,
    client_app_id: Annotated[
        str,
        "The unique identifier for the client application from which an app instance target will be unassigned.",  # noqa: E501
    ],
    role_assignment_id: Annotated[
        str, "The ID of the role assignment to be unassigned from the app instance target."
    ],
    app_name: Annotated[
        str,
        "Specify the name of the app definition from the OIN catalog (app key name) to unassign the target from the client role.",  # noqa: E501
    ],
    application_id: Annotated[
        str,
        "The unique identifier for the application to unassign from the role. This should match the app's ID in the OIN catalog.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'removeAppTargetInstanceRoleForClient'."
]:
    """Unassign an app instance target from a client app role.

    This tool removes an app instance target from a role assignment within a client application. It should be called when you need to unassign a specific app instance from a client app's role, ensuring you have more than one target assigned. For removing all targets, delete the whole role assignment instead."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/oauth2/v1/clients/{clientId}/roles/{roleAssignmentId}/targets/catalog/apps/{appName}/{appId}".format(  # noqa: UP032
            clientId=client_app_id,
            roleAssignmentId=role_assignment_id,
            appName=app_name,
            appId=application_id,
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.read"]))
async def list_group_targets_for_client_role(
    context: ToolContext,
    client_app_id: Annotated[
        str,
        "The unique identifier of the client application for which the role group targets are being listed.",  # noqa: E501
    ],
    role_assignment_id: Annotated[
        str,
        "The ID of the role assignment for which to list group targets. It specifies the role tied to the specific client.",  # noqa: E501
    ],
    pagination_cursor: Annotated[
        str | None,
        "The opaque string cursor for pagination, indicating the current position in the list. Obtain this from the `Link` response header.",  # noqa: E501
    ] = None,
    object_limit: Annotated[int | None, "Specify the maximum number of objects to return."] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listGroupTargetRoleForClient'."]:
    """Retrieve group targets for a specified client role assignment.

    Use this tool to list all group targets associated with a specified role assignment (`USER_ADMIN`, `HELP_DESK_ADMIN`, or `GROUP_MEMBERSHIP_ADMIN`) for a client. If no specific group targets are scoped, an empty array will be returned."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/oauth2/v1/clients/{clientId}/roles/{roleAssignmentId}/targets/groups".format(  # noqa: UP032
            clientId=client_app_id, roleAssignmentId=role_assignment_id
        ),
        method="GET",
        params=remove_none_values({"after": pagination_cursor, "limit": object_limit}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def assign_group_target_role_for_client(
    context: ToolContext,
    client_app_id: Annotated[
        str, "The ID of the client application to which the group target role is assigned."
    ],
    role_assignment_id: Annotated[
        str, "The unique identifier of the role assignment to be targeted."
    ],
    group_id_for_role_assignment: Annotated[
        str, "The identifier of the group to which the role will be assigned for the client app."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'assignGroupTargetRoleForClient'."]:
    """Assign a group target role to a client app.

    Use this tool to assign a group target to a specific role (`USER_ADMIN`, `HELP_DESK_ADMIN`, or `GROUP_MEMBERSHIP_ADMIN`) for a client app. This reduces the scope of the role assignment by applying it only to the specified target group."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/oauth2/v1/clients/{clientId}/roles/{roleAssignmentId}/targets/groups/{groupId}".format(  # noqa: UP032
            clientId=client_app_id,
            roleAssignmentId=role_assignment_id,
            groupId=group_id_for_role_assignment,
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.roles.manage"]))
async def remove_group_target_role(
    context: ToolContext,
    client_app_id: Annotated[
        str,
        "The unique identifier for the client application from which the group target will be removed.",  # noqa: E501
    ],
    role_assignment_id: Annotated[
        str,
        "The unique identifier for the role assignment to modify. This ID specifies which role assignment the group target will be removed from. Ensure it does not refer to the last group target in a role.",  # noqa: E501
    ],
    group_id: Annotated[
        str, "The unique ID of the group to be unassigned from the role in the client app."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'removeGroupTargetRoleFromClient'."]:
    """Removes a group target from a role in a client app.

    This tool unassigns a specified group target from roles such as `USER_ADMIN`, `HELP_DESK_ADMIN`, or `GROUP_MEMBERSHIP_ADMIN` in a client application. Note that it cannot remove the last group target in a role assignment."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/oauth2/v1/clients/{clientId}/roles/{roleAssignmentId}/targets/groups/{groupId}".format(  # noqa: UP032
            clientId=client_app_id, roleAssignmentId=role_assignment_id, groupId=group_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.personal.adminSettings.read"]))
async def list_blocked_email_domains(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listPersonalAppsExportBlockList'."]:
    """Retrieve blocked email domains for app migration exclusion.

    This tool retrieves a list of all blocked email domains that are excluded from app migration. Useful for checking which domains are currently blocked for this purpose."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/okta-personal-settings/api/v1/export-blocklists",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.serviceAccounts.read"]))
async def list_app_service_accounts(
    context: ToolContext,
    number_of_accounts_limit: Annotated[
        int | None, "The maximum number of app service accounts to return in the response."
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "An opaque string for pagination, indicating current position in the list. Obtained from the `Link` response header.",  # noqa: E501
    ] = None,
    search_account_value: Annotated[
        str | None,
        "Provides a search string to filter app service accounts by name, username, instance label, or key name.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listAppServiceAccounts'."]:
    """Retrieve all app service accounts from Okta.

    Use this tool to list all application service accounts in Okta's privileged-access API. It helps to manage and monitor service account details efficiently."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/privileged-access/api/v1/service-accounts",
        method="GET",
        params=remove_none_values({
            "limit": number_of_accounts_limit,
            "after": pagination_cursor,
            "match": search_account_value,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.serviceAccounts.read"]))
async def retrieve_service_account(
    context: ToolContext,
    service_account_id: Annotated[
        str, "The unique identifier of an existing service account to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getAppServiceAccount'."]:
    """Retrieve details of an app service account by ID.

    This tool retrieves information for a specific app service account using its ID. Use it to access service account details in Okta."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/privileged-access/api/v1/service-accounts/{id}".format(  # noqa: UP032
            id=service_account_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.serviceAccounts.manage"]))
async def delete_service_account(
    context: ToolContext,
    service_account_id: Annotated[str, "ID of the service account to be deleted."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteAppServiceAccount'."]:
    """Delete a specified app service account by ID.

    Use this tool to delete an app service account using its ID when managing account access or performing cleanup operations."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/privileged-access/api/v1/service-accounts/{id}".format(  # noqa: UP032
            id=service_account_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta"))
async def publish_security_event_tokens(
    context: ToolContext,
    signed_security_event_token: Annotated[
        str, "A signed Security Event Token (SET), formatted as a JSON Web Token (JWT)."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'publishSecurityEventTokens'."]:
    """Publish a Security Event Token to Okta.

    Use this tool to send a Security Event Token from a Security Events Provider to Okta. After verification, Okta ingests the event and triggers any appropriate actions."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/security/api/v1/security-events",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({"requestBody": signed_security_event_token}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.read"]))
async def list_webauthn_preregistration_factors(
    context: ToolContext,
    user_id: Annotated[
        str, "ID of an existing Okta user to retrieve their WebAuthn preregistration factors."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'listWebAuthnPreregistrationFactors'."
]:
    """Get WebAuthn preregistration factors for a user.

    Use this tool to retrieve all WebAuthn preregistration factors for a specified user. Useful for managing or verifying user authentication methods."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/webauthn-registration/api/v1/users/{userId}/enrollments".format(  # noqa: UP032
            userId=user_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def delete_webauthn_preregistration(
    context: ToolContext,
    okta_user_id: Annotated[
        str,
        "The unique identifier of an existing user in Okta for whom the WebAuthn preregistration factor should be deleted.",  # noqa: E501
    ],
    webauthn_preregistration_id: Annotated[
        str, "ID for a WebAuthn preregistration factor in Okta to be deleted."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'deleteWebAuthnPreregistrationFactor'."
]:
    """Deletes a specific WebAuthn preregistration factor for a user.

    Use this tool to delete a WebAuthn preregistration factor associated with a user, identified by the user ID and authenticator enrollment ID."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/webauthn-registration/api/v1/users/{userId}/enrollments/{authenticatorEnrollmentId}".format(  # noqa: UP032
            userId=okta_user_id, authenticatorEnrollmentId=webauthn_preregistration_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-okta", scopes=["okta.users.manage"]))
async def assign_webauthn_error_status(
    context: ToolContext,
    user_id: Annotated[
        str, "ID of an existing Okta user to whom the error status will be assigned."
    ],
    webauthn_preregistration_factor_id: Annotated[
        str, "ID for a WebAuthn preregistration factor in Okta."
    ],
) -> Annotated[
    dict[str, Any],
    "Response from the API endpoint 'assignFulfillmentErrorWebAuthnPreregistrationFactor'.",
]:
    """Assigns an error status to a user's WebAuthn preregistration.

    Use this tool to assign a fulfillment error status to a WebAuthn preregistration factor for a user. This sets the specific 'FULFILLMENT_ERRORED' status on the enrollment."""  # noqa: E501
    response = await make_request(
        url="https://{yourOktaDomain}/webauthn-registration/api/v1/users/{userId}/enrollments/{authenticatorEnrollmentId}/mark-error".format(  # noqa: UP032
            userId=user_id, authenticatorEnrollmentId=webauthn_preregistration_factor_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}
